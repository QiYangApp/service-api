// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"service-api/src/models/ent/member"
	"service-api/src/models/ent/memberauthorizelog"
	"service-api/src/models/ent/memberrelatedrole"
	"service-api/src/models/ent/memberrole"
	"service-api/src/models/ent/memberrolerelatedpermission"
	"service-api/src/models/ent/permissiongroup"
	"service-api/src/models/ent/permissionrelatedrouter"
	"service-api/src/models/ent/predicate"
	"service-api/src/models/ent/router"
	"service-api/src/models/ent/sourcedata"
	"service-api/src/models/ent/wakatime"
	"service-api/src/models/ent/wakatimecategory"
	"service-api/src/models/ent/wakatimedependency"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMember                      = "Member"
	TypeMemberAuthorizeLog          = "MemberAuthorizeLog"
	TypeMemberRelatedRole           = "MemberRelatedRole"
	TypeMemberRole                  = "MemberRole"
	TypeMemberRoleRelatedPermission = "MemberRoleRelatedPermission"
	TypePermissionGroup             = "PermissionGroup"
	TypePermissionRelatedRouter     = "PermissionRelatedRouter"
	TypeRouter                      = "Router"
	TypeSourceData                  = "SourceData"
	TypeWakatime                    = "Wakatime"
	TypeWakatimeCategory            = "WakatimeCategory"
	TypeWakatimeDependency          = "WakatimeDependency"
	TypeWakatimeDuration            = "WakatimeDuration"
	TypeWakatimeEditor              = "WakatimeEditor"
	TypeWakatimeEntity              = "WakatimeEntity"
	TypeWakatimeGrandTotal          = "WakatimeGrandTotal"
	TypeWakatimeHeartBeat           = "WakatimeHeartBeat"
	TypeWakatimeLanguage            = "WakatimeLanguage"
	TypeWakatimeProject             = "WakatimeProject"
	TypeWakatimeProjectDuration     = "WakatimeProjectDuration"
	TypeWakatimeProjectInfo         = "WakatimeProjectInfo"
	TypeWakatimeSystem              = "WakatimeSystem"
)

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	email         *string
	avatar        *string
	password_sing *string
	password      *string
	mobile        *string
	nickname      *string
	state         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Member, error)
	predicates    []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id uuid.UUID) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MemberMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MemberMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MemberMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MemberMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MemberMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MemberMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *MemberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberMutation) ResetEmail() {
	m.email = nil
}

// SetAvatar sets the "avatar" field.
func (m *MemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberMutation) ResetAvatar() {
	m.avatar = nil
}

// SetPasswordSing sets the "password_sing" field.
func (m *MemberMutation) SetPasswordSing(s string) {
	m.password_sing = &s
}

// PasswordSing returns the value of the "password_sing" field in the mutation.
func (m *MemberMutation) PasswordSing() (r string, exists bool) {
	v := m.password_sing
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordSing returns the old "password_sing" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPasswordSing(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordSing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordSing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordSing: %w", err)
	}
	return oldValue.PasswordSing, nil
}

// ResetPasswordSing resets all changes to the "password_sing" field.
func (m *MemberMutation) ResetPasswordSing() {
	m.password_sing = nil
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
}

// SetMobile sets the "mobile" field.
func (m *MemberMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *MemberMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *MemberMutation) ResetMobile() {
	m.mobile = nil
}

// SetNickname sets the "nickname" field.
func (m *MemberMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *MemberMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *MemberMutation) ResetNickname() {
	m.nickname = nil
}

// SetState sets the "state" field.
func (m *MemberMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *MemberMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *MemberMutation) ResetState() {
	m.state = nil
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, member.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, member.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, member.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, member.FieldAvatar)
	}
	if m.password_sing != nil {
		fields = append(fields, member.FieldPasswordSing)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.mobile != nil {
		fields = append(fields, member.FieldMobile)
	}
	if m.nickname != nil {
		fields = append(fields, member.FieldNickname)
	}
	if m.state != nil {
		fields = append(fields, member.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreateTime:
		return m.CreateTime()
	case member.FieldUpdateTime:
		return m.UpdateTime()
	case member.FieldEmail:
		return m.Email()
	case member.FieldAvatar:
		return m.Avatar()
	case member.FieldPasswordSing:
		return m.PasswordSing()
	case member.FieldPassword:
		return m.Password()
	case member.FieldMobile:
		return m.Mobile()
	case member.FieldNickname:
		return m.Nickname()
	case member.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case member.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case member.FieldEmail:
		return m.OldEmail(ctx)
	case member.FieldAvatar:
		return m.OldAvatar(ctx)
	case member.FieldPasswordSing:
		return m.OldPasswordSing(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldMobile:
		return m.OldMobile(ctx)
	case member.FieldNickname:
		return m.OldNickname(ctx)
	case member.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case member.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case member.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case member.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case member.FieldPasswordSing:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordSing(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case member.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case member.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case member.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case member.FieldEmail:
		m.ResetEmail()
		return nil
	case member.FieldAvatar:
		m.ResetAvatar()
		return nil
	case member.FieldPasswordSing:
		m.ResetPasswordSing()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldMobile:
		m.ResetMobile()
		return nil
	case member.FieldNickname:
		m.ResetNickname()
		return nil
	case member.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Member edge %s", name)
}

// MemberAuthorizeLogMutation represents an operation that mutates the MemberAuthorizeLog nodes in the graph.
type MemberAuthorizeLogMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	member_id     *uuid.UUID
	token         *string
	channel       *string
	device        *string
	device_detail *string
	client_ip     *string
	remote_ip     *string
	snapshot      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MemberAuthorizeLog, error)
	predicates    []predicate.MemberAuthorizeLog
}

var _ ent.Mutation = (*MemberAuthorizeLogMutation)(nil)

// memberauthorizelogOption allows management of the mutation configuration using functional options.
type memberauthorizelogOption func(*MemberAuthorizeLogMutation)

// newMemberAuthorizeLogMutation creates new mutation for the MemberAuthorizeLog entity.
func newMemberAuthorizeLogMutation(c config, op Op, opts ...memberauthorizelogOption) *MemberAuthorizeLogMutation {
	m := &MemberAuthorizeLogMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberAuthorizeLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberAuthorizeLogID sets the ID field of the mutation.
func withMemberAuthorizeLogID(id uuid.UUID) memberauthorizelogOption {
	return func(m *MemberAuthorizeLogMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberAuthorizeLog
		)
		m.oldValue = func(ctx context.Context) (*MemberAuthorizeLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberAuthorizeLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberAuthorizeLog sets the old MemberAuthorizeLog of the mutation.
func withMemberAuthorizeLog(node *MemberAuthorizeLog) memberauthorizelogOption {
	return func(m *MemberAuthorizeLogMutation) {
		m.oldValue = func(context.Context) (*MemberAuthorizeLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberAuthorizeLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberAuthorizeLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberAuthorizeLog entities.
func (m *MemberAuthorizeLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberAuthorizeLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberAuthorizeLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberAuthorizeLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MemberAuthorizeLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MemberAuthorizeLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MemberAuthorizeLogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MemberAuthorizeLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MemberAuthorizeLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MemberAuthorizeLogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetMemberID sets the "member_id" field.
func (m *MemberAuthorizeLogMutation) SetMemberID(u uuid.UUID) {
	m.member_id = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberAuthorizeLogMutation) MemberID() (r uuid.UUID, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberAuthorizeLogMutation) ResetMemberID() {
	m.member_id = nil
}

// SetToken sets the "token" field.
func (m *MemberAuthorizeLogMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *MemberAuthorizeLogMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *MemberAuthorizeLogMutation) ResetToken() {
	m.token = nil
}

// SetChannel sets the "channel" field.
func (m *MemberAuthorizeLogMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *MemberAuthorizeLogMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *MemberAuthorizeLogMutation) ResetChannel() {
	m.channel = nil
}

// SetDevice sets the "device" field.
func (m *MemberAuthorizeLogMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *MemberAuthorizeLogMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ResetDevice resets all changes to the "device" field.
func (m *MemberAuthorizeLogMutation) ResetDevice() {
	m.device = nil
}

// SetDeviceDetail sets the "device_detail" field.
func (m *MemberAuthorizeLogMutation) SetDeviceDetail(s string) {
	m.device_detail = &s
}

// DeviceDetail returns the value of the "device_detail" field in the mutation.
func (m *MemberAuthorizeLogMutation) DeviceDetail() (r string, exists bool) {
	v := m.device_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceDetail returns the old "device_detail" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldDeviceDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceDetail: %w", err)
	}
	return oldValue.DeviceDetail, nil
}

// ResetDeviceDetail resets all changes to the "device_detail" field.
func (m *MemberAuthorizeLogMutation) ResetDeviceDetail() {
	m.device_detail = nil
}

// SetClientIP sets the "client_ip" field.
func (m *MemberAuthorizeLogMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *MemberAuthorizeLogMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *MemberAuthorizeLogMutation) ResetClientIP() {
	m.client_ip = nil
}

// SetRemoteIP sets the "remote_ip" field.
func (m *MemberAuthorizeLogMutation) SetRemoteIP(s string) {
	m.remote_ip = &s
}

// RemoteIP returns the value of the "remote_ip" field in the mutation.
func (m *MemberAuthorizeLogMutation) RemoteIP() (r string, exists bool) {
	v := m.remote_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteIP returns the old "remote_ip" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldRemoteIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteIP: %w", err)
	}
	return oldValue.RemoteIP, nil
}

// ResetRemoteIP resets all changes to the "remote_ip" field.
func (m *MemberAuthorizeLogMutation) ResetRemoteIP() {
	m.remote_ip = nil
}

// SetSnapshot sets the "snapshot" field.
func (m *MemberAuthorizeLogMutation) SetSnapshot(s string) {
	m.snapshot = &s
}

// Snapshot returns the value of the "snapshot" field in the mutation.
func (m *MemberAuthorizeLogMutation) Snapshot() (r string, exists bool) {
	v := m.snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshot returns the old "snapshot" field's value of the MemberAuthorizeLog entity.
// If the MemberAuthorizeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberAuthorizeLogMutation) OldSnapshot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshot: %w", err)
	}
	return oldValue.Snapshot, nil
}

// ResetSnapshot resets all changes to the "snapshot" field.
func (m *MemberAuthorizeLogMutation) ResetSnapshot() {
	m.snapshot = nil
}

// Where appends a list predicates to the MemberAuthorizeLogMutation builder.
func (m *MemberAuthorizeLogMutation) Where(ps ...predicate.MemberAuthorizeLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberAuthorizeLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberAuthorizeLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberAuthorizeLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberAuthorizeLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberAuthorizeLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberAuthorizeLog).
func (m *MemberAuthorizeLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberAuthorizeLogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, memberauthorizelog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, memberauthorizelog.FieldUpdateTime)
	}
	if m.member_id != nil {
		fields = append(fields, memberauthorizelog.FieldMemberID)
	}
	if m.token != nil {
		fields = append(fields, memberauthorizelog.FieldToken)
	}
	if m.channel != nil {
		fields = append(fields, memberauthorizelog.FieldChannel)
	}
	if m.device != nil {
		fields = append(fields, memberauthorizelog.FieldDevice)
	}
	if m.device_detail != nil {
		fields = append(fields, memberauthorizelog.FieldDeviceDetail)
	}
	if m.client_ip != nil {
		fields = append(fields, memberauthorizelog.FieldClientIP)
	}
	if m.remote_ip != nil {
		fields = append(fields, memberauthorizelog.FieldRemoteIP)
	}
	if m.snapshot != nil {
		fields = append(fields, memberauthorizelog.FieldSnapshot)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberAuthorizeLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberauthorizelog.FieldCreateTime:
		return m.CreateTime()
	case memberauthorizelog.FieldUpdateTime:
		return m.UpdateTime()
	case memberauthorizelog.FieldMemberID:
		return m.MemberID()
	case memberauthorizelog.FieldToken:
		return m.Token()
	case memberauthorizelog.FieldChannel:
		return m.Channel()
	case memberauthorizelog.FieldDevice:
		return m.Device()
	case memberauthorizelog.FieldDeviceDetail:
		return m.DeviceDetail()
	case memberauthorizelog.FieldClientIP:
		return m.ClientIP()
	case memberauthorizelog.FieldRemoteIP:
		return m.RemoteIP()
	case memberauthorizelog.FieldSnapshot:
		return m.Snapshot()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberAuthorizeLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberauthorizelog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case memberauthorizelog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case memberauthorizelog.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberauthorizelog.FieldToken:
		return m.OldToken(ctx)
	case memberauthorizelog.FieldChannel:
		return m.OldChannel(ctx)
	case memberauthorizelog.FieldDevice:
		return m.OldDevice(ctx)
	case memberauthorizelog.FieldDeviceDetail:
		return m.OldDeviceDetail(ctx)
	case memberauthorizelog.FieldClientIP:
		return m.OldClientIP(ctx)
	case memberauthorizelog.FieldRemoteIP:
		return m.OldRemoteIP(ctx)
	case memberauthorizelog.FieldSnapshot:
		return m.OldSnapshot(ctx)
	}
	return nil, fmt.Errorf("unknown MemberAuthorizeLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberAuthorizeLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberauthorizelog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case memberauthorizelog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case memberauthorizelog.FieldMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberauthorizelog.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case memberauthorizelog.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case memberauthorizelog.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case memberauthorizelog.FieldDeviceDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceDetail(v)
		return nil
	case memberauthorizelog.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case memberauthorizelog.FieldRemoteIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteIP(v)
		return nil
	case memberauthorizelog.FieldSnapshot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshot(v)
		return nil
	}
	return fmt.Errorf("unknown MemberAuthorizeLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberAuthorizeLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberAuthorizeLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberAuthorizeLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MemberAuthorizeLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberAuthorizeLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberAuthorizeLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberAuthorizeLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MemberAuthorizeLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberAuthorizeLogMutation) ResetField(name string) error {
	switch name {
	case memberauthorizelog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case memberauthorizelog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case memberauthorizelog.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberauthorizelog.FieldToken:
		m.ResetToken()
		return nil
	case memberauthorizelog.FieldChannel:
		m.ResetChannel()
		return nil
	case memberauthorizelog.FieldDevice:
		m.ResetDevice()
		return nil
	case memberauthorizelog.FieldDeviceDetail:
		m.ResetDeviceDetail()
		return nil
	case memberauthorizelog.FieldClientIP:
		m.ResetClientIP()
		return nil
	case memberauthorizelog.FieldRemoteIP:
		m.ResetRemoteIP()
		return nil
	case memberauthorizelog.FieldSnapshot:
		m.ResetSnapshot()
		return nil
	}
	return fmt.Errorf("unknown MemberAuthorizeLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberAuthorizeLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberAuthorizeLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberAuthorizeLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberAuthorizeLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberAuthorizeLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberAuthorizeLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberAuthorizeLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MemberAuthorizeLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberAuthorizeLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MemberAuthorizeLog edge %s", name)
}

// MemberRelatedRoleMutation represents an operation that mutates the MemberRelatedRole nodes in the graph.
type MemberRelatedRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	member_id     *uuid.UUID
	role_id       *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MemberRelatedRole, error)
	predicates    []predicate.MemberRelatedRole
}

var _ ent.Mutation = (*MemberRelatedRoleMutation)(nil)

// memberrelatedroleOption allows management of the mutation configuration using functional options.
type memberrelatedroleOption func(*MemberRelatedRoleMutation)

// newMemberRelatedRoleMutation creates new mutation for the MemberRelatedRole entity.
func newMemberRelatedRoleMutation(c config, op Op, opts ...memberrelatedroleOption) *MemberRelatedRoleMutation {
	m := &MemberRelatedRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberRelatedRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberRelatedRoleID sets the ID field of the mutation.
func withMemberRelatedRoleID(id uuid.UUID) memberrelatedroleOption {
	return func(m *MemberRelatedRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberRelatedRole
		)
		m.oldValue = func(ctx context.Context) (*MemberRelatedRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberRelatedRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberRelatedRole sets the old MemberRelatedRole of the mutation.
func withMemberRelatedRole(node *MemberRelatedRole) memberrelatedroleOption {
	return func(m *MemberRelatedRoleMutation) {
		m.oldValue = func(context.Context) (*MemberRelatedRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberRelatedRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberRelatedRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberRelatedRole entities.
func (m *MemberRelatedRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberRelatedRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberRelatedRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberRelatedRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MemberRelatedRoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MemberRelatedRoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MemberRelatedRole entity.
// If the MemberRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRelatedRoleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MemberRelatedRoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MemberRelatedRoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MemberRelatedRoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MemberRelatedRole entity.
// If the MemberRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRelatedRoleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MemberRelatedRoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetMemberID sets the "member_id" field.
func (m *MemberRelatedRoleMutation) SetMemberID(u uuid.UUID) {
	m.member_id = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberRelatedRoleMutation) MemberID() (r uuid.UUID, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberRelatedRole entity.
// If the MemberRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRelatedRoleMutation) OldMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberRelatedRoleMutation) ResetMemberID() {
	m.member_id = nil
}

// SetRoleID sets the "role_id" field.
func (m *MemberRelatedRoleMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *MemberRelatedRoleMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the MemberRelatedRole entity.
// If the MemberRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRelatedRoleMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *MemberRelatedRoleMutation) ResetRoleID() {
	m.role_id = nil
}

// Where appends a list predicates to the MemberRelatedRoleMutation builder.
func (m *MemberRelatedRoleMutation) Where(ps ...predicate.MemberRelatedRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberRelatedRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberRelatedRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberRelatedRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberRelatedRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberRelatedRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberRelatedRole).
func (m *MemberRelatedRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberRelatedRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, memberrelatedrole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, memberrelatedrole.FieldUpdateTime)
	}
	if m.member_id != nil {
		fields = append(fields, memberrelatedrole.FieldMemberID)
	}
	if m.role_id != nil {
		fields = append(fields, memberrelatedrole.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberRelatedRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberrelatedrole.FieldCreateTime:
		return m.CreateTime()
	case memberrelatedrole.FieldUpdateTime:
		return m.UpdateTime()
	case memberrelatedrole.FieldMemberID:
		return m.MemberID()
	case memberrelatedrole.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberRelatedRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberrelatedrole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case memberrelatedrole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case memberrelatedrole.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberrelatedrole.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown MemberRelatedRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRelatedRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberrelatedrole.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case memberrelatedrole.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case memberrelatedrole.FieldMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberrelatedrole.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberRelatedRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberRelatedRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberRelatedRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRelatedRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MemberRelatedRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberRelatedRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberRelatedRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberRelatedRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MemberRelatedRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberRelatedRoleMutation) ResetField(name string) error {
	switch name {
	case memberrelatedrole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case memberrelatedrole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case memberrelatedrole.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberrelatedrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown MemberRelatedRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberRelatedRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberRelatedRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberRelatedRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberRelatedRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberRelatedRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberRelatedRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberRelatedRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MemberRelatedRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberRelatedRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MemberRelatedRole edge %s", name)
}

// MemberRoleMutation represents an operation that mutates the MemberRole nodes in the graph.
type MemberRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	role_name     *string
	state         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MemberRole, error)
	predicates    []predicate.MemberRole
}

var _ ent.Mutation = (*MemberRoleMutation)(nil)

// memberroleOption allows management of the mutation configuration using functional options.
type memberroleOption func(*MemberRoleMutation)

// newMemberRoleMutation creates new mutation for the MemberRole entity.
func newMemberRoleMutation(c config, op Op, opts ...memberroleOption) *MemberRoleMutation {
	m := &MemberRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberRoleID sets the ID field of the mutation.
func withMemberRoleID(id uuid.UUID) memberroleOption {
	return func(m *MemberRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberRole
		)
		m.oldValue = func(ctx context.Context) (*MemberRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberRole sets the old MemberRole of the mutation.
func withMemberRole(node *MemberRole) memberroleOption {
	return func(m *MemberRoleMutation) {
		m.oldValue = func(context.Context) (*MemberRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberRole entities.
func (m *MemberRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MemberRoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MemberRoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MemberRole entity.
// If the MemberRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MemberRoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MemberRoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MemberRoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MemberRole entity.
// If the MemberRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MemberRoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRoleName sets the "role_name" field.
func (m *MemberRoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *MemberRoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the MemberRole entity.
// If the MemberRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *MemberRoleMutation) ResetRoleName() {
	m.role_name = nil
}

// SetState sets the "state" field.
func (m *MemberRoleMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *MemberRoleMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the MemberRole entity.
// If the MemberRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *MemberRoleMutation) ResetState() {
	m.state = nil
}

// Where appends a list predicates to the MemberRoleMutation builder.
func (m *MemberRoleMutation) Where(ps ...predicate.MemberRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberRole).
func (m *MemberRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, memberrole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, memberrole.FieldUpdateTime)
	}
	if m.role_name != nil {
		fields = append(fields, memberrole.FieldRoleName)
	}
	if m.state != nil {
		fields = append(fields, memberrole.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberrole.FieldCreateTime:
		return m.CreateTime()
	case memberrole.FieldUpdateTime:
		return m.UpdateTime()
	case memberrole.FieldRoleName:
		return m.RoleName()
	case memberrole.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberrole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case memberrole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case memberrole.FieldRoleName:
		return m.OldRoleName(ctx)
	case memberrole.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown MemberRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberrole.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case memberrole.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case memberrole.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case memberrole.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown MemberRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MemberRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MemberRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberRoleMutation) ResetField(name string) error {
	switch name {
	case memberrole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case memberrole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case memberrole.FieldRoleName:
		m.ResetRoleName()
		return nil
	case memberrole.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown MemberRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MemberRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MemberRole edge %s", name)
}

// MemberRoleRelatedPermissionMutation represents an operation that mutates the MemberRoleRelatedPermission nodes in the graph.
type MemberRoleRelatedPermissionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	create_time         *time.Time
	update_time         *time.Time
	role_id             *uuid.UUID
	permission_group_id *uuid.UUID
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*MemberRoleRelatedPermission, error)
	predicates          []predicate.MemberRoleRelatedPermission
}

var _ ent.Mutation = (*MemberRoleRelatedPermissionMutation)(nil)

// memberrolerelatedpermissionOption allows management of the mutation configuration using functional options.
type memberrolerelatedpermissionOption func(*MemberRoleRelatedPermissionMutation)

// newMemberRoleRelatedPermissionMutation creates new mutation for the MemberRoleRelatedPermission entity.
func newMemberRoleRelatedPermissionMutation(c config, op Op, opts ...memberrolerelatedpermissionOption) *MemberRoleRelatedPermissionMutation {
	m := &MemberRoleRelatedPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberRoleRelatedPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberRoleRelatedPermissionID sets the ID field of the mutation.
func withMemberRoleRelatedPermissionID(id uuid.UUID) memberrolerelatedpermissionOption {
	return func(m *MemberRoleRelatedPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberRoleRelatedPermission
		)
		m.oldValue = func(ctx context.Context) (*MemberRoleRelatedPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberRoleRelatedPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberRoleRelatedPermission sets the old MemberRoleRelatedPermission of the mutation.
func withMemberRoleRelatedPermission(node *MemberRoleRelatedPermission) memberrolerelatedpermissionOption {
	return func(m *MemberRoleRelatedPermissionMutation) {
		m.oldValue = func(context.Context) (*MemberRoleRelatedPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberRoleRelatedPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberRoleRelatedPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberRoleRelatedPermission entities.
func (m *MemberRoleRelatedPermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberRoleRelatedPermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberRoleRelatedPermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberRoleRelatedPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MemberRoleRelatedPermissionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MemberRoleRelatedPermissionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MemberRoleRelatedPermissionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MemberRoleRelatedPermissionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRoleID sets the "role_id" field.
func (m *MemberRoleRelatedPermissionMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *MemberRoleRelatedPermissionMutation) ResetRoleID() {
	m.role_id = nil
}

// SetPermissionGroupID sets the "permission_group_id" field.
func (m *MemberRoleRelatedPermissionMutation) SetPermissionGroupID(u uuid.UUID) {
	m.permission_group_id = &u
}

// PermissionGroupID returns the value of the "permission_group_id" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) PermissionGroupID() (r uuid.UUID, exists bool) {
	v := m.permission_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionGroupID returns the old "permission_group_id" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldPermissionGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionGroupID: %w", err)
	}
	return oldValue.PermissionGroupID, nil
}

// ResetPermissionGroupID resets all changes to the "permission_group_id" field.
func (m *MemberRoleRelatedPermissionMutation) ResetPermissionGroupID() {
	m.permission_group_id = nil
}

// Where appends a list predicates to the MemberRoleRelatedPermissionMutation builder.
func (m *MemberRoleRelatedPermissionMutation) Where(ps ...predicate.MemberRoleRelatedPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberRoleRelatedPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberRoleRelatedPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberRoleRelatedPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberRoleRelatedPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberRoleRelatedPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberRoleRelatedPermission).
func (m *MemberRoleRelatedPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberRoleRelatedPermissionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, memberrolerelatedpermission.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, memberrolerelatedpermission.FieldUpdateTime)
	}
	if m.role_id != nil {
		fields = append(fields, memberrolerelatedpermission.FieldRoleID)
	}
	if m.permission_group_id != nil {
		fields = append(fields, memberrolerelatedpermission.FieldPermissionGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberRoleRelatedPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberrolerelatedpermission.FieldCreateTime:
		return m.CreateTime()
	case memberrolerelatedpermission.FieldUpdateTime:
		return m.UpdateTime()
	case memberrolerelatedpermission.FieldRoleID:
		return m.RoleID()
	case memberrolerelatedpermission.FieldPermissionGroupID:
		return m.PermissionGroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberRoleRelatedPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberrolerelatedpermission.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case memberrolerelatedpermission.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case memberrolerelatedpermission.FieldRoleID:
		return m.OldRoleID(ctx)
	case memberrolerelatedpermission.FieldPermissionGroupID:
		return m.OldPermissionGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown MemberRoleRelatedPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRoleRelatedPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberrolerelatedpermission.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case memberrolerelatedpermission.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case memberrolerelatedpermission.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case memberrolerelatedpermission.FieldPermissionGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberRoleRelatedPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberRoleRelatedPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRoleRelatedPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MemberRoleRelatedPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberRoleRelatedPermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberRoleRelatedPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MemberRoleRelatedPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ResetField(name string) error {
	switch name {
	case memberrolerelatedpermission.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case memberrolerelatedpermission.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case memberrolerelatedpermission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case memberrolerelatedpermission.FieldPermissionGroupID:
		m.ResetPermissionGroupID()
		return nil
	}
	return fmt.Errorf("unknown MemberRoleRelatedPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberRoleRelatedPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberRoleRelatedPermissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberRoleRelatedPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberRoleRelatedPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberRoleRelatedPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberRoleRelatedPermissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MemberRoleRelatedPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MemberRoleRelatedPermission edge %s", name)
}

// PermissionGroupMutation represents an operation that mutates the PermissionGroup nodes in the graph.
type PermissionGroupMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	create_time     *time.Time
	update_time     *time.Time
	permission_name *string
	ioc             *string
	sort            *int32
	addsort         *int32
	left            *int32
	addleft         *int32
	right           *int32
	addright        *int32
	state           *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PermissionGroup, error)
	predicates      []predicate.PermissionGroup
}

var _ ent.Mutation = (*PermissionGroupMutation)(nil)

// permissiongroupOption allows management of the mutation configuration using functional options.
type permissiongroupOption func(*PermissionGroupMutation)

// newPermissionGroupMutation creates new mutation for the PermissionGroup entity.
func newPermissionGroupMutation(c config, op Op, opts ...permissiongroupOption) *PermissionGroupMutation {
	m := &PermissionGroupMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionGroupID sets the ID field of the mutation.
func withPermissionGroupID(id uuid.UUID) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionGroup
		)
		m.oldValue = func(ctx context.Context) (*PermissionGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionGroup sets the old PermissionGroup of the mutation.
func withPermissionGroup(node *PermissionGroup) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		m.oldValue = func(context.Context) (*PermissionGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionGroup entities.
func (m *PermissionGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PermissionGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PermissionGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PermissionGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PermissionGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PermissionGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PermissionGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPermissionName sets the "permission_name" field.
func (m *PermissionGroupMutation) SetPermissionName(s string) {
	m.permission_name = &s
}

// PermissionName returns the value of the "permission_name" field in the mutation.
func (m *PermissionGroupMutation) PermissionName() (r string, exists bool) {
	v := m.permission_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionName returns the old "permission_name" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldPermissionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionName: %w", err)
	}
	return oldValue.PermissionName, nil
}

// ResetPermissionName resets all changes to the "permission_name" field.
func (m *PermissionGroupMutation) ResetPermissionName() {
	m.permission_name = nil
}

// SetIoc sets the "ioc" field.
func (m *PermissionGroupMutation) SetIoc(s string) {
	m.ioc = &s
}

// Ioc returns the value of the "ioc" field in the mutation.
func (m *PermissionGroupMutation) Ioc() (r string, exists bool) {
	v := m.ioc
	if v == nil {
		return
	}
	return *v, true
}

// OldIoc returns the old "ioc" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldIoc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoc: %w", err)
	}
	return oldValue.Ioc, nil
}

// ResetIoc resets all changes to the "ioc" field.
func (m *PermissionGroupMutation) ResetIoc() {
	m.ioc = nil
}

// SetSort sets the "sort" field.
func (m *PermissionGroupMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PermissionGroupMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *PermissionGroupMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PermissionGroupMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *PermissionGroupMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetLeft sets the "left" field.
func (m *PermissionGroupMutation) SetLeft(i int32) {
	m.left = &i
	m.addleft = nil
}

// Left returns the value of the "left" field in the mutation.
func (m *PermissionGroupMutation) Left() (r int32, exists bool) {
	v := m.left
	if v == nil {
		return
	}
	return *v, true
}

// OldLeft returns the old "left" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldLeft(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeft: %w", err)
	}
	return oldValue.Left, nil
}

// AddLeft adds i to the "left" field.
func (m *PermissionGroupMutation) AddLeft(i int32) {
	if m.addleft != nil {
		*m.addleft += i
	} else {
		m.addleft = &i
	}
}

// AddedLeft returns the value that was added to the "left" field in this mutation.
func (m *PermissionGroupMutation) AddedLeft() (r int32, exists bool) {
	v := m.addleft
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeft resets all changes to the "left" field.
func (m *PermissionGroupMutation) ResetLeft() {
	m.left = nil
	m.addleft = nil
}

// SetRight sets the "right" field.
func (m *PermissionGroupMutation) SetRight(i int32) {
	m.right = &i
	m.addright = nil
}

// Right returns the value of the "right" field in the mutation.
func (m *PermissionGroupMutation) Right() (r int32, exists bool) {
	v := m.right
	if v == nil {
		return
	}
	return *v, true
}

// OldRight returns the old "right" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldRight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRight: %w", err)
	}
	return oldValue.Right, nil
}

// AddRight adds i to the "right" field.
func (m *PermissionGroupMutation) AddRight(i int32) {
	if m.addright != nil {
		*m.addright += i
	} else {
		m.addright = &i
	}
}

// AddedRight returns the value that was added to the "right" field in this mutation.
func (m *PermissionGroupMutation) AddedRight() (r int32, exists bool) {
	v := m.addright
	if v == nil {
		return
	}
	return *v, true
}

// ResetRight resets all changes to the "right" field.
func (m *PermissionGroupMutation) ResetRight() {
	m.right = nil
	m.addright = nil
}

// SetState sets the "state" field.
func (m *PermissionGroupMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PermissionGroupMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PermissionGroupMutation) ResetState() {
	m.state = nil
}

// Where appends a list predicates to the PermissionGroupMutation builder.
func (m *PermissionGroupMutation) Where(ps ...predicate.PermissionGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionGroup).
func (m *PermissionGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionGroupMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, permissiongroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, permissiongroup.FieldUpdateTime)
	}
	if m.permission_name != nil {
		fields = append(fields, permissiongroup.FieldPermissionName)
	}
	if m.ioc != nil {
		fields = append(fields, permissiongroup.FieldIoc)
	}
	if m.sort != nil {
		fields = append(fields, permissiongroup.FieldSort)
	}
	if m.left != nil {
		fields = append(fields, permissiongroup.FieldLeft)
	}
	if m.right != nil {
		fields = append(fields, permissiongroup.FieldRight)
	}
	if m.state != nil {
		fields = append(fields, permissiongroup.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldCreateTime:
		return m.CreateTime()
	case permissiongroup.FieldUpdateTime:
		return m.UpdateTime()
	case permissiongroup.FieldPermissionName:
		return m.PermissionName()
	case permissiongroup.FieldIoc:
		return m.Ioc()
	case permissiongroup.FieldSort:
		return m.Sort()
	case permissiongroup.FieldLeft:
		return m.Left()
	case permissiongroup.FieldRight:
		return m.Right()
	case permissiongroup.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissiongroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case permissiongroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case permissiongroup.FieldPermissionName:
		return m.OldPermissionName(ctx)
	case permissiongroup.FieldIoc:
		return m.OldIoc(ctx)
	case permissiongroup.FieldSort:
		return m.OldSort(ctx)
	case permissiongroup.FieldLeft:
		return m.OldLeft(ctx)
	case permissiongroup.FieldRight:
		return m.OldRight(ctx)
	case permissiongroup.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case permissiongroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case permissiongroup.FieldPermissionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionName(v)
		return nil
	case permissiongroup.FieldIoc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoc(v)
		return nil
	case permissiongroup.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case permissiongroup.FieldLeft:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeft(v)
		return nil
	case permissiongroup.FieldRight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRight(v)
		return nil
	case permissiongroup.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionGroupMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, permissiongroup.FieldSort)
	}
	if m.addleft != nil {
		fields = append(fields, permissiongroup.FieldLeft)
	}
	if m.addright != nil {
		fields = append(fields, permissiongroup.FieldRight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldSort:
		return m.AddedSort()
	case permissiongroup.FieldLeft:
		return m.AddedLeft()
	case permissiongroup.FieldRight:
		return m.AddedRight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case permissiongroup.FieldLeft:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeft(v)
		return nil
	case permissiongroup.FieldRight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRight(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PermissionGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ResetField(name string) error {
	switch name {
	case permissiongroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case permissiongroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case permissiongroup.FieldPermissionName:
		m.ResetPermissionName()
		return nil
	case permissiongroup.FieldIoc:
		m.ResetIoc()
		return nil
	case permissiongroup.FieldSort:
		m.ResetSort()
		return nil
	case permissiongroup.FieldLeft:
		m.ResetLeft()
		return nil
	case permissiongroup.FieldRight:
		m.ResetRight()
		return nil
	case permissiongroup.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionGroup edge %s", name)
}

// PermissionRelatedRouterMutation represents an operation that mutates the PermissionRelatedRouter nodes in the graph.
type PermissionRelatedRouterMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	create_time         *time.Time
	update_time         *time.Time
	router_id           *uuid.UUID
	permission_group_id *uuid.UUID
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*PermissionRelatedRouter, error)
	predicates          []predicate.PermissionRelatedRouter
}

var _ ent.Mutation = (*PermissionRelatedRouterMutation)(nil)

// permissionrelatedrouterOption allows management of the mutation configuration using functional options.
type permissionrelatedrouterOption func(*PermissionRelatedRouterMutation)

// newPermissionRelatedRouterMutation creates new mutation for the PermissionRelatedRouter entity.
func newPermissionRelatedRouterMutation(c config, op Op, opts ...permissionrelatedrouterOption) *PermissionRelatedRouterMutation {
	m := &PermissionRelatedRouterMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionRelatedRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionRelatedRouterID sets the ID field of the mutation.
func withPermissionRelatedRouterID(id uuid.UUID) permissionrelatedrouterOption {
	return func(m *PermissionRelatedRouterMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionRelatedRouter
		)
		m.oldValue = func(ctx context.Context) (*PermissionRelatedRouter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionRelatedRouter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionRelatedRouter sets the old PermissionRelatedRouter of the mutation.
func withPermissionRelatedRouter(node *PermissionRelatedRouter) permissionrelatedrouterOption {
	return func(m *PermissionRelatedRouterMutation) {
		m.oldValue = func(context.Context) (*PermissionRelatedRouter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionRelatedRouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionRelatedRouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionRelatedRouter entities.
func (m *PermissionRelatedRouterMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionRelatedRouterMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionRelatedRouterMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionRelatedRouter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PermissionRelatedRouterMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PermissionRelatedRouterMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PermissionRelatedRouterMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PermissionRelatedRouterMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PermissionRelatedRouterMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PermissionRelatedRouterMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRouterID sets the "router_id" field.
func (m *PermissionRelatedRouterMutation) SetRouterID(u uuid.UUID) {
	m.router_id = &u
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *PermissionRelatedRouterMutation) RouterID() (r uuid.UUID, exists bool) {
	v := m.router_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldRouterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *PermissionRelatedRouterMutation) ResetRouterID() {
	m.router_id = nil
}

// SetPermissionGroupID sets the "permission_group_id" field.
func (m *PermissionRelatedRouterMutation) SetPermissionGroupID(u uuid.UUID) {
	m.permission_group_id = &u
}

// PermissionGroupID returns the value of the "permission_group_id" field in the mutation.
func (m *PermissionRelatedRouterMutation) PermissionGroupID() (r uuid.UUID, exists bool) {
	v := m.permission_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionGroupID returns the old "permission_group_id" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldPermissionGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionGroupID: %w", err)
	}
	return oldValue.PermissionGroupID, nil
}

// ResetPermissionGroupID resets all changes to the "permission_group_id" field.
func (m *PermissionRelatedRouterMutation) ResetPermissionGroupID() {
	m.permission_group_id = nil
}

// Where appends a list predicates to the PermissionRelatedRouterMutation builder.
func (m *PermissionRelatedRouterMutation) Where(ps ...predicate.PermissionRelatedRouter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionRelatedRouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionRelatedRouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionRelatedRouter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionRelatedRouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionRelatedRouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionRelatedRouter).
func (m *PermissionRelatedRouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionRelatedRouterMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, permissionrelatedrouter.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, permissionrelatedrouter.FieldUpdateTime)
	}
	if m.router_id != nil {
		fields = append(fields, permissionrelatedrouter.FieldRouterID)
	}
	if m.permission_group_id != nil {
		fields = append(fields, permissionrelatedrouter.FieldPermissionGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionRelatedRouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionrelatedrouter.FieldCreateTime:
		return m.CreateTime()
	case permissionrelatedrouter.FieldUpdateTime:
		return m.UpdateTime()
	case permissionrelatedrouter.FieldRouterID:
		return m.RouterID()
	case permissionrelatedrouter.FieldPermissionGroupID:
		return m.PermissionGroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionRelatedRouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionrelatedrouter.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case permissionrelatedrouter.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case permissionrelatedrouter.FieldRouterID:
		return m.OldRouterID(ctx)
	case permissionrelatedrouter.FieldPermissionGroupID:
		return m.OldPermissionGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionRelatedRouter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionRelatedRouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionrelatedrouter.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case permissionrelatedrouter.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case permissionrelatedrouter.FieldRouterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case permissionrelatedrouter.FieldPermissionGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionRelatedRouter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionRelatedRouterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionRelatedRouterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionRelatedRouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PermissionRelatedRouter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionRelatedRouterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionRelatedRouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PermissionRelatedRouter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ResetField(name string) error {
	switch name {
	case permissionrelatedrouter.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case permissionrelatedrouter.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case permissionrelatedrouter.FieldRouterID:
		m.ResetRouterID()
		return nil
	case permissionrelatedrouter.FieldPermissionGroupID:
		m.ResetPermissionGroupID()
		return nil
	}
	return fmt.Errorf("unknown PermissionRelatedRouter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionRelatedRouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionRelatedRouterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionRelatedRouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionRelatedRouterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionRelatedRouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionRelatedRouterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionRelatedRouter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionRelatedRouter edge %s", name)
}

// RouterMutation represents an operation that mutates the Router nodes in the graph.
type RouterMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	route_name    *string
	route         *string
	description   *string
	state         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Router, error)
	predicates    []predicate.Router
}

var _ ent.Mutation = (*RouterMutation)(nil)

// routerOption allows management of the mutation configuration using functional options.
type routerOption func(*RouterMutation)

// newRouterMutation creates new mutation for the Router entity.
func newRouterMutation(c config, op Op, opts ...routerOption) *RouterMutation {
	m := &RouterMutation{
		config:        c,
		op:            op,
		typ:           TypeRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterID sets the ID field of the mutation.
func withRouterID(id uuid.UUID) routerOption {
	return func(m *RouterMutation) {
		var (
			err   error
			once  sync.Once
			value *Router
		)
		m.oldValue = func(ctx context.Context) (*Router, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Router.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouter sets the old Router of the mutation.
func withRouter(node *Router) routerOption {
	return func(m *RouterMutation) {
		m.oldValue = func(context.Context) (*Router, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Router entities.
func (m *RouterMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Router.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RouterMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RouterMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RouterMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RouterMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RouterMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RouterMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRouteName sets the "route_name" field.
func (m *RouterMutation) SetRouteName(s string) {
	m.route_name = &s
}

// RouteName returns the value of the "route_name" field in the mutation.
func (m *RouterMutation) RouteName() (r string, exists bool) {
	v := m.route_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteName returns the old "route_name" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldRouteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteName: %w", err)
	}
	return oldValue.RouteName, nil
}

// ResetRouteName resets all changes to the "route_name" field.
func (m *RouterMutation) ResetRouteName() {
	m.route_name = nil
}

// SetRoute sets the "route" field.
func (m *RouterMutation) SetRoute(s string) {
	m.route = &s
}

// Route returns the value of the "route" field in the mutation.
func (m *RouterMutation) Route() (r string, exists bool) {
	v := m.route
	if v == nil {
		return
	}
	return *v, true
}

// OldRoute returns the old "route" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldRoute(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoute: %w", err)
	}
	return oldValue.Route, nil
}

// ResetRoute resets all changes to the "route" field.
func (m *RouterMutation) ResetRoute() {
	m.route = nil
}

// SetDescription sets the "description" field.
func (m *RouterMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RouterMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RouterMutation) ResetDescription() {
	m.description = nil
}

// SetState sets the "state" field.
func (m *RouterMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *RouterMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *RouterMutation) ResetState() {
	m.state = nil
}

// Where appends a list predicates to the RouterMutation builder.
func (m *RouterMutation) Where(ps ...predicate.Router) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Router, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Router).
func (m *RouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, router.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, router.FieldUpdateTime)
	}
	if m.route_name != nil {
		fields = append(fields, router.FieldRouteName)
	}
	if m.route != nil {
		fields = append(fields, router.FieldRoute)
	}
	if m.description != nil {
		fields = append(fields, router.FieldDescription)
	}
	if m.state != nil {
		fields = append(fields, router.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case router.FieldCreateTime:
		return m.CreateTime()
	case router.FieldUpdateTime:
		return m.UpdateTime()
	case router.FieldRouteName:
		return m.RouteName()
	case router.FieldRoute:
		return m.Route()
	case router.FieldDescription:
		return m.Description()
	case router.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case router.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case router.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case router.FieldRouteName:
		return m.OldRouteName(ctx)
	case router.FieldRoute:
		return m.OldRoute(ctx)
	case router.FieldDescription:
		return m.OldDescription(ctx)
	case router.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Router field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case router.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case router.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case router.FieldRouteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteName(v)
		return nil
	case router.FieldRoute:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoute(v)
		return nil
	case router.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case router.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Router numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Router nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterMutation) ResetField(name string) error {
	switch name {
	case router.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case router.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case router.FieldRouteName:
		m.ResetRouteName()
		return nil
	case router.FieldRoute:
		m.ResetRoute()
		return nil
	case router.FieldDescription:
		m.ResetDescription()
		return nil
	case router.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Router unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Router edge %s", name)
}

// SourceDataMutation represents an operation that mutates the SourceData nodes in the graph.
type SourceDataMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	member_id     *uuid.UUID
	_type         *string
	sub_type      *string
	info          *string
	snapshot      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SourceData, error)
	predicates    []predicate.SourceData
}

var _ ent.Mutation = (*SourceDataMutation)(nil)

// sourcedataOption allows management of the mutation configuration using functional options.
type sourcedataOption func(*SourceDataMutation)

// newSourceDataMutation creates new mutation for the SourceData entity.
func newSourceDataMutation(c config, op Op, opts ...sourcedataOption) *SourceDataMutation {
	m := &SourceDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceDataID sets the ID field of the mutation.
func withSourceDataID(id uuid.UUID) sourcedataOption {
	return func(m *SourceDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceData
		)
		m.oldValue = func(ctx context.Context) (*SourceData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceData sets the old SourceData of the mutation.
func withSourceData(node *SourceData) sourcedataOption {
	return func(m *SourceDataMutation) {
		m.oldValue = func(context.Context) (*SourceData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceData entities.
func (m *SourceDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SourceDataMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SourceDataMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SourceDataMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SourceDataMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SourceDataMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SourceDataMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetMemberID sets the "member_id" field.
func (m *SourceDataMutation) SetMemberID(u uuid.UUID) {
	m.member_id = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *SourceDataMutation) MemberID() (r uuid.UUID, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *SourceDataMutation) ResetMemberID() {
	m.member_id = nil
}

// SetType sets the "type" field.
func (m *SourceDataMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SourceDataMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SourceDataMutation) ResetType() {
	m._type = nil
}

// SetSubType sets the "sub_type" field.
func (m *SourceDataMutation) SetSubType(s string) {
	m.sub_type = &s
}

// SubType returns the value of the "sub_type" field in the mutation.
func (m *SourceDataMutation) SubType() (r string, exists bool) {
	v := m.sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubType returns the old "sub_type" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubType: %w", err)
	}
	return oldValue.SubType, nil
}

// ResetSubType resets all changes to the "sub_type" field.
func (m *SourceDataMutation) ResetSubType() {
	m.sub_type = nil
}

// SetInfo sets the "info" field.
func (m *SourceDataMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *SourceDataMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *SourceDataMutation) ResetInfo() {
	m.info = nil
}

// SetSnapshot sets the "snapshot" field.
func (m *SourceDataMutation) SetSnapshot(s string) {
	m.snapshot = &s
}

// Snapshot returns the value of the "snapshot" field in the mutation.
func (m *SourceDataMutation) Snapshot() (r string, exists bool) {
	v := m.snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshot returns the old "snapshot" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldSnapshot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshot: %w", err)
	}
	return oldValue.Snapshot, nil
}

// ResetSnapshot resets all changes to the "snapshot" field.
func (m *SourceDataMutation) ResetSnapshot() {
	m.snapshot = nil
}

// Where appends a list predicates to the SourceDataMutation builder.
func (m *SourceDataMutation) Where(ps ...predicate.SourceData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceData).
func (m *SourceDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceDataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, sourcedata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, sourcedata.FieldUpdateTime)
	}
	if m.member_id != nil {
		fields = append(fields, sourcedata.FieldMemberID)
	}
	if m._type != nil {
		fields = append(fields, sourcedata.FieldType)
	}
	if m.sub_type != nil {
		fields = append(fields, sourcedata.FieldSubType)
	}
	if m.info != nil {
		fields = append(fields, sourcedata.FieldInfo)
	}
	if m.snapshot != nil {
		fields = append(fields, sourcedata.FieldSnapshot)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcedata.FieldCreateTime:
		return m.CreateTime()
	case sourcedata.FieldUpdateTime:
		return m.UpdateTime()
	case sourcedata.FieldMemberID:
		return m.MemberID()
	case sourcedata.FieldType:
		return m.GetType()
	case sourcedata.FieldSubType:
		return m.SubType()
	case sourcedata.FieldInfo:
		return m.Info()
	case sourcedata.FieldSnapshot:
		return m.Snapshot()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcedata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sourcedata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sourcedata.FieldMemberID:
		return m.OldMemberID(ctx)
	case sourcedata.FieldType:
		return m.OldType(ctx)
	case sourcedata.FieldSubType:
		return m.OldSubType(ctx)
	case sourcedata.FieldInfo:
		return m.OldInfo(ctx)
	case sourcedata.FieldSnapshot:
		return m.OldSnapshot(ctx)
	}
	return nil, fmt.Errorf("unknown SourceData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcedata.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sourcedata.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sourcedata.FieldMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case sourcedata.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case sourcedata.FieldSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubType(v)
		return nil
	case sourcedata.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case sourcedata.FieldSnapshot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshot(v)
		return nil
	}
	return fmt.Errorf("unknown SourceData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SourceData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceDataMutation) ResetField(name string) error {
	switch name {
	case sourcedata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sourcedata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sourcedata.FieldMemberID:
		m.ResetMemberID()
		return nil
	case sourcedata.FieldType:
		m.ResetType()
		return nil
	case sourcedata.FieldSubType:
		m.ResetSubType()
		return nil
	case sourcedata.FieldInfo:
		m.ResetInfo()
		return nil
	case sourcedata.FieldSnapshot:
		m.ResetSnapshot()
		return nil
	}
	return fmt.Errorf("unknown SourceData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SourceData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SourceData edge %s", name)
}

// WakatimeMutation represents an operation that mutates the Wakatime nodes in the graph.
type WakatimeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	member_id     *uuid.UUID
	key           *string
	api           *string
	state         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Wakatime, error)
	predicates    []predicate.Wakatime
}

var _ ent.Mutation = (*WakatimeMutation)(nil)

// wakatimeOption allows management of the mutation configuration using functional options.
type wakatimeOption func(*WakatimeMutation)

// newWakatimeMutation creates new mutation for the Wakatime entity.
func newWakatimeMutation(c config, op Op, opts ...wakatimeOption) *WakatimeMutation {
	m := &WakatimeMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeID sets the ID field of the mutation.
func withWakatimeID(id uuid.UUID) wakatimeOption {
	return func(m *WakatimeMutation) {
		var (
			err   error
			once  sync.Once
			value *Wakatime
		)
		m.oldValue = func(ctx context.Context) (*Wakatime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wakatime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatime sets the old Wakatime of the mutation.
func withWakatime(node *Wakatime) wakatimeOption {
	return func(m *WakatimeMutation) {
		m.oldValue = func(context.Context) (*Wakatime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wakatime entities.
func (m *WakatimeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wakatime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WakatimeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WakatimeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WakatimeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WakatimeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WakatimeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WakatimeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetMemberID sets the "member_id" field.
func (m *WakatimeMutation) SetMemberID(u uuid.UUID) {
	m.member_id = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *WakatimeMutation) MemberID() (r uuid.UUID, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *WakatimeMutation) ResetMemberID() {
	m.member_id = nil
}

// SetKey sets the "key" field.
func (m *WakatimeMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *WakatimeMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *WakatimeMutation) ResetKey() {
	m.key = nil
}

// SetAPI sets the "api" field.
func (m *WakatimeMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *WakatimeMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *WakatimeMutation) ResetAPI() {
	m.api = nil
}

// SetState sets the "state" field.
func (m *WakatimeMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *WakatimeMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *WakatimeMutation) ResetState() {
	m.state = nil
}

// Where appends a list predicates to the WakatimeMutation builder.
func (m *WakatimeMutation) Where(ps ...predicate.Wakatime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wakatime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wakatime).
func (m *WakatimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, wakatime.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wakatime.FieldUpdateTime)
	}
	if m.member_id != nil {
		fields = append(fields, wakatime.FieldMemberID)
	}
	if m.key != nil {
		fields = append(fields, wakatime.FieldKey)
	}
	if m.api != nil {
		fields = append(fields, wakatime.FieldAPI)
	}
	if m.state != nil {
		fields = append(fields, wakatime.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wakatime.FieldCreateTime:
		return m.CreateTime()
	case wakatime.FieldUpdateTime:
		return m.UpdateTime()
	case wakatime.FieldMemberID:
		return m.MemberID()
	case wakatime.FieldKey:
		return m.Key()
	case wakatime.FieldAPI:
		return m.API()
	case wakatime.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wakatime.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wakatime.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wakatime.FieldMemberID:
		return m.OldMemberID(ctx)
	case wakatime.FieldKey:
		return m.OldKey(ctx)
	case wakatime.FieldAPI:
		return m.OldAPI(ctx)
	case wakatime.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Wakatime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wakatime.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wakatime.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wakatime.FieldMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case wakatime.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case wakatime.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case wakatime.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Wakatime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Wakatime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wakatime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeMutation) ResetField(name string) error {
	switch name {
	case wakatime.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wakatime.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wakatime.FieldMemberID:
		m.ResetMemberID()
		return nil
	case wakatime.FieldKey:
		m.ResetKey()
		return nil
	case wakatime.FieldAPI:
		m.ResetAPI()
		return nil
	case wakatime.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Wakatime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Wakatime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Wakatime edge %s", name)
}

// WakatimeCategoryMutation represents an operation that mutates the WakatimeCategory nodes in the graph.
type WakatimeCategoryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	wakatime_id      *uuid.UUID
	member_id        *uuid.UUID
	name             *string
	total_seconds    *int64
	addtotal_seconds *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*WakatimeCategory, error)
	predicates       []predicate.WakatimeCategory
}

var _ ent.Mutation = (*WakatimeCategoryMutation)(nil)

// wakatimecategoryOption allows management of the mutation configuration using functional options.
type wakatimecategoryOption func(*WakatimeCategoryMutation)

// newWakatimeCategoryMutation creates new mutation for the WakatimeCategory entity.
func newWakatimeCategoryMutation(c config, op Op, opts ...wakatimecategoryOption) *WakatimeCategoryMutation {
	m := &WakatimeCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeCategoryID sets the ID field of the mutation.
func withWakatimeCategoryID(id uuid.UUID) wakatimecategoryOption {
	return func(m *WakatimeCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeCategory
		)
		m.oldValue = func(ctx context.Context) (*WakatimeCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeCategory sets the old WakatimeCategory of the mutation.
func withWakatimeCategory(node *WakatimeCategory) wakatimecategoryOption {
	return func(m *WakatimeCategoryMutation) {
		m.oldValue = func(context.Context) (*WakatimeCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WakatimeCategory entities.
func (m *WakatimeCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WakatimeCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WakatimeCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WakatimeCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WakatimeCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WakatimeCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WakatimeCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetWakatimeID sets the "wakatime_id" field.
func (m *WakatimeCategoryMutation) SetWakatimeID(u uuid.UUID) {
	m.wakatime_id = &u
}

// WakatimeID returns the value of the "wakatime_id" field in the mutation.
func (m *WakatimeCategoryMutation) WakatimeID() (r uuid.UUID, exists bool) {
	v := m.wakatime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWakatimeID returns the old "wakatime_id" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldWakatimeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWakatimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWakatimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWakatimeID: %w", err)
	}
	return oldValue.WakatimeID, nil
}

// ResetWakatimeID resets all changes to the "wakatime_id" field.
func (m *WakatimeCategoryMutation) ResetWakatimeID() {
	m.wakatime_id = nil
}

// SetMemberID sets the "member_id" field.
func (m *WakatimeCategoryMutation) SetMemberID(u uuid.UUID) {
	m.member_id = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *WakatimeCategoryMutation) MemberID() (r uuid.UUID, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *WakatimeCategoryMutation) ResetMemberID() {
	m.member_id = nil
}

// SetName sets the "name" field.
func (m *WakatimeCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WakatimeCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WakatimeCategoryMutation) ResetName() {
	m.name = nil
}

// SetTotalSeconds sets the "total_seconds" field.
func (m *WakatimeCategoryMutation) SetTotalSeconds(i int64) {
	m.total_seconds = &i
	m.addtotal_seconds = nil
}

// TotalSeconds returns the value of the "total_seconds" field in the mutation.
func (m *WakatimeCategoryMutation) TotalSeconds() (r int64, exists bool) {
	v := m.total_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSeconds returns the old "total_seconds" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldTotalSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSeconds: %w", err)
	}
	return oldValue.TotalSeconds, nil
}

// AddTotalSeconds adds i to the "total_seconds" field.
func (m *WakatimeCategoryMutation) AddTotalSeconds(i int64) {
	if m.addtotal_seconds != nil {
		*m.addtotal_seconds += i
	} else {
		m.addtotal_seconds = &i
	}
}

// AddedTotalSeconds returns the value that was added to the "total_seconds" field in this mutation.
func (m *WakatimeCategoryMutation) AddedTotalSeconds() (r int64, exists bool) {
	v := m.addtotal_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSeconds resets all changes to the "total_seconds" field.
func (m *WakatimeCategoryMutation) ResetTotalSeconds() {
	m.total_seconds = nil
	m.addtotal_seconds = nil
}

// Where appends a list predicates to the WakatimeCategoryMutation builder.
func (m *WakatimeCategoryMutation) Where(ps ...predicate.WakatimeCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeCategory).
func (m *WakatimeCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, wakatimecategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wakatimecategory.FieldUpdateTime)
	}
	if m.wakatime_id != nil {
		fields = append(fields, wakatimecategory.FieldWakatimeID)
	}
	if m.member_id != nil {
		fields = append(fields, wakatimecategory.FieldMemberID)
	}
	if m.name != nil {
		fields = append(fields, wakatimecategory.FieldName)
	}
	if m.total_seconds != nil {
		fields = append(fields, wakatimecategory.FieldTotalSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wakatimecategory.FieldCreateTime:
		return m.CreateTime()
	case wakatimecategory.FieldUpdateTime:
		return m.UpdateTime()
	case wakatimecategory.FieldWakatimeID:
		return m.WakatimeID()
	case wakatimecategory.FieldMemberID:
		return m.MemberID()
	case wakatimecategory.FieldName:
		return m.Name()
	case wakatimecategory.FieldTotalSeconds:
		return m.TotalSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wakatimecategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wakatimecategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wakatimecategory.FieldWakatimeID:
		return m.OldWakatimeID(ctx)
	case wakatimecategory.FieldMemberID:
		return m.OldMemberID(ctx)
	case wakatimecategory.FieldName:
		return m.OldName(ctx)
	case wakatimecategory.FieldTotalSeconds:
		return m.OldTotalSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown WakatimeCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wakatimecategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wakatimecategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wakatimecategory.FieldWakatimeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWakatimeID(v)
		return nil
	case wakatimecategory.FieldMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case wakatimecategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case wakatimecategory.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_seconds != nil {
		fields = append(fields, wakatimecategory.FieldTotalSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wakatimecategory.FieldTotalSeconds:
		return m.AddedTotalSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wakatimecategory.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeCategoryMutation) ResetField(name string) error {
	switch name {
	case wakatimecategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wakatimecategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wakatimecategory.FieldWakatimeID:
		m.ResetWakatimeID()
		return nil
	case wakatimecategory.FieldMemberID:
		m.ResetMemberID()
		return nil
	case wakatimecategory.FieldName:
		m.ResetName()
		return nil
	case wakatimecategory.FieldTotalSeconds:
		m.ResetTotalSeconds()
		return nil
	}
	return fmt.Errorf("unknown WakatimeCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeCategory edge %s", name)
}

// WakatimeDependencyMutation represents an operation that mutates the WakatimeDependency nodes in the graph.
type WakatimeDependencyMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	wakatime_id      *uuid.UUID
	member_id        *uuid.UUID
	name             *string
	total_seconds    *int64
	addtotal_seconds *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*WakatimeDependency, error)
	predicates       []predicate.WakatimeDependency
}

var _ ent.Mutation = (*WakatimeDependencyMutation)(nil)

// wakatimedependencyOption allows management of the mutation configuration using functional options.
type wakatimedependencyOption func(*WakatimeDependencyMutation)

// newWakatimeDependencyMutation creates new mutation for the WakatimeDependency entity.
func newWakatimeDependencyMutation(c config, op Op, opts ...wakatimedependencyOption) *WakatimeDependencyMutation {
	m := &WakatimeDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeDependencyID sets the ID field of the mutation.
func withWakatimeDependencyID(id uuid.UUID) wakatimedependencyOption {
	return func(m *WakatimeDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeDependency
		)
		m.oldValue = func(ctx context.Context) (*WakatimeDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeDependency sets the old WakatimeDependency of the mutation.
func withWakatimeDependency(node *WakatimeDependency) wakatimedependencyOption {
	return func(m *WakatimeDependencyMutation) {
		m.oldValue = func(context.Context) (*WakatimeDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WakatimeDependency entities.
func (m *WakatimeDependencyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeDependencyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeDependencyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WakatimeDependencyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WakatimeDependencyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WakatimeDependencyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WakatimeDependencyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WakatimeDependencyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WakatimeDependencyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetWakatimeID sets the "wakatime_id" field.
func (m *WakatimeDependencyMutation) SetWakatimeID(u uuid.UUID) {
	m.wakatime_id = &u
}

// WakatimeID returns the value of the "wakatime_id" field in the mutation.
func (m *WakatimeDependencyMutation) WakatimeID() (r uuid.UUID, exists bool) {
	v := m.wakatime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWakatimeID returns the old "wakatime_id" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldWakatimeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWakatimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWakatimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWakatimeID: %w", err)
	}
	return oldValue.WakatimeID, nil
}

// ResetWakatimeID resets all changes to the "wakatime_id" field.
func (m *WakatimeDependencyMutation) ResetWakatimeID() {
	m.wakatime_id = nil
}

// SetMemberID sets the "member_id" field.
func (m *WakatimeDependencyMutation) SetMemberID(u uuid.UUID) {
	m.member_id = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *WakatimeDependencyMutation) MemberID() (r uuid.UUID, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldMemberID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *WakatimeDependencyMutation) ResetMemberID() {
	m.member_id = nil
}

// SetName sets the "name" field.
func (m *WakatimeDependencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WakatimeDependencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WakatimeDependencyMutation) ResetName() {
	m.name = nil
}

// SetTotalSeconds sets the "total_seconds" field.
func (m *WakatimeDependencyMutation) SetTotalSeconds(i int64) {
	m.total_seconds = &i
	m.addtotal_seconds = nil
}

// TotalSeconds returns the value of the "total_seconds" field in the mutation.
func (m *WakatimeDependencyMutation) TotalSeconds() (r int64, exists bool) {
	v := m.total_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSeconds returns the old "total_seconds" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldTotalSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSeconds: %w", err)
	}
	return oldValue.TotalSeconds, nil
}

// AddTotalSeconds adds i to the "total_seconds" field.
func (m *WakatimeDependencyMutation) AddTotalSeconds(i int64) {
	if m.addtotal_seconds != nil {
		*m.addtotal_seconds += i
	} else {
		m.addtotal_seconds = &i
	}
}

// AddedTotalSeconds returns the value that was added to the "total_seconds" field in this mutation.
func (m *WakatimeDependencyMutation) AddedTotalSeconds() (r int64, exists bool) {
	v := m.addtotal_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSeconds resets all changes to the "total_seconds" field.
func (m *WakatimeDependencyMutation) ResetTotalSeconds() {
	m.total_seconds = nil
	m.addtotal_seconds = nil
}

// Where appends a list predicates to the WakatimeDependencyMutation builder.
func (m *WakatimeDependencyMutation) Where(ps ...predicate.WakatimeDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeDependency).
func (m *WakatimeDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeDependencyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, wakatimedependency.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wakatimedependency.FieldUpdateTime)
	}
	if m.wakatime_id != nil {
		fields = append(fields, wakatimedependency.FieldWakatimeID)
	}
	if m.member_id != nil {
		fields = append(fields, wakatimedependency.FieldMemberID)
	}
	if m.name != nil {
		fields = append(fields, wakatimedependency.FieldName)
	}
	if m.total_seconds != nil {
		fields = append(fields, wakatimedependency.FieldTotalSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wakatimedependency.FieldCreateTime:
		return m.CreateTime()
	case wakatimedependency.FieldUpdateTime:
		return m.UpdateTime()
	case wakatimedependency.FieldWakatimeID:
		return m.WakatimeID()
	case wakatimedependency.FieldMemberID:
		return m.MemberID()
	case wakatimedependency.FieldName:
		return m.Name()
	case wakatimedependency.FieldTotalSeconds:
		return m.TotalSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wakatimedependency.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wakatimedependency.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wakatimedependency.FieldWakatimeID:
		return m.OldWakatimeID(ctx)
	case wakatimedependency.FieldMemberID:
		return m.OldMemberID(ctx)
	case wakatimedependency.FieldName:
		return m.OldName(ctx)
	case wakatimedependency.FieldTotalSeconds:
		return m.OldTotalSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown WakatimeDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wakatimedependency.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wakatimedependency.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wakatimedependency.FieldWakatimeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWakatimeID(v)
		return nil
	case wakatimedependency.FieldMemberID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case wakatimedependency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case wakatimedependency.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeDependencyMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_seconds != nil {
		fields = append(fields, wakatimedependency.FieldTotalSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeDependencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wakatimedependency.FieldTotalSeconds:
		return m.AddedTotalSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wakatimedependency.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeDependencyMutation) ResetField(name string) error {
	switch name {
	case wakatimedependency.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wakatimedependency.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wakatimedependency.FieldWakatimeID:
		m.ResetWakatimeID()
		return nil
	case wakatimedependency.FieldMemberID:
		m.ResetMemberID()
		return nil
	case wakatimedependency.FieldName:
		m.ResetName()
		return nil
	case wakatimedependency.FieldTotalSeconds:
		m.ResetTotalSeconds()
		return nil
	}
	return fmt.Errorf("unknown WakatimeDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeDependencyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeDependencyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeDependencyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeDependencyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDependency edge %s", name)
}

// WakatimeDurationMutation represents an operation that mutates the WakatimeDuration nodes in the graph.
type WakatimeDurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeDuration, error)
	predicates    []predicate.WakatimeDuration
}

var _ ent.Mutation = (*WakatimeDurationMutation)(nil)

// wakatimedurationOption allows management of the mutation configuration using functional options.
type wakatimedurationOption func(*WakatimeDurationMutation)

// newWakatimeDurationMutation creates new mutation for the WakatimeDuration entity.
func newWakatimeDurationMutation(c config, op Op, opts ...wakatimedurationOption) *WakatimeDurationMutation {
	m := &WakatimeDurationMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeDuration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeDurationID sets the ID field of the mutation.
func withWakatimeDurationID(id int) wakatimedurationOption {
	return func(m *WakatimeDurationMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeDuration
		)
		m.oldValue = func(ctx context.Context) (*WakatimeDuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeDuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeDuration sets the old WakatimeDuration of the mutation.
func withWakatimeDuration(node *WakatimeDuration) wakatimedurationOption {
	return func(m *WakatimeDurationMutation) {
		m.oldValue = func(context.Context) (*WakatimeDuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeDurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeDurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeDurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeDurationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeDuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeDurationMutation builder.
func (m *WakatimeDurationMutation) Where(ps ...predicate.WakatimeDuration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeDurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeDurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeDuration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeDurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeDurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeDuration).
func (m *WakatimeDurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeDurationMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeDurationMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeDurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeDuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeDuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeDurationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeDurationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDurationMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeDuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeDurationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeDurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeDurationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeDuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeDurationMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeDuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeDurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeDurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeDurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeDurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeDurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeDurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeDurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeDurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDuration edge %s", name)
}

// WakatimeEditorMutation represents an operation that mutates the WakatimeEditor nodes in the graph.
type WakatimeEditorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeEditor, error)
	predicates    []predicate.WakatimeEditor
}

var _ ent.Mutation = (*WakatimeEditorMutation)(nil)

// wakatimeeditorOption allows management of the mutation configuration using functional options.
type wakatimeeditorOption func(*WakatimeEditorMutation)

// newWakatimeEditorMutation creates new mutation for the WakatimeEditor entity.
func newWakatimeEditorMutation(c config, op Op, opts ...wakatimeeditorOption) *WakatimeEditorMutation {
	m := &WakatimeEditorMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeEditor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeEditorID sets the ID field of the mutation.
func withWakatimeEditorID(id int) wakatimeeditorOption {
	return func(m *WakatimeEditorMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeEditor
		)
		m.oldValue = func(ctx context.Context) (*WakatimeEditor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeEditor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeEditor sets the old WakatimeEditor of the mutation.
func withWakatimeEditor(node *WakatimeEditor) wakatimeeditorOption {
	return func(m *WakatimeEditorMutation) {
		m.oldValue = func(context.Context) (*WakatimeEditor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeEditorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeEditorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeEditorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeEditorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeEditor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeEditorMutation builder.
func (m *WakatimeEditorMutation) Where(ps ...predicate.WakatimeEditor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeEditorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeEditorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeEditor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeEditorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeEditorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeEditor).
func (m *WakatimeEditorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeEditorMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeEditorMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeEditorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeEditor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEditorMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeEditor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeEditorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeEditorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEditorMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeEditor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeEditorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeEditorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeEditorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeEditor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeEditorMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeEditor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeEditorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeEditorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeEditorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeEditorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeEditorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeEditorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeEditorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEditor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeEditorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEditor edge %s", name)
}

// WakatimeEntityMutation represents an operation that mutates the WakatimeEntity nodes in the graph.
type WakatimeEntityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeEntity, error)
	predicates    []predicate.WakatimeEntity
}

var _ ent.Mutation = (*WakatimeEntityMutation)(nil)

// wakatimeentityOption allows management of the mutation configuration using functional options.
type wakatimeentityOption func(*WakatimeEntityMutation)

// newWakatimeEntityMutation creates new mutation for the WakatimeEntity entity.
func newWakatimeEntityMutation(c config, op Op, opts ...wakatimeentityOption) *WakatimeEntityMutation {
	m := &WakatimeEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeEntityID sets the ID field of the mutation.
func withWakatimeEntityID(id int) wakatimeentityOption {
	return func(m *WakatimeEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeEntity
		)
		m.oldValue = func(ctx context.Context) (*WakatimeEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeEntity sets the old WakatimeEntity of the mutation.
func withWakatimeEntity(node *WakatimeEntity) wakatimeentityOption {
	return func(m *WakatimeEntityMutation) {
		m.oldValue = func(context.Context) (*WakatimeEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeEntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeEntityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeEntityMutation builder.
func (m *WakatimeEntityMutation) Where(ps ...predicate.WakatimeEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeEntity).
func (m *WakatimeEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeEntityMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeEntityMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeEntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeEntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEntityMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeEntityMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeEntityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeEntityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeEntityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeEntityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEntity edge %s", name)
}

// WakatimeGrandTotalMutation represents an operation that mutates the WakatimeGrandTotal nodes in the graph.
type WakatimeGrandTotalMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeGrandTotal, error)
	predicates    []predicate.WakatimeGrandTotal
}

var _ ent.Mutation = (*WakatimeGrandTotalMutation)(nil)

// wakatimegrandtotalOption allows management of the mutation configuration using functional options.
type wakatimegrandtotalOption func(*WakatimeGrandTotalMutation)

// newWakatimeGrandTotalMutation creates new mutation for the WakatimeGrandTotal entity.
func newWakatimeGrandTotalMutation(c config, op Op, opts ...wakatimegrandtotalOption) *WakatimeGrandTotalMutation {
	m := &WakatimeGrandTotalMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeGrandTotal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeGrandTotalID sets the ID field of the mutation.
func withWakatimeGrandTotalID(id int) wakatimegrandtotalOption {
	return func(m *WakatimeGrandTotalMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeGrandTotal
		)
		m.oldValue = func(ctx context.Context) (*WakatimeGrandTotal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeGrandTotal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeGrandTotal sets the old WakatimeGrandTotal of the mutation.
func withWakatimeGrandTotal(node *WakatimeGrandTotal) wakatimegrandtotalOption {
	return func(m *WakatimeGrandTotalMutation) {
		m.oldValue = func(context.Context) (*WakatimeGrandTotal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeGrandTotalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeGrandTotalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeGrandTotalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeGrandTotalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeGrandTotal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeGrandTotalMutation builder.
func (m *WakatimeGrandTotalMutation) Where(ps ...predicate.WakatimeGrandTotal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeGrandTotalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeGrandTotalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeGrandTotal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeGrandTotalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeGrandTotalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeGrandTotal).
func (m *WakatimeGrandTotalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeGrandTotalMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeGrandTotalMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeGrandTotalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeGrandTotal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeGrandTotalMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeGrandTotal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeGrandTotalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeGrandTotalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeGrandTotalMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeGrandTotal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeGrandTotalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeGrandTotalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeGrandTotalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeGrandTotalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeGrandTotalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeGrandTotalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeGrandTotalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeGrandTotalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal edge %s", name)
}

// WakatimeHeartBeatMutation represents an operation that mutates the WakatimeHeartBeat nodes in the graph.
type WakatimeHeartBeatMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeHeartBeat, error)
	predicates    []predicate.WakatimeHeartBeat
}

var _ ent.Mutation = (*WakatimeHeartBeatMutation)(nil)

// wakatimeheartbeatOption allows management of the mutation configuration using functional options.
type wakatimeheartbeatOption func(*WakatimeHeartBeatMutation)

// newWakatimeHeartBeatMutation creates new mutation for the WakatimeHeartBeat entity.
func newWakatimeHeartBeatMutation(c config, op Op, opts ...wakatimeheartbeatOption) *WakatimeHeartBeatMutation {
	m := &WakatimeHeartBeatMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeHeartBeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeHeartBeatID sets the ID field of the mutation.
func withWakatimeHeartBeatID(id int) wakatimeheartbeatOption {
	return func(m *WakatimeHeartBeatMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeHeartBeat
		)
		m.oldValue = func(ctx context.Context) (*WakatimeHeartBeat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeHeartBeat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeHeartBeat sets the old WakatimeHeartBeat of the mutation.
func withWakatimeHeartBeat(node *WakatimeHeartBeat) wakatimeheartbeatOption {
	return func(m *WakatimeHeartBeatMutation) {
		m.oldValue = func(context.Context) (*WakatimeHeartBeat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeHeartBeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeHeartBeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeHeartBeatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeHeartBeatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeHeartBeat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeHeartBeatMutation builder.
func (m *WakatimeHeartBeatMutation) Where(ps ...predicate.WakatimeHeartBeat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeHeartBeatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeHeartBeatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeHeartBeat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeHeartBeatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeHeartBeatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeHeartBeat).
func (m *WakatimeHeartBeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeHeartBeatMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeHeartBeatMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeHeartBeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeHeartBeat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeHeartBeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeHeartBeat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeHeartBeatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeHeartBeatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeHeartBeatMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeHeartBeat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeHeartBeatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeHeartBeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeHeartBeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeHeartBeatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeHeartBeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeHeartBeatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeHeartBeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeHeartBeatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat edge %s", name)
}

// WakatimeLanguageMutation represents an operation that mutates the WakatimeLanguage nodes in the graph.
type WakatimeLanguageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeLanguage, error)
	predicates    []predicate.WakatimeLanguage
}

var _ ent.Mutation = (*WakatimeLanguageMutation)(nil)

// wakatimelanguageOption allows management of the mutation configuration using functional options.
type wakatimelanguageOption func(*WakatimeLanguageMutation)

// newWakatimeLanguageMutation creates new mutation for the WakatimeLanguage entity.
func newWakatimeLanguageMutation(c config, op Op, opts ...wakatimelanguageOption) *WakatimeLanguageMutation {
	m := &WakatimeLanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeLanguageID sets the ID field of the mutation.
func withWakatimeLanguageID(id int) wakatimelanguageOption {
	return func(m *WakatimeLanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeLanguage
		)
		m.oldValue = func(ctx context.Context) (*WakatimeLanguage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeLanguage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeLanguage sets the old WakatimeLanguage of the mutation.
func withWakatimeLanguage(node *WakatimeLanguage) wakatimelanguageOption {
	return func(m *WakatimeLanguageMutation) {
		m.oldValue = func(context.Context) (*WakatimeLanguage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeLanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeLanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeLanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeLanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeLanguage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeLanguageMutation builder.
func (m *WakatimeLanguageMutation) Where(ps ...predicate.WakatimeLanguage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeLanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeLanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeLanguage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeLanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeLanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeLanguage).
func (m *WakatimeLanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeLanguageMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeLanguageMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeLanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeLanguage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeLanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeLanguage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeLanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeLanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeLanguageMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeLanguage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeLanguageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeLanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeLanguageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeLanguageMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeLanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeLanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeLanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeLanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeLanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeLanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeLanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeLanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage edge %s", name)
}

// WakatimeProjectMutation represents an operation that mutates the WakatimeProject nodes in the graph.
type WakatimeProjectMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeProject, error)
	predicates    []predicate.WakatimeProject
}

var _ ent.Mutation = (*WakatimeProjectMutation)(nil)

// wakatimeprojectOption allows management of the mutation configuration using functional options.
type wakatimeprojectOption func(*WakatimeProjectMutation)

// newWakatimeProjectMutation creates new mutation for the WakatimeProject entity.
func newWakatimeProjectMutation(c config, op Op, opts ...wakatimeprojectOption) *WakatimeProjectMutation {
	m := &WakatimeProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeProjectID sets the ID field of the mutation.
func withWakatimeProjectID(id int) wakatimeprojectOption {
	return func(m *WakatimeProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeProject
		)
		m.oldValue = func(ctx context.Context) (*WakatimeProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeProject sets the old WakatimeProject of the mutation.
func withWakatimeProject(node *WakatimeProject) wakatimeprojectOption {
	return func(m *WakatimeProjectMutation) {
		m.oldValue = func(context.Context) (*WakatimeProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeProjectMutation builder.
func (m *WakatimeProjectMutation) Where(ps ...predicate.WakatimeProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeProject).
func (m *WakatimeProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeProjectMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeProjectMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeProjectMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeProjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeProjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeProjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeProjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProject edge %s", name)
}

// WakatimeProjectDurationMutation represents an operation that mutates the WakatimeProjectDuration nodes in the graph.
type WakatimeProjectDurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeProjectDuration, error)
	predicates    []predicate.WakatimeProjectDuration
}

var _ ent.Mutation = (*WakatimeProjectDurationMutation)(nil)

// wakatimeprojectdurationOption allows management of the mutation configuration using functional options.
type wakatimeprojectdurationOption func(*WakatimeProjectDurationMutation)

// newWakatimeProjectDurationMutation creates new mutation for the WakatimeProjectDuration entity.
func newWakatimeProjectDurationMutation(c config, op Op, opts ...wakatimeprojectdurationOption) *WakatimeProjectDurationMutation {
	m := &WakatimeProjectDurationMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeProjectDuration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeProjectDurationID sets the ID field of the mutation.
func withWakatimeProjectDurationID(id int) wakatimeprojectdurationOption {
	return func(m *WakatimeProjectDurationMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeProjectDuration
		)
		m.oldValue = func(ctx context.Context) (*WakatimeProjectDuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeProjectDuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeProjectDuration sets the old WakatimeProjectDuration of the mutation.
func withWakatimeProjectDuration(node *WakatimeProjectDuration) wakatimeprojectdurationOption {
	return func(m *WakatimeProjectDurationMutation) {
		m.oldValue = func(context.Context) (*WakatimeProjectDuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeProjectDurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeProjectDurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeProjectDurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeProjectDurationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeProjectDuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeProjectDurationMutation builder.
func (m *WakatimeProjectDurationMutation) Where(ps ...predicate.WakatimeProjectDuration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeProjectDurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeProjectDurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeProjectDuration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeProjectDurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeProjectDurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeProjectDuration).
func (m *WakatimeProjectDurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeProjectDurationMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeProjectDurationMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeProjectDurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeProjectDuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectDurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeProjectDuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeProjectDurationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeProjectDurationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectDurationMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeProjectDuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeProjectDurationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeProjectDurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeProjectDurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeProjectDurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeProjectDurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeProjectDurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeProjectDurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeProjectDurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration edge %s", name)
}

// WakatimeProjectInfoMutation represents an operation that mutates the WakatimeProjectInfo nodes in the graph.
type WakatimeProjectInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeProjectInfo, error)
	predicates    []predicate.WakatimeProjectInfo
}

var _ ent.Mutation = (*WakatimeProjectInfoMutation)(nil)

// wakatimeprojectinfoOption allows management of the mutation configuration using functional options.
type wakatimeprojectinfoOption func(*WakatimeProjectInfoMutation)

// newWakatimeProjectInfoMutation creates new mutation for the WakatimeProjectInfo entity.
func newWakatimeProjectInfoMutation(c config, op Op, opts ...wakatimeprojectinfoOption) *WakatimeProjectInfoMutation {
	m := &WakatimeProjectInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeProjectInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeProjectInfoID sets the ID field of the mutation.
func withWakatimeProjectInfoID(id int) wakatimeprojectinfoOption {
	return func(m *WakatimeProjectInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeProjectInfo
		)
		m.oldValue = func(ctx context.Context) (*WakatimeProjectInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeProjectInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeProjectInfo sets the old WakatimeProjectInfo of the mutation.
func withWakatimeProjectInfo(node *WakatimeProjectInfo) wakatimeprojectinfoOption {
	return func(m *WakatimeProjectInfoMutation) {
		m.oldValue = func(context.Context) (*WakatimeProjectInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeProjectInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeProjectInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeProjectInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeProjectInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeProjectInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeProjectInfoMutation builder.
func (m *WakatimeProjectInfoMutation) Where(ps ...predicate.WakatimeProjectInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeProjectInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeProjectInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeProjectInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeProjectInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeProjectInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeProjectInfo).
func (m *WakatimeProjectInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeProjectInfoMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeProjectInfoMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeProjectInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeProjectInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeProjectInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeProjectInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeProjectInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectInfoMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeProjectInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeProjectInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeProjectInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeProjectInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeProjectInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeProjectInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeProjectInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeProjectInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeProjectInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo edge %s", name)
}

// WakatimeSystemMutation represents an operation that mutates the WakatimeSystem nodes in the graph.
type WakatimeSystemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeSystem, error)
	predicates    []predicate.WakatimeSystem
}

var _ ent.Mutation = (*WakatimeSystemMutation)(nil)

// wakatimesystemOption allows management of the mutation configuration using functional options.
type wakatimesystemOption func(*WakatimeSystemMutation)

// newWakatimeSystemMutation creates new mutation for the WakatimeSystem entity.
func newWakatimeSystemMutation(c config, op Op, opts ...wakatimesystemOption) *WakatimeSystemMutation {
	m := &WakatimeSystemMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeSystemID sets the ID field of the mutation.
func withWakatimeSystemID(id int) wakatimesystemOption {
	return func(m *WakatimeSystemMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeSystem
		)
		m.oldValue = func(ctx context.Context) (*WakatimeSystem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeSystem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeSystem sets the old WakatimeSystem of the mutation.
func withWakatimeSystem(node *WakatimeSystem) wakatimesystemOption {
	return func(m *WakatimeSystemMutation) {
		m.oldValue = func(context.Context) (*WakatimeSystem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeSystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeSystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeSystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeSystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeSystem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeSystemMutation builder.
func (m *WakatimeSystemMutation) Where(ps ...predicate.WakatimeSystem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeSystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeSystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeSystem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeSystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeSystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeSystem).
func (m *WakatimeSystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeSystemMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeSystemMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeSystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeSystem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeSystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeSystem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeSystemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeSystemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeSystemMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeSystem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeSystemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeSystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeSystemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeSystem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeSystemMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeSystem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeSystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeSystemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeSystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeSystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeSystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeSystemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeSystemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeSystem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeSystemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeSystem edge %s", name)
}
