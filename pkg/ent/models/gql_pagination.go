// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"ent/models/accesstoken"
	"ent/models/accounts"
	"ent/models/memberrolerelatedpermission"
	"ent/models/permissiongroup"
	"ent/models/permissionrelatedrouter"
	"ent/models/router"
	"ent/models/source"
	"ent/models/sourcedata"
	"ent/models/user"
	"ent/models/userauthsource"
	"ent/models/userrelatedrole"
	"ent/models/userrole"
	"ent/models/wakatime"
	"ent/models/wakatimecategory"
	"ent/models/wakatimedependency"
	"ent/models/wakatimeduration"
	"ent/models/wakatimeeditor"
	"ent/models/wakatimeentity"
	"ent/models/wakatimegrandtotal"
	"ent/models/wakatimeheartbeat"
	"ent/models/wakatimelanguage"
	"ent/models/wakatimeproject"
	"ent/models/wakatimeprojectduration"
	"ent/models/wakatimeprojectinfo"
	"ent/models/wakatimesystem"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int64]
	PageInfo       = entgql.PageInfo[int64]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AccessTokenEdge is the edge representation of AccessToken.
type AccessTokenEdge struct {
	Node   *AccessToken `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AccessTokenConnection is the connection containing edges to AccessToken.
type AccessTokenConnection struct {
	Edges      []*AccessTokenEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *AccessTokenConnection) build(nodes []*AccessToken, pager *accesstokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AccessToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AccessToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AccessToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccessTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccessTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccessTokenPaginateOption enables pagination customization.
type AccessTokenPaginateOption func(*accesstokenPager) error

// WithAccessTokenOrder configures pagination ordering.
func WithAccessTokenOrder(order *AccessTokenOrder) AccessTokenPaginateOption {
	if order == nil {
		order = DefaultAccessTokenOrder
	}
	o := *order
	return func(pager *accesstokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccessTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccessTokenFilter configures pagination filter.
func WithAccessTokenFilter(filter func(*AccessTokenQuery) (*AccessTokenQuery, error)) AccessTokenPaginateOption {
	return func(pager *accesstokenPager) error {
		if filter == nil {
			return errors.New("AccessTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accesstokenPager struct {
	reverse bool
	order   *AccessTokenOrder
	filter  func(*AccessTokenQuery) (*AccessTokenQuery, error)
}

func newAccessTokenPager(opts []AccessTokenPaginateOption, reverse bool) (*accesstokenPager, error) {
	pager := &accesstokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccessTokenOrder
	}
	return pager, nil
}

func (p *accesstokenPager) applyFilter(query *AccessTokenQuery) (*AccessTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accesstokenPager) toCursor(at *AccessToken) Cursor {
	return p.order.Field.toCursor(at)
}

func (p *accesstokenPager) applyCursors(query *AccessTokenQuery, after, before *Cursor) (*AccessTokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAccessTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *accesstokenPager) applyOrder(query *AccessTokenQuery) *AccessTokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAccessTokenOrder.Field {
		query = query.Order(DefaultAccessTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *accesstokenPager) orderExpr(query *AccessTokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccessTokenOrder.Field {
			b.Comma().Ident(DefaultAccessTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AccessToken.
func (at *AccessTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccessTokenPaginateOption,
) (*AccessTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccessTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}
	conn := &AccessTokenConnection{Edges: []*AccessTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = at.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if at, err = pager.applyCursors(at, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		at.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := at.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	at = pager.applyOrder(at)
	nodes, err := at.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AccessTokenOrderField defines the ordering field of AccessToken.
type AccessTokenOrderField struct {
	// Value extracts the ordering value from the given AccessToken.
	Value    func(*AccessToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) accesstoken.OrderOption
	toCursor func(*AccessToken) Cursor
}

// AccessTokenOrder defines the ordering of AccessToken.
type AccessTokenOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AccessTokenOrderField `json:"field"`
}

// DefaultAccessTokenOrder is the default ordering of AccessToken.
var DefaultAccessTokenOrder = &AccessTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AccessTokenOrderField{
		Value: func(at *AccessToken) (ent.Value, error) {
			return at.ID, nil
		},
		column: accesstoken.FieldID,
		toTerm: accesstoken.ByID,
		toCursor: func(at *AccessToken) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts AccessToken into AccessTokenEdge.
func (at *AccessToken) ToEdge(order *AccessTokenOrder) *AccessTokenEdge {
	if order == nil {
		order = DefaultAccessTokenOrder
	}
	return &AccessTokenEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// AccountsEdge is the edge representation of Accounts.
type AccountsEdge struct {
	Node   *Accounts `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AccountsConnection is the connection containing edges to Accounts.
type AccountsConnection struct {
	Edges      []*AccountsEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AccountsConnection) build(nodes []*Accounts, pager *accountsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Accounts
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Accounts {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Accounts {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountsPaginateOption enables pagination customization.
type AccountsPaginateOption func(*accountsPager) error

// WithAccountsOrder configures pagination ordering.
func WithAccountsOrder(order *AccountsOrder) AccountsPaginateOption {
	if order == nil {
		order = DefaultAccountsOrder
	}
	o := *order
	return func(pager *accountsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountsFilter configures pagination filter.
func WithAccountsFilter(filter func(*AccountsQuery) (*AccountsQuery, error)) AccountsPaginateOption {
	return func(pager *accountsPager) error {
		if filter == nil {
			return errors.New("AccountsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountsPager struct {
	reverse bool
	order   *AccountsOrder
	filter  func(*AccountsQuery) (*AccountsQuery, error)
}

func newAccountsPager(opts []AccountsPaginateOption, reverse bool) (*accountsPager, error) {
	pager := &accountsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountsOrder
	}
	return pager, nil
}

func (p *accountsPager) applyFilter(query *AccountsQuery) (*AccountsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountsPager) toCursor(a *Accounts) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *accountsPager) applyCursors(query *AccountsQuery, after, before *Cursor) (*AccountsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAccountsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *accountsPager) applyOrder(query *AccountsQuery) *AccountsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAccountsOrder.Field {
		query = query.Order(DefaultAccountsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *accountsPager) orderExpr(query *AccountsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccountsOrder.Field {
			b.Comma().Ident(DefaultAccountsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Accounts.
func (a *AccountsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountsPaginateOption,
) (*AccountsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AccountsConnection{Edges: []*AccountsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AccountsOrderField defines the ordering field of Accounts.
type AccountsOrderField struct {
	// Value extracts the ordering value from the given Accounts.
	Value    func(*Accounts) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) accounts.OrderOption
	toCursor func(*Accounts) Cursor
}

// AccountsOrder defines the ordering of Accounts.
type AccountsOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AccountsOrderField `json:"field"`
}

// DefaultAccountsOrder is the default ordering of Accounts.
var DefaultAccountsOrder = &AccountsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AccountsOrderField{
		Value: func(a *Accounts) (ent.Value, error) {
			return a.ID, nil
		},
		column: accounts.FieldID,
		toTerm: accounts.ByID,
		toCursor: func(a *Accounts) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Accounts into AccountsEdge.
func (a *Accounts) ToEdge(order *AccountsOrder) *AccountsEdge {
	if order == nil {
		order = DefaultAccountsOrder
	}
	return &AccountsEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// MemberRoleRelatedPermissionEdge is the edge representation of MemberRoleRelatedPermission.
type MemberRoleRelatedPermissionEdge struct {
	Node   *MemberRoleRelatedPermission `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// MemberRoleRelatedPermissionConnection is the connection containing edges to MemberRoleRelatedPermission.
type MemberRoleRelatedPermissionConnection struct {
	Edges      []*MemberRoleRelatedPermissionEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *MemberRoleRelatedPermissionConnection) build(nodes []*MemberRoleRelatedPermission, pager *memberrolerelatedpermissionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MemberRoleRelatedPermission
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MemberRoleRelatedPermission {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MemberRoleRelatedPermission {
			return nodes[i]
		}
	}
	c.Edges = make([]*MemberRoleRelatedPermissionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MemberRoleRelatedPermissionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MemberRoleRelatedPermissionPaginateOption enables pagination customization.
type MemberRoleRelatedPermissionPaginateOption func(*memberrolerelatedpermissionPager) error

// WithMemberRoleRelatedPermissionOrder configures pagination ordering.
func WithMemberRoleRelatedPermissionOrder(order *MemberRoleRelatedPermissionOrder) MemberRoleRelatedPermissionPaginateOption {
	if order == nil {
		order = DefaultMemberRoleRelatedPermissionOrder
	}
	o := *order
	return func(pager *memberrolerelatedpermissionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMemberRoleRelatedPermissionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMemberRoleRelatedPermissionFilter configures pagination filter.
func WithMemberRoleRelatedPermissionFilter(filter func(*MemberRoleRelatedPermissionQuery) (*MemberRoleRelatedPermissionQuery, error)) MemberRoleRelatedPermissionPaginateOption {
	return func(pager *memberrolerelatedpermissionPager) error {
		if filter == nil {
			return errors.New("MemberRoleRelatedPermissionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type memberrolerelatedpermissionPager struct {
	reverse bool
	order   *MemberRoleRelatedPermissionOrder
	filter  func(*MemberRoleRelatedPermissionQuery) (*MemberRoleRelatedPermissionQuery, error)
}

func newMemberRoleRelatedPermissionPager(opts []MemberRoleRelatedPermissionPaginateOption, reverse bool) (*memberrolerelatedpermissionPager, error) {
	pager := &memberrolerelatedpermissionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMemberRoleRelatedPermissionOrder
	}
	return pager, nil
}

func (p *memberrolerelatedpermissionPager) applyFilter(query *MemberRoleRelatedPermissionQuery) (*MemberRoleRelatedPermissionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *memberrolerelatedpermissionPager) toCursor(mrrp *MemberRoleRelatedPermission) Cursor {
	return p.order.Field.toCursor(mrrp)
}

func (p *memberrolerelatedpermissionPager) applyCursors(query *MemberRoleRelatedPermissionQuery, after, before *Cursor) (*MemberRoleRelatedPermissionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMemberRoleRelatedPermissionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *memberrolerelatedpermissionPager) applyOrder(query *MemberRoleRelatedPermissionQuery) *MemberRoleRelatedPermissionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMemberRoleRelatedPermissionOrder.Field {
		query = query.Order(DefaultMemberRoleRelatedPermissionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *memberrolerelatedpermissionPager) orderExpr(query *MemberRoleRelatedPermissionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMemberRoleRelatedPermissionOrder.Field {
			b.Comma().Ident(DefaultMemberRoleRelatedPermissionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MemberRoleRelatedPermission.
func (mrrp *MemberRoleRelatedPermissionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MemberRoleRelatedPermissionPaginateOption,
) (*MemberRoleRelatedPermissionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMemberRoleRelatedPermissionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mrrp, err = pager.applyFilter(mrrp); err != nil {
		return nil, err
	}
	conn := &MemberRoleRelatedPermissionConnection{Edges: []*MemberRoleRelatedPermissionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = mrrp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mrrp, err = pager.applyCursors(mrrp, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		mrrp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mrrp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mrrp = pager.applyOrder(mrrp)
	nodes, err := mrrp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MemberRoleRelatedPermissionOrderField defines the ordering field of MemberRoleRelatedPermission.
type MemberRoleRelatedPermissionOrderField struct {
	// Value extracts the ordering value from the given MemberRoleRelatedPermission.
	Value    func(*MemberRoleRelatedPermission) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) memberrolerelatedpermission.OrderOption
	toCursor func(*MemberRoleRelatedPermission) Cursor
}

// MemberRoleRelatedPermissionOrder defines the ordering of MemberRoleRelatedPermission.
type MemberRoleRelatedPermissionOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *MemberRoleRelatedPermissionOrderField `json:"field"`
}

// DefaultMemberRoleRelatedPermissionOrder is the default ordering of MemberRoleRelatedPermission.
var DefaultMemberRoleRelatedPermissionOrder = &MemberRoleRelatedPermissionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MemberRoleRelatedPermissionOrderField{
		Value: func(mrrp *MemberRoleRelatedPermission) (ent.Value, error) {
			return mrrp.ID, nil
		},
		column: memberrolerelatedpermission.FieldID,
		toTerm: memberrolerelatedpermission.ByID,
		toCursor: func(mrrp *MemberRoleRelatedPermission) Cursor {
			return Cursor{ID: mrrp.ID}
		},
	},
}

// ToEdge converts MemberRoleRelatedPermission into MemberRoleRelatedPermissionEdge.
func (mrrp *MemberRoleRelatedPermission) ToEdge(order *MemberRoleRelatedPermissionOrder) *MemberRoleRelatedPermissionEdge {
	if order == nil {
		order = DefaultMemberRoleRelatedPermissionOrder
	}
	return &MemberRoleRelatedPermissionEdge{
		Node:   mrrp,
		Cursor: order.Field.toCursor(mrrp),
	}
}

// PermissionGroupEdge is the edge representation of PermissionGroup.
type PermissionGroupEdge struct {
	Node   *PermissionGroup `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// PermissionGroupConnection is the connection containing edges to PermissionGroup.
type PermissionGroupConnection struct {
	Edges      []*PermissionGroupEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *PermissionGroupConnection) build(nodes []*PermissionGroup, pager *permissiongroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PermissionGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PermissionGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PermissionGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*PermissionGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PermissionGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PermissionGroupPaginateOption enables pagination customization.
type PermissionGroupPaginateOption func(*permissiongroupPager) error

// WithPermissionGroupOrder configures pagination ordering.
func WithPermissionGroupOrder(order *PermissionGroupOrder) PermissionGroupPaginateOption {
	if order == nil {
		order = DefaultPermissionGroupOrder
	}
	o := *order
	return func(pager *permissiongroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPermissionGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPermissionGroupFilter configures pagination filter.
func WithPermissionGroupFilter(filter func(*PermissionGroupQuery) (*PermissionGroupQuery, error)) PermissionGroupPaginateOption {
	return func(pager *permissiongroupPager) error {
		if filter == nil {
			return errors.New("PermissionGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type permissiongroupPager struct {
	reverse bool
	order   *PermissionGroupOrder
	filter  func(*PermissionGroupQuery) (*PermissionGroupQuery, error)
}

func newPermissionGroupPager(opts []PermissionGroupPaginateOption, reverse bool) (*permissiongroupPager, error) {
	pager := &permissiongroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPermissionGroupOrder
	}
	return pager, nil
}

func (p *permissiongroupPager) applyFilter(query *PermissionGroupQuery) (*PermissionGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *permissiongroupPager) toCursor(pg *PermissionGroup) Cursor {
	return p.order.Field.toCursor(pg)
}

func (p *permissiongroupPager) applyCursors(query *PermissionGroupQuery, after, before *Cursor) (*PermissionGroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPermissionGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *permissiongroupPager) applyOrder(query *PermissionGroupQuery) *PermissionGroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPermissionGroupOrder.Field {
		query = query.Order(DefaultPermissionGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *permissiongroupPager) orderExpr(query *PermissionGroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPermissionGroupOrder.Field {
			b.Comma().Ident(DefaultPermissionGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PermissionGroup.
func (pg *PermissionGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PermissionGroupPaginateOption,
) (*PermissionGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPermissionGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pg, err = pager.applyFilter(pg); err != nil {
		return nil, err
	}
	conn := &PermissionGroupConnection{Edges: []*PermissionGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pg.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pg, err = pager.applyCursors(pg, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pg.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pg = pager.applyOrder(pg)
	nodes, err := pg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PermissionGroupOrderField defines the ordering field of PermissionGroup.
type PermissionGroupOrderField struct {
	// Value extracts the ordering value from the given PermissionGroup.
	Value    func(*PermissionGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) permissiongroup.OrderOption
	toCursor func(*PermissionGroup) Cursor
}

// PermissionGroupOrder defines the ordering of PermissionGroup.
type PermissionGroupOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *PermissionGroupOrderField `json:"field"`
}

// DefaultPermissionGroupOrder is the default ordering of PermissionGroup.
var DefaultPermissionGroupOrder = &PermissionGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PermissionGroupOrderField{
		Value: func(pg *PermissionGroup) (ent.Value, error) {
			return pg.ID, nil
		},
		column: permissiongroup.FieldID,
		toTerm: permissiongroup.ByID,
		toCursor: func(pg *PermissionGroup) Cursor {
			return Cursor{ID: pg.ID}
		},
	},
}

// ToEdge converts PermissionGroup into PermissionGroupEdge.
func (pg *PermissionGroup) ToEdge(order *PermissionGroupOrder) *PermissionGroupEdge {
	if order == nil {
		order = DefaultPermissionGroupOrder
	}
	return &PermissionGroupEdge{
		Node:   pg,
		Cursor: order.Field.toCursor(pg),
	}
}

// PermissionRelatedRouterEdge is the edge representation of PermissionRelatedRouter.
type PermissionRelatedRouterEdge struct {
	Node   *PermissionRelatedRouter `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// PermissionRelatedRouterConnection is the connection containing edges to PermissionRelatedRouter.
type PermissionRelatedRouterConnection struct {
	Edges      []*PermissionRelatedRouterEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *PermissionRelatedRouterConnection) build(nodes []*PermissionRelatedRouter, pager *permissionrelatedrouterPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PermissionRelatedRouter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PermissionRelatedRouter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PermissionRelatedRouter {
			return nodes[i]
		}
	}
	c.Edges = make([]*PermissionRelatedRouterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PermissionRelatedRouterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PermissionRelatedRouterPaginateOption enables pagination customization.
type PermissionRelatedRouterPaginateOption func(*permissionrelatedrouterPager) error

// WithPermissionRelatedRouterOrder configures pagination ordering.
func WithPermissionRelatedRouterOrder(order *PermissionRelatedRouterOrder) PermissionRelatedRouterPaginateOption {
	if order == nil {
		order = DefaultPermissionRelatedRouterOrder
	}
	o := *order
	return func(pager *permissionrelatedrouterPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPermissionRelatedRouterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPermissionRelatedRouterFilter configures pagination filter.
func WithPermissionRelatedRouterFilter(filter func(*PermissionRelatedRouterQuery) (*PermissionRelatedRouterQuery, error)) PermissionRelatedRouterPaginateOption {
	return func(pager *permissionrelatedrouterPager) error {
		if filter == nil {
			return errors.New("PermissionRelatedRouterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type permissionrelatedrouterPager struct {
	reverse bool
	order   *PermissionRelatedRouterOrder
	filter  func(*PermissionRelatedRouterQuery) (*PermissionRelatedRouterQuery, error)
}

func newPermissionRelatedRouterPager(opts []PermissionRelatedRouterPaginateOption, reverse bool) (*permissionrelatedrouterPager, error) {
	pager := &permissionrelatedrouterPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPermissionRelatedRouterOrder
	}
	return pager, nil
}

func (p *permissionrelatedrouterPager) applyFilter(query *PermissionRelatedRouterQuery) (*PermissionRelatedRouterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *permissionrelatedrouterPager) toCursor(prr *PermissionRelatedRouter) Cursor {
	return p.order.Field.toCursor(prr)
}

func (p *permissionrelatedrouterPager) applyCursors(query *PermissionRelatedRouterQuery, after, before *Cursor) (*PermissionRelatedRouterQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPermissionRelatedRouterOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *permissionrelatedrouterPager) applyOrder(query *PermissionRelatedRouterQuery) *PermissionRelatedRouterQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPermissionRelatedRouterOrder.Field {
		query = query.Order(DefaultPermissionRelatedRouterOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *permissionrelatedrouterPager) orderExpr(query *PermissionRelatedRouterQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPermissionRelatedRouterOrder.Field {
			b.Comma().Ident(DefaultPermissionRelatedRouterOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PermissionRelatedRouter.
func (prr *PermissionRelatedRouterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PermissionRelatedRouterPaginateOption,
) (*PermissionRelatedRouterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPermissionRelatedRouterPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if prr, err = pager.applyFilter(prr); err != nil {
		return nil, err
	}
	conn := &PermissionRelatedRouterConnection{Edges: []*PermissionRelatedRouterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = prr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if prr, err = pager.applyCursors(prr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		prr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := prr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	prr = pager.applyOrder(prr)
	nodes, err := prr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PermissionRelatedRouterOrderField defines the ordering field of PermissionRelatedRouter.
type PermissionRelatedRouterOrderField struct {
	// Value extracts the ordering value from the given PermissionRelatedRouter.
	Value    func(*PermissionRelatedRouter) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) permissionrelatedrouter.OrderOption
	toCursor func(*PermissionRelatedRouter) Cursor
}

// PermissionRelatedRouterOrder defines the ordering of PermissionRelatedRouter.
type PermissionRelatedRouterOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *PermissionRelatedRouterOrderField `json:"field"`
}

// DefaultPermissionRelatedRouterOrder is the default ordering of PermissionRelatedRouter.
var DefaultPermissionRelatedRouterOrder = &PermissionRelatedRouterOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PermissionRelatedRouterOrderField{
		Value: func(prr *PermissionRelatedRouter) (ent.Value, error) {
			return prr.ID, nil
		},
		column: permissionrelatedrouter.FieldID,
		toTerm: permissionrelatedrouter.ByID,
		toCursor: func(prr *PermissionRelatedRouter) Cursor {
			return Cursor{ID: prr.ID}
		},
	},
}

// ToEdge converts PermissionRelatedRouter into PermissionRelatedRouterEdge.
func (prr *PermissionRelatedRouter) ToEdge(order *PermissionRelatedRouterOrder) *PermissionRelatedRouterEdge {
	if order == nil {
		order = DefaultPermissionRelatedRouterOrder
	}
	return &PermissionRelatedRouterEdge{
		Node:   prr,
		Cursor: order.Field.toCursor(prr),
	}
}

// RouterEdge is the edge representation of Router.
type RouterEdge struct {
	Node   *Router `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// RouterConnection is the connection containing edges to Router.
type RouterConnection struct {
	Edges      []*RouterEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *RouterConnection) build(nodes []*Router, pager *routerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Router
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Router {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Router {
			return nodes[i]
		}
	}
	c.Edges = make([]*RouterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RouterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RouterPaginateOption enables pagination customization.
type RouterPaginateOption func(*routerPager) error

// WithRouterOrder configures pagination ordering.
func WithRouterOrder(order *RouterOrder) RouterPaginateOption {
	if order == nil {
		order = DefaultRouterOrder
	}
	o := *order
	return func(pager *routerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRouterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRouterFilter configures pagination filter.
func WithRouterFilter(filter func(*RouterQuery) (*RouterQuery, error)) RouterPaginateOption {
	return func(pager *routerPager) error {
		if filter == nil {
			return errors.New("RouterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type routerPager struct {
	reverse bool
	order   *RouterOrder
	filter  func(*RouterQuery) (*RouterQuery, error)
}

func newRouterPager(opts []RouterPaginateOption, reverse bool) (*routerPager, error) {
	pager := &routerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRouterOrder
	}
	return pager, nil
}

func (p *routerPager) applyFilter(query *RouterQuery) (*RouterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *routerPager) toCursor(r *Router) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *routerPager) applyCursors(query *RouterQuery, after, before *Cursor) (*RouterQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRouterOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *routerPager) applyOrder(query *RouterQuery) *RouterQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRouterOrder.Field {
		query = query.Order(DefaultRouterOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *routerPager) orderExpr(query *RouterQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRouterOrder.Field {
			b.Comma().Ident(DefaultRouterOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Router.
func (r *RouterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RouterPaginateOption,
) (*RouterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRouterPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RouterConnection{Edges: []*RouterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = r.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RouterOrderField defines the ordering field of Router.
type RouterOrderField struct {
	// Value extracts the ordering value from the given Router.
	Value    func(*Router) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) router.OrderOption
	toCursor func(*Router) Cursor
}

// RouterOrder defines the ordering of Router.
type RouterOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *RouterOrderField `json:"field"`
}

// DefaultRouterOrder is the default ordering of Router.
var DefaultRouterOrder = &RouterOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RouterOrderField{
		Value: func(r *Router) (ent.Value, error) {
			return r.ID, nil
		},
		column: router.FieldID,
		toTerm: router.ByID,
		toCursor: func(r *Router) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Router into RouterEdge.
func (r *Router) ToEdge(order *RouterOrder) *RouterEdge {
	if order == nil {
		order = DefaultRouterOrder
	}
	return &RouterEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SourceEdge is the edge representation of Source.
type SourceEdge struct {
	Node   *Source `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// SourceConnection is the connection containing edges to Source.
type SourceConnection struct {
	Edges      []*SourceEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *SourceConnection) build(nodes []*Source, pager *sourcePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Source
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Source {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Source {
			return nodes[i]
		}
	}
	c.Edges = make([]*SourceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SourceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SourcePaginateOption enables pagination customization.
type SourcePaginateOption func(*sourcePager) error

// WithSourceOrder configures pagination ordering.
func WithSourceOrder(order *SourceOrder) SourcePaginateOption {
	if order == nil {
		order = DefaultSourceOrder
	}
	o := *order
	return func(pager *sourcePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSourceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSourceFilter configures pagination filter.
func WithSourceFilter(filter func(*SourceQuery) (*SourceQuery, error)) SourcePaginateOption {
	return func(pager *sourcePager) error {
		if filter == nil {
			return errors.New("SourceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sourcePager struct {
	reverse bool
	order   *SourceOrder
	filter  func(*SourceQuery) (*SourceQuery, error)
}

func newSourcePager(opts []SourcePaginateOption, reverse bool) (*sourcePager, error) {
	pager := &sourcePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSourceOrder
	}
	return pager, nil
}

func (p *sourcePager) applyFilter(query *SourceQuery) (*SourceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sourcePager) toCursor(s *Source) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *sourcePager) applyCursors(query *SourceQuery, after, before *Cursor) (*SourceQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSourceOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *sourcePager) applyOrder(query *SourceQuery) *SourceQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSourceOrder.Field {
		query = query.Order(DefaultSourceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *sourcePager) orderExpr(query *SourceQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSourceOrder.Field {
			b.Comma().Ident(DefaultSourceOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Source.
func (s *SourceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SourcePaginateOption,
) (*SourceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSourcePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SourceConnection{Edges: []*SourceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SourceOrderField defines the ordering field of Source.
type SourceOrderField struct {
	// Value extracts the ordering value from the given Source.
	Value    func(*Source) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) source.OrderOption
	toCursor func(*Source) Cursor
}

// SourceOrder defines the ordering of Source.
type SourceOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *SourceOrderField `json:"field"`
}

// DefaultSourceOrder is the default ordering of Source.
var DefaultSourceOrder = &SourceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SourceOrderField{
		Value: func(s *Source) (ent.Value, error) {
			return s.ID, nil
		},
		column: source.FieldID,
		toTerm: source.ByID,
		toCursor: func(s *Source) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Source into SourceEdge.
func (s *Source) ToEdge(order *SourceOrder) *SourceEdge {
	if order == nil {
		order = DefaultSourceOrder
	}
	return &SourceEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SourceDataEdge is the edge representation of SourceData.
type SourceDataEdge struct {
	Node   *SourceData `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SourceDataConnection is the connection containing edges to SourceData.
type SourceDataConnection struct {
	Edges      []*SourceDataEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SourceDataConnection) build(nodes []*SourceData, pager *sourcedataPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SourceData
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SourceData {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SourceData {
			return nodes[i]
		}
	}
	c.Edges = make([]*SourceDataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SourceDataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SourceDataPaginateOption enables pagination customization.
type SourceDataPaginateOption func(*sourcedataPager) error

// WithSourceDataOrder configures pagination ordering.
func WithSourceDataOrder(order *SourceDataOrder) SourceDataPaginateOption {
	if order == nil {
		order = DefaultSourceDataOrder
	}
	o := *order
	return func(pager *sourcedataPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSourceDataOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSourceDataFilter configures pagination filter.
func WithSourceDataFilter(filter func(*SourceDataQuery) (*SourceDataQuery, error)) SourceDataPaginateOption {
	return func(pager *sourcedataPager) error {
		if filter == nil {
			return errors.New("SourceDataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sourcedataPager struct {
	reverse bool
	order   *SourceDataOrder
	filter  func(*SourceDataQuery) (*SourceDataQuery, error)
}

func newSourceDataPager(opts []SourceDataPaginateOption, reverse bool) (*sourcedataPager, error) {
	pager := &sourcedataPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSourceDataOrder
	}
	return pager, nil
}

func (p *sourcedataPager) applyFilter(query *SourceDataQuery) (*SourceDataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sourcedataPager) toCursor(sd *SourceData) Cursor {
	return p.order.Field.toCursor(sd)
}

func (p *sourcedataPager) applyCursors(query *SourceDataQuery, after, before *Cursor) (*SourceDataQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSourceDataOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *sourcedataPager) applyOrder(query *SourceDataQuery) *SourceDataQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSourceDataOrder.Field {
		query = query.Order(DefaultSourceDataOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *sourcedataPager) orderExpr(query *SourceDataQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSourceDataOrder.Field {
			b.Comma().Ident(DefaultSourceDataOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SourceData.
func (sd *SourceDataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SourceDataPaginateOption,
) (*SourceDataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSourceDataPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sd, err = pager.applyFilter(sd); err != nil {
		return nil, err
	}
	conn := &SourceDataConnection{Edges: []*SourceDataEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = sd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sd, err = pager.applyCursors(sd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sd = pager.applyOrder(sd)
	nodes, err := sd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SourceDataOrderField defines the ordering field of SourceData.
type SourceDataOrderField struct {
	// Value extracts the ordering value from the given SourceData.
	Value    func(*SourceData) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) sourcedata.OrderOption
	toCursor func(*SourceData) Cursor
}

// SourceDataOrder defines the ordering of SourceData.
type SourceDataOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SourceDataOrderField `json:"field"`
}

// DefaultSourceDataOrder is the default ordering of SourceData.
var DefaultSourceDataOrder = &SourceDataOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SourceDataOrderField{
		Value: func(sd *SourceData) (ent.Value, error) {
			return sd.ID, nil
		},
		column: sourcedata.FieldID,
		toTerm: sourcedata.ByID,
		toCursor: func(sd *SourceData) Cursor {
			return Cursor{ID: sd.ID}
		},
	},
}

// ToEdge converts SourceData into SourceDataEdge.
func (sd *SourceData) ToEdge(order *SourceDataOrder) *SourceDataEdge {
	if order == nil {
		order = DefaultSourceDataOrder
	}
	return &SourceDataEdge{
		Node:   sd,
		Cursor: order.Field.toCursor(sd),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserAuthSourceEdge is the edge representation of UserAuthSource.
type UserAuthSourceEdge struct {
	Node   *UserAuthSource `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// UserAuthSourceConnection is the connection containing edges to UserAuthSource.
type UserAuthSourceConnection struct {
	Edges      []*UserAuthSourceEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *UserAuthSourceConnection) build(nodes []*UserAuthSource, pager *userauthsourcePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserAuthSource
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserAuthSource {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserAuthSource {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserAuthSourceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserAuthSourceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserAuthSourcePaginateOption enables pagination customization.
type UserAuthSourcePaginateOption func(*userauthsourcePager) error

// WithUserAuthSourceOrder configures pagination ordering.
func WithUserAuthSourceOrder(order *UserAuthSourceOrder) UserAuthSourcePaginateOption {
	if order == nil {
		order = DefaultUserAuthSourceOrder
	}
	o := *order
	return func(pager *userauthsourcePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserAuthSourceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserAuthSourceFilter configures pagination filter.
func WithUserAuthSourceFilter(filter func(*UserAuthSourceQuery) (*UserAuthSourceQuery, error)) UserAuthSourcePaginateOption {
	return func(pager *userauthsourcePager) error {
		if filter == nil {
			return errors.New("UserAuthSourceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userauthsourcePager struct {
	reverse bool
	order   *UserAuthSourceOrder
	filter  func(*UserAuthSourceQuery) (*UserAuthSourceQuery, error)
}

func newUserAuthSourcePager(opts []UserAuthSourcePaginateOption, reverse bool) (*userauthsourcePager, error) {
	pager := &userauthsourcePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserAuthSourceOrder
	}
	return pager, nil
}

func (p *userauthsourcePager) applyFilter(query *UserAuthSourceQuery) (*UserAuthSourceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userauthsourcePager) toCursor(uas *UserAuthSource) Cursor {
	return p.order.Field.toCursor(uas)
}

func (p *userauthsourcePager) applyCursors(query *UserAuthSourceQuery, after, before *Cursor) (*UserAuthSourceQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserAuthSourceOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userauthsourcePager) applyOrder(query *UserAuthSourceQuery) *UserAuthSourceQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserAuthSourceOrder.Field {
		query = query.Order(DefaultUserAuthSourceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userauthsourcePager) orderExpr(query *UserAuthSourceQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserAuthSourceOrder.Field {
			b.Comma().Ident(DefaultUserAuthSourceOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserAuthSource.
func (uas *UserAuthSourceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserAuthSourcePaginateOption,
) (*UserAuthSourceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserAuthSourcePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if uas, err = pager.applyFilter(uas); err != nil {
		return nil, err
	}
	conn := &UserAuthSourceConnection{Edges: []*UserAuthSourceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = uas.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if uas, err = pager.applyCursors(uas, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		uas.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := uas.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	uas = pager.applyOrder(uas)
	nodes, err := uas.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserAuthSourceOrderField defines the ordering field of UserAuthSource.
type UserAuthSourceOrderField struct {
	// Value extracts the ordering value from the given UserAuthSource.
	Value    func(*UserAuthSource) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userauthsource.OrderOption
	toCursor func(*UserAuthSource) Cursor
}

// UserAuthSourceOrder defines the ordering of UserAuthSource.
type UserAuthSourceOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *UserAuthSourceOrderField `json:"field"`
}

// DefaultUserAuthSourceOrder is the default ordering of UserAuthSource.
var DefaultUserAuthSourceOrder = &UserAuthSourceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserAuthSourceOrderField{
		Value: func(uas *UserAuthSource) (ent.Value, error) {
			return uas.ID, nil
		},
		column: userauthsource.FieldID,
		toTerm: userauthsource.ByID,
		toCursor: func(uas *UserAuthSource) Cursor {
			return Cursor{ID: uas.ID}
		},
	},
}

// ToEdge converts UserAuthSource into UserAuthSourceEdge.
func (uas *UserAuthSource) ToEdge(order *UserAuthSourceOrder) *UserAuthSourceEdge {
	if order == nil {
		order = DefaultUserAuthSourceOrder
	}
	return &UserAuthSourceEdge{
		Node:   uas,
		Cursor: order.Field.toCursor(uas),
	}
}

// UserRelatedRoleEdge is the edge representation of UserRelatedRole.
type UserRelatedRoleEdge struct {
	Node   *UserRelatedRole `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// UserRelatedRoleConnection is the connection containing edges to UserRelatedRole.
type UserRelatedRoleConnection struct {
	Edges      []*UserRelatedRoleEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *UserRelatedRoleConnection) build(nodes []*UserRelatedRole, pager *userrelatedrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserRelatedRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserRelatedRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserRelatedRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserRelatedRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserRelatedRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserRelatedRolePaginateOption enables pagination customization.
type UserRelatedRolePaginateOption func(*userrelatedrolePager) error

// WithUserRelatedRoleOrder configures pagination ordering.
func WithUserRelatedRoleOrder(order *UserRelatedRoleOrder) UserRelatedRolePaginateOption {
	if order == nil {
		order = DefaultUserRelatedRoleOrder
	}
	o := *order
	return func(pager *userrelatedrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserRelatedRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserRelatedRoleFilter configures pagination filter.
func WithUserRelatedRoleFilter(filter func(*UserRelatedRoleQuery) (*UserRelatedRoleQuery, error)) UserRelatedRolePaginateOption {
	return func(pager *userrelatedrolePager) error {
		if filter == nil {
			return errors.New("UserRelatedRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userrelatedrolePager struct {
	reverse bool
	order   *UserRelatedRoleOrder
	filter  func(*UserRelatedRoleQuery) (*UserRelatedRoleQuery, error)
}

func newUserRelatedRolePager(opts []UserRelatedRolePaginateOption, reverse bool) (*userrelatedrolePager, error) {
	pager := &userrelatedrolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserRelatedRoleOrder
	}
	return pager, nil
}

func (p *userrelatedrolePager) applyFilter(query *UserRelatedRoleQuery) (*UserRelatedRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userrelatedrolePager) toCursor(urr *UserRelatedRole) Cursor {
	return p.order.Field.toCursor(urr)
}

func (p *userrelatedrolePager) applyCursors(query *UserRelatedRoleQuery, after, before *Cursor) (*UserRelatedRoleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserRelatedRoleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userrelatedrolePager) applyOrder(query *UserRelatedRoleQuery) *UserRelatedRoleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserRelatedRoleOrder.Field {
		query = query.Order(DefaultUserRelatedRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userrelatedrolePager) orderExpr(query *UserRelatedRoleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserRelatedRoleOrder.Field {
			b.Comma().Ident(DefaultUserRelatedRoleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserRelatedRole.
func (urr *UserRelatedRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserRelatedRolePaginateOption,
) (*UserRelatedRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserRelatedRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if urr, err = pager.applyFilter(urr); err != nil {
		return nil, err
	}
	conn := &UserRelatedRoleConnection{Edges: []*UserRelatedRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = urr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if urr, err = pager.applyCursors(urr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		urr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := urr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	urr = pager.applyOrder(urr)
	nodes, err := urr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserRelatedRoleOrderField defines the ordering field of UserRelatedRole.
type UserRelatedRoleOrderField struct {
	// Value extracts the ordering value from the given UserRelatedRole.
	Value    func(*UserRelatedRole) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userrelatedrole.OrderOption
	toCursor func(*UserRelatedRole) Cursor
}

// UserRelatedRoleOrder defines the ordering of UserRelatedRole.
type UserRelatedRoleOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *UserRelatedRoleOrderField `json:"field"`
}

// DefaultUserRelatedRoleOrder is the default ordering of UserRelatedRole.
var DefaultUserRelatedRoleOrder = &UserRelatedRoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserRelatedRoleOrderField{
		Value: func(urr *UserRelatedRole) (ent.Value, error) {
			return urr.ID, nil
		},
		column: userrelatedrole.FieldID,
		toTerm: userrelatedrole.ByID,
		toCursor: func(urr *UserRelatedRole) Cursor {
			return Cursor{ID: urr.ID}
		},
	},
}

// ToEdge converts UserRelatedRole into UserRelatedRoleEdge.
func (urr *UserRelatedRole) ToEdge(order *UserRelatedRoleOrder) *UserRelatedRoleEdge {
	if order == nil {
		order = DefaultUserRelatedRoleOrder
	}
	return &UserRelatedRoleEdge{
		Node:   urr,
		Cursor: order.Field.toCursor(urr),
	}
}

// UserRoleEdge is the edge representation of UserRole.
type UserRoleEdge struct {
	Node   *UserRole `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UserRoleConnection is the connection containing edges to UserRole.
type UserRoleConnection struct {
	Edges      []*UserRoleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UserRoleConnection) build(nodes []*UserRole, pager *userrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserRolePaginateOption enables pagination customization.
type UserRolePaginateOption func(*userrolePager) error

// WithUserRoleOrder configures pagination ordering.
func WithUserRoleOrder(order *UserRoleOrder) UserRolePaginateOption {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	o := *order
	return func(pager *userrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserRoleFilter configures pagination filter.
func WithUserRoleFilter(filter func(*UserRoleQuery) (*UserRoleQuery, error)) UserRolePaginateOption {
	return func(pager *userrolePager) error {
		if filter == nil {
			return errors.New("UserRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userrolePager struct {
	reverse bool
	order   *UserRoleOrder
	filter  func(*UserRoleQuery) (*UserRoleQuery, error)
}

func newUserRolePager(opts []UserRolePaginateOption, reverse bool) (*userrolePager, error) {
	pager := &userrolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserRoleOrder
	}
	return pager, nil
}

func (p *userrolePager) applyFilter(query *UserRoleQuery) (*UserRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userrolePager) toCursor(ur *UserRole) Cursor {
	return p.order.Field.toCursor(ur)
}

func (p *userrolePager) applyCursors(query *UserRoleQuery, after, before *Cursor) (*UserRoleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserRoleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userrolePager) applyOrder(query *UserRoleQuery) *UserRoleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserRoleOrder.Field {
		query = query.Order(DefaultUserRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userrolePager) orderExpr(query *UserRoleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserRoleOrder.Field {
			b.Comma().Ident(DefaultUserRoleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserRole.
func (ur *UserRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserRolePaginateOption,
) (*UserRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ur, err = pager.applyFilter(ur); err != nil {
		return nil, err
	}
	conn := &UserRoleConnection{Edges: []*UserRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ur.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ur, err = pager.applyCursors(ur, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ur.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ur.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ur = pager.applyOrder(ur)
	nodes, err := ur.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserRoleOrderField defines the ordering field of UserRole.
type UserRoleOrderField struct {
	// Value extracts the ordering value from the given UserRole.
	Value    func(*UserRole) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userrole.OrderOption
	toCursor func(*UserRole) Cursor
}

// UserRoleOrder defines the ordering of UserRole.
type UserRoleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UserRoleOrderField `json:"field"`
}

// DefaultUserRoleOrder is the default ordering of UserRole.
var DefaultUserRoleOrder = &UserRoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserRoleOrderField{
		Value: func(ur *UserRole) (ent.Value, error) {
			return ur.ID, nil
		},
		column: userrole.FieldID,
		toTerm: userrole.ByID,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{ID: ur.ID}
		},
	},
}

// ToEdge converts UserRole into UserRoleEdge.
func (ur *UserRole) ToEdge(order *UserRoleOrder) *UserRoleEdge {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	return &UserRoleEdge{
		Node:   ur,
		Cursor: order.Field.toCursor(ur),
	}
}

// WakatimeEdge is the edge representation of Wakatime.
type WakatimeEdge struct {
	Node   *Wakatime `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// WakatimeConnection is the connection containing edges to Wakatime.
type WakatimeConnection struct {
	Edges      []*WakatimeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *WakatimeConnection) build(nodes []*Wakatime, pager *wakatimePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Wakatime
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Wakatime {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Wakatime {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimePaginateOption enables pagination customization.
type WakatimePaginateOption func(*wakatimePager) error

// WithWakatimeOrder configures pagination ordering.
func WithWakatimeOrder(order *WakatimeOrder) WakatimePaginateOption {
	if order == nil {
		order = DefaultWakatimeOrder
	}
	o := *order
	return func(pager *wakatimePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeFilter configures pagination filter.
func WithWakatimeFilter(filter func(*WakatimeQuery) (*WakatimeQuery, error)) WakatimePaginateOption {
	return func(pager *wakatimePager) error {
		if filter == nil {
			return errors.New("WakatimeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimePager struct {
	reverse bool
	order   *WakatimeOrder
	filter  func(*WakatimeQuery) (*WakatimeQuery, error)
}

func newWakatimePager(opts []WakatimePaginateOption, reverse bool) (*wakatimePager, error) {
	pager := &wakatimePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeOrder
	}
	return pager, nil
}

func (p *wakatimePager) applyFilter(query *WakatimeQuery) (*WakatimeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimePager) toCursor(w *Wakatime) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *wakatimePager) applyCursors(query *WakatimeQuery, after, before *Cursor) (*WakatimeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimePager) applyOrder(query *WakatimeQuery) *WakatimeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeOrder.Field {
		query = query.Order(DefaultWakatimeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimePager) orderExpr(query *WakatimeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeOrder.Field {
			b.Comma().Ident(DefaultWakatimeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Wakatime.
func (w *WakatimeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimePaginateOption,
) (*WakatimeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WakatimeConnection{Edges: []*WakatimeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeOrderField defines the ordering field of Wakatime.
type WakatimeOrderField struct {
	// Value extracts the ordering value from the given Wakatime.
	Value    func(*Wakatime) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatime.OrderOption
	toCursor func(*Wakatime) Cursor
}

// WakatimeOrder defines the ordering of Wakatime.
type WakatimeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *WakatimeOrderField `json:"field"`
}

// DefaultWakatimeOrder is the default ordering of Wakatime.
var DefaultWakatimeOrder = &WakatimeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeOrderField{
		Value: func(w *Wakatime) (ent.Value, error) {
			return w.ID, nil
		},
		column: wakatime.FieldID,
		toTerm: wakatime.ByID,
		toCursor: func(w *Wakatime) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Wakatime into WakatimeEdge.
func (w *Wakatime) ToEdge(order *WakatimeOrder) *WakatimeEdge {
	if order == nil {
		order = DefaultWakatimeOrder
	}
	return &WakatimeEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}

// WakatimeCategoryEdge is the edge representation of WakatimeCategory.
type WakatimeCategoryEdge struct {
	Node   *WakatimeCategory `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// WakatimeCategoryConnection is the connection containing edges to WakatimeCategory.
type WakatimeCategoryConnection struct {
	Edges      []*WakatimeCategoryEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *WakatimeCategoryConnection) build(nodes []*WakatimeCategory, pager *wakatimecategoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeCategory {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeCategoryPaginateOption enables pagination customization.
type WakatimeCategoryPaginateOption func(*wakatimecategoryPager) error

// WithWakatimeCategoryOrder configures pagination ordering.
func WithWakatimeCategoryOrder(order *WakatimeCategoryOrder) WakatimeCategoryPaginateOption {
	if order == nil {
		order = DefaultWakatimeCategoryOrder
	}
	o := *order
	return func(pager *wakatimecategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeCategoryFilter configures pagination filter.
func WithWakatimeCategoryFilter(filter func(*WakatimeCategoryQuery) (*WakatimeCategoryQuery, error)) WakatimeCategoryPaginateOption {
	return func(pager *wakatimecategoryPager) error {
		if filter == nil {
			return errors.New("WakatimeCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimecategoryPager struct {
	reverse bool
	order   *WakatimeCategoryOrder
	filter  func(*WakatimeCategoryQuery) (*WakatimeCategoryQuery, error)
}

func newWakatimeCategoryPager(opts []WakatimeCategoryPaginateOption, reverse bool) (*wakatimecategoryPager, error) {
	pager := &wakatimecategoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeCategoryOrder
	}
	return pager, nil
}

func (p *wakatimecategoryPager) applyFilter(query *WakatimeCategoryQuery) (*WakatimeCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimecategoryPager) toCursor(wc *WakatimeCategory) Cursor {
	return p.order.Field.toCursor(wc)
}

func (p *wakatimecategoryPager) applyCursors(query *WakatimeCategoryQuery, after, before *Cursor) (*WakatimeCategoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeCategoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimecategoryPager) applyOrder(query *WakatimeCategoryQuery) *WakatimeCategoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeCategoryOrder.Field {
		query = query.Order(DefaultWakatimeCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimecategoryPager) orderExpr(query *WakatimeCategoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeCategoryOrder.Field {
			b.Comma().Ident(DefaultWakatimeCategoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeCategory.
func (wc *WakatimeCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeCategoryPaginateOption,
) (*WakatimeCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wc, err = pager.applyFilter(wc); err != nil {
		return nil, err
	}
	conn := &WakatimeCategoryConnection{Edges: []*WakatimeCategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wc, err = pager.applyCursors(wc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wc = pager.applyOrder(wc)
	nodes, err := wc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeCategoryOrderField defines the ordering field of WakatimeCategory.
type WakatimeCategoryOrderField struct {
	// Value extracts the ordering value from the given WakatimeCategory.
	Value    func(*WakatimeCategory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimecategory.OrderOption
	toCursor func(*WakatimeCategory) Cursor
}

// WakatimeCategoryOrder defines the ordering of WakatimeCategory.
type WakatimeCategoryOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *WakatimeCategoryOrderField `json:"field"`
}

// DefaultWakatimeCategoryOrder is the default ordering of WakatimeCategory.
var DefaultWakatimeCategoryOrder = &WakatimeCategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeCategoryOrderField{
		Value: func(wc *WakatimeCategory) (ent.Value, error) {
			return wc.ID, nil
		},
		column: wakatimecategory.FieldID,
		toTerm: wakatimecategory.ByID,
		toCursor: func(wc *WakatimeCategory) Cursor {
			return Cursor{ID: wc.ID}
		},
	},
}

// ToEdge converts WakatimeCategory into WakatimeCategoryEdge.
func (wc *WakatimeCategory) ToEdge(order *WakatimeCategoryOrder) *WakatimeCategoryEdge {
	if order == nil {
		order = DefaultWakatimeCategoryOrder
	}
	return &WakatimeCategoryEdge{
		Node:   wc,
		Cursor: order.Field.toCursor(wc),
	}
}

// WakatimeDependencyEdge is the edge representation of WakatimeDependency.
type WakatimeDependencyEdge struct {
	Node   *WakatimeDependency `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// WakatimeDependencyConnection is the connection containing edges to WakatimeDependency.
type WakatimeDependencyConnection struct {
	Edges      []*WakatimeDependencyEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *WakatimeDependencyConnection) build(nodes []*WakatimeDependency, pager *wakatimedependencyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeDependency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeDependency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeDependency {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeDependencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeDependencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeDependencyPaginateOption enables pagination customization.
type WakatimeDependencyPaginateOption func(*wakatimedependencyPager) error

// WithWakatimeDependencyOrder configures pagination ordering.
func WithWakatimeDependencyOrder(order *WakatimeDependencyOrder) WakatimeDependencyPaginateOption {
	if order == nil {
		order = DefaultWakatimeDependencyOrder
	}
	o := *order
	return func(pager *wakatimedependencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeDependencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeDependencyFilter configures pagination filter.
func WithWakatimeDependencyFilter(filter func(*WakatimeDependencyQuery) (*WakatimeDependencyQuery, error)) WakatimeDependencyPaginateOption {
	return func(pager *wakatimedependencyPager) error {
		if filter == nil {
			return errors.New("WakatimeDependencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimedependencyPager struct {
	reverse bool
	order   *WakatimeDependencyOrder
	filter  func(*WakatimeDependencyQuery) (*WakatimeDependencyQuery, error)
}

func newWakatimeDependencyPager(opts []WakatimeDependencyPaginateOption, reverse bool) (*wakatimedependencyPager, error) {
	pager := &wakatimedependencyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeDependencyOrder
	}
	return pager, nil
}

func (p *wakatimedependencyPager) applyFilter(query *WakatimeDependencyQuery) (*WakatimeDependencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimedependencyPager) toCursor(wd *WakatimeDependency) Cursor {
	return p.order.Field.toCursor(wd)
}

func (p *wakatimedependencyPager) applyCursors(query *WakatimeDependencyQuery, after, before *Cursor) (*WakatimeDependencyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeDependencyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimedependencyPager) applyOrder(query *WakatimeDependencyQuery) *WakatimeDependencyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeDependencyOrder.Field {
		query = query.Order(DefaultWakatimeDependencyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimedependencyPager) orderExpr(query *WakatimeDependencyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeDependencyOrder.Field {
			b.Comma().Ident(DefaultWakatimeDependencyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeDependency.
func (wd *WakatimeDependencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeDependencyPaginateOption,
) (*WakatimeDependencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeDependencyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wd, err = pager.applyFilter(wd); err != nil {
		return nil, err
	}
	conn := &WakatimeDependencyConnection{Edges: []*WakatimeDependencyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wd, err = pager.applyCursors(wd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wd = pager.applyOrder(wd)
	nodes, err := wd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeDependencyOrderField defines the ordering field of WakatimeDependency.
type WakatimeDependencyOrderField struct {
	// Value extracts the ordering value from the given WakatimeDependency.
	Value    func(*WakatimeDependency) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimedependency.OrderOption
	toCursor func(*WakatimeDependency) Cursor
}

// WakatimeDependencyOrder defines the ordering of WakatimeDependency.
type WakatimeDependencyOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *WakatimeDependencyOrderField `json:"field"`
}

// DefaultWakatimeDependencyOrder is the default ordering of WakatimeDependency.
var DefaultWakatimeDependencyOrder = &WakatimeDependencyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeDependencyOrderField{
		Value: func(wd *WakatimeDependency) (ent.Value, error) {
			return wd.ID, nil
		},
		column: wakatimedependency.FieldID,
		toTerm: wakatimedependency.ByID,
		toCursor: func(wd *WakatimeDependency) Cursor {
			return Cursor{ID: wd.ID}
		},
	},
}

// ToEdge converts WakatimeDependency into WakatimeDependencyEdge.
func (wd *WakatimeDependency) ToEdge(order *WakatimeDependencyOrder) *WakatimeDependencyEdge {
	if order == nil {
		order = DefaultWakatimeDependencyOrder
	}
	return &WakatimeDependencyEdge{
		Node:   wd,
		Cursor: order.Field.toCursor(wd),
	}
}

// WakatimeDurationEdge is the edge representation of WakatimeDuration.
type WakatimeDurationEdge struct {
	Node   *WakatimeDuration `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// WakatimeDurationConnection is the connection containing edges to WakatimeDuration.
type WakatimeDurationConnection struct {
	Edges      []*WakatimeDurationEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *WakatimeDurationConnection) build(nodes []*WakatimeDuration, pager *wakatimedurationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeDuration
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeDuration {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeDuration {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeDurationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeDurationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeDurationPaginateOption enables pagination customization.
type WakatimeDurationPaginateOption func(*wakatimedurationPager) error

// WithWakatimeDurationOrder configures pagination ordering.
func WithWakatimeDurationOrder(order *WakatimeDurationOrder) WakatimeDurationPaginateOption {
	if order == nil {
		order = DefaultWakatimeDurationOrder
	}
	o := *order
	return func(pager *wakatimedurationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeDurationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeDurationFilter configures pagination filter.
func WithWakatimeDurationFilter(filter func(*WakatimeDurationQuery) (*WakatimeDurationQuery, error)) WakatimeDurationPaginateOption {
	return func(pager *wakatimedurationPager) error {
		if filter == nil {
			return errors.New("WakatimeDurationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimedurationPager struct {
	reverse bool
	order   *WakatimeDurationOrder
	filter  func(*WakatimeDurationQuery) (*WakatimeDurationQuery, error)
}

func newWakatimeDurationPager(opts []WakatimeDurationPaginateOption, reverse bool) (*wakatimedurationPager, error) {
	pager := &wakatimedurationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeDurationOrder
	}
	return pager, nil
}

func (p *wakatimedurationPager) applyFilter(query *WakatimeDurationQuery) (*WakatimeDurationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimedurationPager) toCursor(wd *WakatimeDuration) Cursor {
	return p.order.Field.toCursor(wd)
}

func (p *wakatimedurationPager) applyCursors(query *WakatimeDurationQuery, after, before *Cursor) (*WakatimeDurationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeDurationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimedurationPager) applyOrder(query *WakatimeDurationQuery) *WakatimeDurationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeDurationOrder.Field {
		query = query.Order(DefaultWakatimeDurationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimedurationPager) orderExpr(query *WakatimeDurationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeDurationOrder.Field {
			b.Comma().Ident(DefaultWakatimeDurationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeDuration.
func (wd *WakatimeDurationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeDurationPaginateOption,
) (*WakatimeDurationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeDurationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wd, err = pager.applyFilter(wd); err != nil {
		return nil, err
	}
	conn := &WakatimeDurationConnection{Edges: []*WakatimeDurationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wd, err = pager.applyCursors(wd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wd = pager.applyOrder(wd)
	nodes, err := wd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeDurationOrderField defines the ordering field of WakatimeDuration.
type WakatimeDurationOrderField struct {
	// Value extracts the ordering value from the given WakatimeDuration.
	Value    func(*WakatimeDuration) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimeduration.OrderOption
	toCursor func(*WakatimeDuration) Cursor
}

// WakatimeDurationOrder defines the ordering of WakatimeDuration.
type WakatimeDurationOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *WakatimeDurationOrderField `json:"field"`
}

// DefaultWakatimeDurationOrder is the default ordering of WakatimeDuration.
var DefaultWakatimeDurationOrder = &WakatimeDurationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeDurationOrderField{
		Value: func(wd *WakatimeDuration) (ent.Value, error) {
			return wd.ID, nil
		},
		column: wakatimeduration.FieldID,
		toTerm: wakatimeduration.ByID,
		toCursor: func(wd *WakatimeDuration) Cursor {
			return Cursor{ID: wd.ID}
		},
	},
}

// ToEdge converts WakatimeDuration into WakatimeDurationEdge.
func (wd *WakatimeDuration) ToEdge(order *WakatimeDurationOrder) *WakatimeDurationEdge {
	if order == nil {
		order = DefaultWakatimeDurationOrder
	}
	return &WakatimeDurationEdge{
		Node:   wd,
		Cursor: order.Field.toCursor(wd),
	}
}

// WakatimeEditorEdge is the edge representation of WakatimeEditor.
type WakatimeEditorEdge struct {
	Node   *WakatimeEditor `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// WakatimeEditorConnection is the connection containing edges to WakatimeEditor.
type WakatimeEditorConnection struct {
	Edges      []*WakatimeEditorEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *WakatimeEditorConnection) build(nodes []*WakatimeEditor, pager *wakatimeeditorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeEditor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeEditor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeEditor {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeEditorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeEditorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeEditorPaginateOption enables pagination customization.
type WakatimeEditorPaginateOption func(*wakatimeeditorPager) error

// WithWakatimeEditorOrder configures pagination ordering.
func WithWakatimeEditorOrder(order *WakatimeEditorOrder) WakatimeEditorPaginateOption {
	if order == nil {
		order = DefaultWakatimeEditorOrder
	}
	o := *order
	return func(pager *wakatimeeditorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeEditorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeEditorFilter configures pagination filter.
func WithWakatimeEditorFilter(filter func(*WakatimeEditorQuery) (*WakatimeEditorQuery, error)) WakatimeEditorPaginateOption {
	return func(pager *wakatimeeditorPager) error {
		if filter == nil {
			return errors.New("WakatimeEditorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimeeditorPager struct {
	reverse bool
	order   *WakatimeEditorOrder
	filter  func(*WakatimeEditorQuery) (*WakatimeEditorQuery, error)
}

func newWakatimeEditorPager(opts []WakatimeEditorPaginateOption, reverse bool) (*wakatimeeditorPager, error) {
	pager := &wakatimeeditorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeEditorOrder
	}
	return pager, nil
}

func (p *wakatimeeditorPager) applyFilter(query *WakatimeEditorQuery) (*WakatimeEditorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimeeditorPager) toCursor(we *WakatimeEditor) Cursor {
	return p.order.Field.toCursor(we)
}

func (p *wakatimeeditorPager) applyCursors(query *WakatimeEditorQuery, after, before *Cursor) (*WakatimeEditorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeEditorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimeeditorPager) applyOrder(query *WakatimeEditorQuery) *WakatimeEditorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeEditorOrder.Field {
		query = query.Order(DefaultWakatimeEditorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimeeditorPager) orderExpr(query *WakatimeEditorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeEditorOrder.Field {
			b.Comma().Ident(DefaultWakatimeEditorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeEditor.
func (we *WakatimeEditorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeEditorPaginateOption,
) (*WakatimeEditorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeEditorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if we, err = pager.applyFilter(we); err != nil {
		return nil, err
	}
	conn := &WakatimeEditorConnection{Edges: []*WakatimeEditorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = we.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if we, err = pager.applyCursors(we, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		we.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := we.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	we = pager.applyOrder(we)
	nodes, err := we.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeEditorOrderField defines the ordering field of WakatimeEditor.
type WakatimeEditorOrderField struct {
	// Value extracts the ordering value from the given WakatimeEditor.
	Value    func(*WakatimeEditor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimeeditor.OrderOption
	toCursor func(*WakatimeEditor) Cursor
}

// WakatimeEditorOrder defines the ordering of WakatimeEditor.
type WakatimeEditorOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *WakatimeEditorOrderField `json:"field"`
}

// DefaultWakatimeEditorOrder is the default ordering of WakatimeEditor.
var DefaultWakatimeEditorOrder = &WakatimeEditorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeEditorOrderField{
		Value: func(we *WakatimeEditor) (ent.Value, error) {
			return we.ID, nil
		},
		column: wakatimeeditor.FieldID,
		toTerm: wakatimeeditor.ByID,
		toCursor: func(we *WakatimeEditor) Cursor {
			return Cursor{ID: we.ID}
		},
	},
}

// ToEdge converts WakatimeEditor into WakatimeEditorEdge.
func (we *WakatimeEditor) ToEdge(order *WakatimeEditorOrder) *WakatimeEditorEdge {
	if order == nil {
		order = DefaultWakatimeEditorOrder
	}
	return &WakatimeEditorEdge{
		Node:   we,
		Cursor: order.Field.toCursor(we),
	}
}

// WakatimeEntityEdge is the edge representation of WakatimeEntity.
type WakatimeEntityEdge struct {
	Node   *WakatimeEntity `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// WakatimeEntityConnection is the connection containing edges to WakatimeEntity.
type WakatimeEntityConnection struct {
	Edges      []*WakatimeEntityEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *WakatimeEntityConnection) build(nodes []*WakatimeEntity, pager *wakatimeentityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeEntity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeEntity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeEntity {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeEntityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeEntityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeEntityPaginateOption enables pagination customization.
type WakatimeEntityPaginateOption func(*wakatimeentityPager) error

// WithWakatimeEntityOrder configures pagination ordering.
func WithWakatimeEntityOrder(order *WakatimeEntityOrder) WakatimeEntityPaginateOption {
	if order == nil {
		order = DefaultWakatimeEntityOrder
	}
	o := *order
	return func(pager *wakatimeentityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeEntityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeEntityFilter configures pagination filter.
func WithWakatimeEntityFilter(filter func(*WakatimeEntityQuery) (*WakatimeEntityQuery, error)) WakatimeEntityPaginateOption {
	return func(pager *wakatimeentityPager) error {
		if filter == nil {
			return errors.New("WakatimeEntityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimeentityPager struct {
	reverse bool
	order   *WakatimeEntityOrder
	filter  func(*WakatimeEntityQuery) (*WakatimeEntityQuery, error)
}

func newWakatimeEntityPager(opts []WakatimeEntityPaginateOption, reverse bool) (*wakatimeentityPager, error) {
	pager := &wakatimeentityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeEntityOrder
	}
	return pager, nil
}

func (p *wakatimeentityPager) applyFilter(query *WakatimeEntityQuery) (*WakatimeEntityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimeentityPager) toCursor(we *WakatimeEntity) Cursor {
	return p.order.Field.toCursor(we)
}

func (p *wakatimeentityPager) applyCursors(query *WakatimeEntityQuery, after, before *Cursor) (*WakatimeEntityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeEntityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimeentityPager) applyOrder(query *WakatimeEntityQuery) *WakatimeEntityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeEntityOrder.Field {
		query = query.Order(DefaultWakatimeEntityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimeentityPager) orderExpr(query *WakatimeEntityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeEntityOrder.Field {
			b.Comma().Ident(DefaultWakatimeEntityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeEntity.
func (we *WakatimeEntityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeEntityPaginateOption,
) (*WakatimeEntityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeEntityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if we, err = pager.applyFilter(we); err != nil {
		return nil, err
	}
	conn := &WakatimeEntityConnection{Edges: []*WakatimeEntityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = we.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if we, err = pager.applyCursors(we, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		we.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := we.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	we = pager.applyOrder(we)
	nodes, err := we.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeEntityOrderField defines the ordering field of WakatimeEntity.
type WakatimeEntityOrderField struct {
	// Value extracts the ordering value from the given WakatimeEntity.
	Value    func(*WakatimeEntity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimeentity.OrderOption
	toCursor func(*WakatimeEntity) Cursor
}

// WakatimeEntityOrder defines the ordering of WakatimeEntity.
type WakatimeEntityOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *WakatimeEntityOrderField `json:"field"`
}

// DefaultWakatimeEntityOrder is the default ordering of WakatimeEntity.
var DefaultWakatimeEntityOrder = &WakatimeEntityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeEntityOrderField{
		Value: func(we *WakatimeEntity) (ent.Value, error) {
			return we.ID, nil
		},
		column: wakatimeentity.FieldID,
		toTerm: wakatimeentity.ByID,
		toCursor: func(we *WakatimeEntity) Cursor {
			return Cursor{ID: we.ID}
		},
	},
}

// ToEdge converts WakatimeEntity into WakatimeEntityEdge.
func (we *WakatimeEntity) ToEdge(order *WakatimeEntityOrder) *WakatimeEntityEdge {
	if order == nil {
		order = DefaultWakatimeEntityOrder
	}
	return &WakatimeEntityEdge{
		Node:   we,
		Cursor: order.Field.toCursor(we),
	}
}

// WakatimeGrandTotalEdge is the edge representation of WakatimeGrandTotal.
type WakatimeGrandTotalEdge struct {
	Node   *WakatimeGrandTotal `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// WakatimeGrandTotalConnection is the connection containing edges to WakatimeGrandTotal.
type WakatimeGrandTotalConnection struct {
	Edges      []*WakatimeGrandTotalEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *WakatimeGrandTotalConnection) build(nodes []*WakatimeGrandTotal, pager *wakatimegrandtotalPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeGrandTotal
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeGrandTotal {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeGrandTotal {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeGrandTotalEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeGrandTotalEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeGrandTotalPaginateOption enables pagination customization.
type WakatimeGrandTotalPaginateOption func(*wakatimegrandtotalPager) error

// WithWakatimeGrandTotalOrder configures pagination ordering.
func WithWakatimeGrandTotalOrder(order *WakatimeGrandTotalOrder) WakatimeGrandTotalPaginateOption {
	if order == nil {
		order = DefaultWakatimeGrandTotalOrder
	}
	o := *order
	return func(pager *wakatimegrandtotalPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeGrandTotalOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeGrandTotalFilter configures pagination filter.
func WithWakatimeGrandTotalFilter(filter func(*WakatimeGrandTotalQuery) (*WakatimeGrandTotalQuery, error)) WakatimeGrandTotalPaginateOption {
	return func(pager *wakatimegrandtotalPager) error {
		if filter == nil {
			return errors.New("WakatimeGrandTotalQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimegrandtotalPager struct {
	reverse bool
	order   *WakatimeGrandTotalOrder
	filter  func(*WakatimeGrandTotalQuery) (*WakatimeGrandTotalQuery, error)
}

func newWakatimeGrandTotalPager(opts []WakatimeGrandTotalPaginateOption, reverse bool) (*wakatimegrandtotalPager, error) {
	pager := &wakatimegrandtotalPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeGrandTotalOrder
	}
	return pager, nil
}

func (p *wakatimegrandtotalPager) applyFilter(query *WakatimeGrandTotalQuery) (*WakatimeGrandTotalQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimegrandtotalPager) toCursor(wgt *WakatimeGrandTotal) Cursor {
	return p.order.Field.toCursor(wgt)
}

func (p *wakatimegrandtotalPager) applyCursors(query *WakatimeGrandTotalQuery, after, before *Cursor) (*WakatimeGrandTotalQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeGrandTotalOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimegrandtotalPager) applyOrder(query *WakatimeGrandTotalQuery) *WakatimeGrandTotalQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeGrandTotalOrder.Field {
		query = query.Order(DefaultWakatimeGrandTotalOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimegrandtotalPager) orderExpr(query *WakatimeGrandTotalQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeGrandTotalOrder.Field {
			b.Comma().Ident(DefaultWakatimeGrandTotalOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeGrandTotal.
func (wgt *WakatimeGrandTotalQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeGrandTotalPaginateOption,
) (*WakatimeGrandTotalConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeGrandTotalPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wgt, err = pager.applyFilter(wgt); err != nil {
		return nil, err
	}
	conn := &WakatimeGrandTotalConnection{Edges: []*WakatimeGrandTotalEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wgt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wgt, err = pager.applyCursors(wgt, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wgt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wgt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wgt = pager.applyOrder(wgt)
	nodes, err := wgt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeGrandTotalOrderField defines the ordering field of WakatimeGrandTotal.
type WakatimeGrandTotalOrderField struct {
	// Value extracts the ordering value from the given WakatimeGrandTotal.
	Value    func(*WakatimeGrandTotal) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimegrandtotal.OrderOption
	toCursor func(*WakatimeGrandTotal) Cursor
}

// WakatimeGrandTotalOrder defines the ordering of WakatimeGrandTotal.
type WakatimeGrandTotalOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *WakatimeGrandTotalOrderField `json:"field"`
}

// DefaultWakatimeGrandTotalOrder is the default ordering of WakatimeGrandTotal.
var DefaultWakatimeGrandTotalOrder = &WakatimeGrandTotalOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeGrandTotalOrderField{
		Value: func(wgt *WakatimeGrandTotal) (ent.Value, error) {
			return wgt.ID, nil
		},
		column: wakatimegrandtotal.FieldID,
		toTerm: wakatimegrandtotal.ByID,
		toCursor: func(wgt *WakatimeGrandTotal) Cursor {
			return Cursor{ID: wgt.ID}
		},
	},
}

// ToEdge converts WakatimeGrandTotal into WakatimeGrandTotalEdge.
func (wgt *WakatimeGrandTotal) ToEdge(order *WakatimeGrandTotalOrder) *WakatimeGrandTotalEdge {
	if order == nil {
		order = DefaultWakatimeGrandTotalOrder
	}
	return &WakatimeGrandTotalEdge{
		Node:   wgt,
		Cursor: order.Field.toCursor(wgt),
	}
}

// WakatimeHeartBeatEdge is the edge representation of WakatimeHeartBeat.
type WakatimeHeartBeatEdge struct {
	Node   *WakatimeHeartBeat `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// WakatimeHeartBeatConnection is the connection containing edges to WakatimeHeartBeat.
type WakatimeHeartBeatConnection struct {
	Edges      []*WakatimeHeartBeatEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *WakatimeHeartBeatConnection) build(nodes []*WakatimeHeartBeat, pager *wakatimeheartbeatPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeHeartBeat
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeHeartBeat {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeHeartBeat {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeHeartBeatEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeHeartBeatEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeHeartBeatPaginateOption enables pagination customization.
type WakatimeHeartBeatPaginateOption func(*wakatimeheartbeatPager) error

// WithWakatimeHeartBeatOrder configures pagination ordering.
func WithWakatimeHeartBeatOrder(order *WakatimeHeartBeatOrder) WakatimeHeartBeatPaginateOption {
	if order == nil {
		order = DefaultWakatimeHeartBeatOrder
	}
	o := *order
	return func(pager *wakatimeheartbeatPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeHeartBeatOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeHeartBeatFilter configures pagination filter.
func WithWakatimeHeartBeatFilter(filter func(*WakatimeHeartBeatQuery) (*WakatimeHeartBeatQuery, error)) WakatimeHeartBeatPaginateOption {
	return func(pager *wakatimeheartbeatPager) error {
		if filter == nil {
			return errors.New("WakatimeHeartBeatQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimeheartbeatPager struct {
	reverse bool
	order   *WakatimeHeartBeatOrder
	filter  func(*WakatimeHeartBeatQuery) (*WakatimeHeartBeatQuery, error)
}

func newWakatimeHeartBeatPager(opts []WakatimeHeartBeatPaginateOption, reverse bool) (*wakatimeheartbeatPager, error) {
	pager := &wakatimeheartbeatPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeHeartBeatOrder
	}
	return pager, nil
}

func (p *wakatimeheartbeatPager) applyFilter(query *WakatimeHeartBeatQuery) (*WakatimeHeartBeatQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimeheartbeatPager) toCursor(whb *WakatimeHeartBeat) Cursor {
	return p.order.Field.toCursor(whb)
}

func (p *wakatimeheartbeatPager) applyCursors(query *WakatimeHeartBeatQuery, after, before *Cursor) (*WakatimeHeartBeatQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeHeartBeatOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimeheartbeatPager) applyOrder(query *WakatimeHeartBeatQuery) *WakatimeHeartBeatQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeHeartBeatOrder.Field {
		query = query.Order(DefaultWakatimeHeartBeatOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimeheartbeatPager) orderExpr(query *WakatimeHeartBeatQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeHeartBeatOrder.Field {
			b.Comma().Ident(DefaultWakatimeHeartBeatOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeHeartBeat.
func (whb *WakatimeHeartBeatQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeHeartBeatPaginateOption,
) (*WakatimeHeartBeatConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeHeartBeatPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if whb, err = pager.applyFilter(whb); err != nil {
		return nil, err
	}
	conn := &WakatimeHeartBeatConnection{Edges: []*WakatimeHeartBeatEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = whb.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if whb, err = pager.applyCursors(whb, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		whb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := whb.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	whb = pager.applyOrder(whb)
	nodes, err := whb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeHeartBeatOrderField defines the ordering field of WakatimeHeartBeat.
type WakatimeHeartBeatOrderField struct {
	// Value extracts the ordering value from the given WakatimeHeartBeat.
	Value    func(*WakatimeHeartBeat) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimeheartbeat.OrderOption
	toCursor func(*WakatimeHeartBeat) Cursor
}

// WakatimeHeartBeatOrder defines the ordering of WakatimeHeartBeat.
type WakatimeHeartBeatOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *WakatimeHeartBeatOrderField `json:"field"`
}

// DefaultWakatimeHeartBeatOrder is the default ordering of WakatimeHeartBeat.
var DefaultWakatimeHeartBeatOrder = &WakatimeHeartBeatOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeHeartBeatOrderField{
		Value: func(whb *WakatimeHeartBeat) (ent.Value, error) {
			return whb.ID, nil
		},
		column: wakatimeheartbeat.FieldID,
		toTerm: wakatimeheartbeat.ByID,
		toCursor: func(whb *WakatimeHeartBeat) Cursor {
			return Cursor{ID: whb.ID}
		},
	},
}

// ToEdge converts WakatimeHeartBeat into WakatimeHeartBeatEdge.
func (whb *WakatimeHeartBeat) ToEdge(order *WakatimeHeartBeatOrder) *WakatimeHeartBeatEdge {
	if order == nil {
		order = DefaultWakatimeHeartBeatOrder
	}
	return &WakatimeHeartBeatEdge{
		Node:   whb,
		Cursor: order.Field.toCursor(whb),
	}
}

// WakatimeLanguageEdge is the edge representation of WakatimeLanguage.
type WakatimeLanguageEdge struct {
	Node   *WakatimeLanguage `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// WakatimeLanguageConnection is the connection containing edges to WakatimeLanguage.
type WakatimeLanguageConnection struct {
	Edges      []*WakatimeLanguageEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *WakatimeLanguageConnection) build(nodes []*WakatimeLanguage, pager *wakatimelanguagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeLanguage
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeLanguage {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeLanguage {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeLanguageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeLanguageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeLanguagePaginateOption enables pagination customization.
type WakatimeLanguagePaginateOption func(*wakatimelanguagePager) error

// WithWakatimeLanguageOrder configures pagination ordering.
func WithWakatimeLanguageOrder(order *WakatimeLanguageOrder) WakatimeLanguagePaginateOption {
	if order == nil {
		order = DefaultWakatimeLanguageOrder
	}
	o := *order
	return func(pager *wakatimelanguagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeLanguageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeLanguageFilter configures pagination filter.
func WithWakatimeLanguageFilter(filter func(*WakatimeLanguageQuery) (*WakatimeLanguageQuery, error)) WakatimeLanguagePaginateOption {
	return func(pager *wakatimelanguagePager) error {
		if filter == nil {
			return errors.New("WakatimeLanguageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimelanguagePager struct {
	reverse bool
	order   *WakatimeLanguageOrder
	filter  func(*WakatimeLanguageQuery) (*WakatimeLanguageQuery, error)
}

func newWakatimeLanguagePager(opts []WakatimeLanguagePaginateOption, reverse bool) (*wakatimelanguagePager, error) {
	pager := &wakatimelanguagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeLanguageOrder
	}
	return pager, nil
}

func (p *wakatimelanguagePager) applyFilter(query *WakatimeLanguageQuery) (*WakatimeLanguageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimelanguagePager) toCursor(wl *WakatimeLanguage) Cursor {
	return p.order.Field.toCursor(wl)
}

func (p *wakatimelanguagePager) applyCursors(query *WakatimeLanguageQuery, after, before *Cursor) (*WakatimeLanguageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeLanguageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimelanguagePager) applyOrder(query *WakatimeLanguageQuery) *WakatimeLanguageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeLanguageOrder.Field {
		query = query.Order(DefaultWakatimeLanguageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimelanguagePager) orderExpr(query *WakatimeLanguageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeLanguageOrder.Field {
			b.Comma().Ident(DefaultWakatimeLanguageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeLanguage.
func (wl *WakatimeLanguageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeLanguagePaginateOption,
) (*WakatimeLanguageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeLanguagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wl, err = pager.applyFilter(wl); err != nil {
		return nil, err
	}
	conn := &WakatimeLanguageConnection{Edges: []*WakatimeLanguageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wl.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wl, err = pager.applyCursors(wl, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wl.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wl = pager.applyOrder(wl)
	nodes, err := wl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeLanguageOrderField defines the ordering field of WakatimeLanguage.
type WakatimeLanguageOrderField struct {
	// Value extracts the ordering value from the given WakatimeLanguage.
	Value    func(*WakatimeLanguage) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimelanguage.OrderOption
	toCursor func(*WakatimeLanguage) Cursor
}

// WakatimeLanguageOrder defines the ordering of WakatimeLanguage.
type WakatimeLanguageOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *WakatimeLanguageOrderField `json:"field"`
}

// DefaultWakatimeLanguageOrder is the default ordering of WakatimeLanguage.
var DefaultWakatimeLanguageOrder = &WakatimeLanguageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeLanguageOrderField{
		Value: func(wl *WakatimeLanguage) (ent.Value, error) {
			return wl.ID, nil
		},
		column: wakatimelanguage.FieldID,
		toTerm: wakatimelanguage.ByID,
		toCursor: func(wl *WakatimeLanguage) Cursor {
			return Cursor{ID: wl.ID}
		},
	},
}

// ToEdge converts WakatimeLanguage into WakatimeLanguageEdge.
func (wl *WakatimeLanguage) ToEdge(order *WakatimeLanguageOrder) *WakatimeLanguageEdge {
	if order == nil {
		order = DefaultWakatimeLanguageOrder
	}
	return &WakatimeLanguageEdge{
		Node:   wl,
		Cursor: order.Field.toCursor(wl),
	}
}

// WakatimeProjectEdge is the edge representation of WakatimeProject.
type WakatimeProjectEdge struct {
	Node   *WakatimeProject `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// WakatimeProjectConnection is the connection containing edges to WakatimeProject.
type WakatimeProjectConnection struct {
	Edges      []*WakatimeProjectEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *WakatimeProjectConnection) build(nodes []*WakatimeProject, pager *wakatimeprojectPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeProject
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeProject {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeProject {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeProjectPaginateOption enables pagination customization.
type WakatimeProjectPaginateOption func(*wakatimeprojectPager) error

// WithWakatimeProjectOrder configures pagination ordering.
func WithWakatimeProjectOrder(order *WakatimeProjectOrder) WakatimeProjectPaginateOption {
	if order == nil {
		order = DefaultWakatimeProjectOrder
	}
	o := *order
	return func(pager *wakatimeprojectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeProjectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeProjectFilter configures pagination filter.
func WithWakatimeProjectFilter(filter func(*WakatimeProjectQuery) (*WakatimeProjectQuery, error)) WakatimeProjectPaginateOption {
	return func(pager *wakatimeprojectPager) error {
		if filter == nil {
			return errors.New("WakatimeProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimeprojectPager struct {
	reverse bool
	order   *WakatimeProjectOrder
	filter  func(*WakatimeProjectQuery) (*WakatimeProjectQuery, error)
}

func newWakatimeProjectPager(opts []WakatimeProjectPaginateOption, reverse bool) (*wakatimeprojectPager, error) {
	pager := &wakatimeprojectPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeProjectOrder
	}
	return pager, nil
}

func (p *wakatimeprojectPager) applyFilter(query *WakatimeProjectQuery) (*WakatimeProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimeprojectPager) toCursor(wp *WakatimeProject) Cursor {
	return p.order.Field.toCursor(wp)
}

func (p *wakatimeprojectPager) applyCursors(query *WakatimeProjectQuery, after, before *Cursor) (*WakatimeProjectQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeProjectOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimeprojectPager) applyOrder(query *WakatimeProjectQuery) *WakatimeProjectQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeProjectOrder.Field {
		query = query.Order(DefaultWakatimeProjectOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimeprojectPager) orderExpr(query *WakatimeProjectQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeProjectOrder.Field {
			b.Comma().Ident(DefaultWakatimeProjectOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeProject.
func (wp *WakatimeProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeProjectPaginateOption,
) (*WakatimeProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeProjectPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wp, err = pager.applyFilter(wp); err != nil {
		return nil, err
	}
	conn := &WakatimeProjectConnection{Edges: []*WakatimeProjectEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wp, err = pager.applyCursors(wp, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wp = pager.applyOrder(wp)
	nodes, err := wp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeProjectOrderField defines the ordering field of WakatimeProject.
type WakatimeProjectOrderField struct {
	// Value extracts the ordering value from the given WakatimeProject.
	Value    func(*WakatimeProject) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimeproject.OrderOption
	toCursor func(*WakatimeProject) Cursor
}

// WakatimeProjectOrder defines the ordering of WakatimeProject.
type WakatimeProjectOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *WakatimeProjectOrderField `json:"field"`
}

// DefaultWakatimeProjectOrder is the default ordering of WakatimeProject.
var DefaultWakatimeProjectOrder = &WakatimeProjectOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeProjectOrderField{
		Value: func(wp *WakatimeProject) (ent.Value, error) {
			return wp.ID, nil
		},
		column: wakatimeproject.FieldID,
		toTerm: wakatimeproject.ByID,
		toCursor: func(wp *WakatimeProject) Cursor {
			return Cursor{ID: wp.ID}
		},
	},
}

// ToEdge converts WakatimeProject into WakatimeProjectEdge.
func (wp *WakatimeProject) ToEdge(order *WakatimeProjectOrder) *WakatimeProjectEdge {
	if order == nil {
		order = DefaultWakatimeProjectOrder
	}
	return &WakatimeProjectEdge{
		Node:   wp,
		Cursor: order.Field.toCursor(wp),
	}
}

// WakatimeProjectDurationEdge is the edge representation of WakatimeProjectDuration.
type WakatimeProjectDurationEdge struct {
	Node   *WakatimeProjectDuration `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// WakatimeProjectDurationConnection is the connection containing edges to WakatimeProjectDuration.
type WakatimeProjectDurationConnection struct {
	Edges      []*WakatimeProjectDurationEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *WakatimeProjectDurationConnection) build(nodes []*WakatimeProjectDuration, pager *wakatimeprojectdurationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeProjectDuration
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeProjectDuration {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeProjectDuration {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeProjectDurationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeProjectDurationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeProjectDurationPaginateOption enables pagination customization.
type WakatimeProjectDurationPaginateOption func(*wakatimeprojectdurationPager) error

// WithWakatimeProjectDurationOrder configures pagination ordering.
func WithWakatimeProjectDurationOrder(order *WakatimeProjectDurationOrder) WakatimeProjectDurationPaginateOption {
	if order == nil {
		order = DefaultWakatimeProjectDurationOrder
	}
	o := *order
	return func(pager *wakatimeprojectdurationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeProjectDurationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeProjectDurationFilter configures pagination filter.
func WithWakatimeProjectDurationFilter(filter func(*WakatimeProjectDurationQuery) (*WakatimeProjectDurationQuery, error)) WakatimeProjectDurationPaginateOption {
	return func(pager *wakatimeprojectdurationPager) error {
		if filter == nil {
			return errors.New("WakatimeProjectDurationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimeprojectdurationPager struct {
	reverse bool
	order   *WakatimeProjectDurationOrder
	filter  func(*WakatimeProjectDurationQuery) (*WakatimeProjectDurationQuery, error)
}

func newWakatimeProjectDurationPager(opts []WakatimeProjectDurationPaginateOption, reverse bool) (*wakatimeprojectdurationPager, error) {
	pager := &wakatimeprojectdurationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeProjectDurationOrder
	}
	return pager, nil
}

func (p *wakatimeprojectdurationPager) applyFilter(query *WakatimeProjectDurationQuery) (*WakatimeProjectDurationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimeprojectdurationPager) toCursor(wpd *WakatimeProjectDuration) Cursor {
	return p.order.Field.toCursor(wpd)
}

func (p *wakatimeprojectdurationPager) applyCursors(query *WakatimeProjectDurationQuery, after, before *Cursor) (*WakatimeProjectDurationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeProjectDurationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimeprojectdurationPager) applyOrder(query *WakatimeProjectDurationQuery) *WakatimeProjectDurationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeProjectDurationOrder.Field {
		query = query.Order(DefaultWakatimeProjectDurationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimeprojectdurationPager) orderExpr(query *WakatimeProjectDurationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeProjectDurationOrder.Field {
			b.Comma().Ident(DefaultWakatimeProjectDurationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeProjectDuration.
func (wpd *WakatimeProjectDurationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeProjectDurationPaginateOption,
) (*WakatimeProjectDurationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeProjectDurationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wpd, err = pager.applyFilter(wpd); err != nil {
		return nil, err
	}
	conn := &WakatimeProjectDurationConnection{Edges: []*WakatimeProjectDurationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wpd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wpd, err = pager.applyCursors(wpd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wpd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wpd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wpd = pager.applyOrder(wpd)
	nodes, err := wpd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeProjectDurationOrderField defines the ordering field of WakatimeProjectDuration.
type WakatimeProjectDurationOrderField struct {
	// Value extracts the ordering value from the given WakatimeProjectDuration.
	Value    func(*WakatimeProjectDuration) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimeprojectduration.OrderOption
	toCursor func(*WakatimeProjectDuration) Cursor
}

// WakatimeProjectDurationOrder defines the ordering of WakatimeProjectDuration.
type WakatimeProjectDurationOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *WakatimeProjectDurationOrderField `json:"field"`
}

// DefaultWakatimeProjectDurationOrder is the default ordering of WakatimeProjectDuration.
var DefaultWakatimeProjectDurationOrder = &WakatimeProjectDurationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeProjectDurationOrderField{
		Value: func(wpd *WakatimeProjectDuration) (ent.Value, error) {
			return wpd.ID, nil
		},
		column: wakatimeprojectduration.FieldID,
		toTerm: wakatimeprojectduration.ByID,
		toCursor: func(wpd *WakatimeProjectDuration) Cursor {
			return Cursor{ID: wpd.ID}
		},
	},
}

// ToEdge converts WakatimeProjectDuration into WakatimeProjectDurationEdge.
func (wpd *WakatimeProjectDuration) ToEdge(order *WakatimeProjectDurationOrder) *WakatimeProjectDurationEdge {
	if order == nil {
		order = DefaultWakatimeProjectDurationOrder
	}
	return &WakatimeProjectDurationEdge{
		Node:   wpd,
		Cursor: order.Field.toCursor(wpd),
	}
}

// WakatimeProjectInfoEdge is the edge representation of WakatimeProjectInfo.
type WakatimeProjectInfoEdge struct {
	Node   *WakatimeProjectInfo `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// WakatimeProjectInfoConnection is the connection containing edges to WakatimeProjectInfo.
type WakatimeProjectInfoConnection struct {
	Edges      []*WakatimeProjectInfoEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *WakatimeProjectInfoConnection) build(nodes []*WakatimeProjectInfo, pager *wakatimeprojectinfoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeProjectInfo
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeProjectInfo {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeProjectInfo {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeProjectInfoEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeProjectInfoEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeProjectInfoPaginateOption enables pagination customization.
type WakatimeProjectInfoPaginateOption func(*wakatimeprojectinfoPager) error

// WithWakatimeProjectInfoOrder configures pagination ordering.
func WithWakatimeProjectInfoOrder(order *WakatimeProjectInfoOrder) WakatimeProjectInfoPaginateOption {
	if order == nil {
		order = DefaultWakatimeProjectInfoOrder
	}
	o := *order
	return func(pager *wakatimeprojectinfoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeProjectInfoOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeProjectInfoFilter configures pagination filter.
func WithWakatimeProjectInfoFilter(filter func(*WakatimeProjectInfoQuery) (*WakatimeProjectInfoQuery, error)) WakatimeProjectInfoPaginateOption {
	return func(pager *wakatimeprojectinfoPager) error {
		if filter == nil {
			return errors.New("WakatimeProjectInfoQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimeprojectinfoPager struct {
	reverse bool
	order   *WakatimeProjectInfoOrder
	filter  func(*WakatimeProjectInfoQuery) (*WakatimeProjectInfoQuery, error)
}

func newWakatimeProjectInfoPager(opts []WakatimeProjectInfoPaginateOption, reverse bool) (*wakatimeprojectinfoPager, error) {
	pager := &wakatimeprojectinfoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeProjectInfoOrder
	}
	return pager, nil
}

func (p *wakatimeprojectinfoPager) applyFilter(query *WakatimeProjectInfoQuery) (*WakatimeProjectInfoQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimeprojectinfoPager) toCursor(wpi *WakatimeProjectInfo) Cursor {
	return p.order.Field.toCursor(wpi)
}

func (p *wakatimeprojectinfoPager) applyCursors(query *WakatimeProjectInfoQuery, after, before *Cursor) (*WakatimeProjectInfoQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeProjectInfoOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimeprojectinfoPager) applyOrder(query *WakatimeProjectInfoQuery) *WakatimeProjectInfoQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeProjectInfoOrder.Field {
		query = query.Order(DefaultWakatimeProjectInfoOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimeprojectinfoPager) orderExpr(query *WakatimeProjectInfoQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeProjectInfoOrder.Field {
			b.Comma().Ident(DefaultWakatimeProjectInfoOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeProjectInfo.
func (wpi *WakatimeProjectInfoQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeProjectInfoPaginateOption,
) (*WakatimeProjectInfoConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeProjectInfoPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wpi, err = pager.applyFilter(wpi); err != nil {
		return nil, err
	}
	conn := &WakatimeProjectInfoConnection{Edges: []*WakatimeProjectInfoEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wpi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wpi, err = pager.applyCursors(wpi, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wpi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wpi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wpi = pager.applyOrder(wpi)
	nodes, err := wpi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeProjectInfoOrderField defines the ordering field of WakatimeProjectInfo.
type WakatimeProjectInfoOrderField struct {
	// Value extracts the ordering value from the given WakatimeProjectInfo.
	Value    func(*WakatimeProjectInfo) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimeprojectinfo.OrderOption
	toCursor func(*WakatimeProjectInfo) Cursor
}

// WakatimeProjectInfoOrder defines the ordering of WakatimeProjectInfo.
type WakatimeProjectInfoOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *WakatimeProjectInfoOrderField `json:"field"`
}

// DefaultWakatimeProjectInfoOrder is the default ordering of WakatimeProjectInfo.
var DefaultWakatimeProjectInfoOrder = &WakatimeProjectInfoOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeProjectInfoOrderField{
		Value: func(wpi *WakatimeProjectInfo) (ent.Value, error) {
			return wpi.ID, nil
		},
		column: wakatimeprojectinfo.FieldID,
		toTerm: wakatimeprojectinfo.ByID,
		toCursor: func(wpi *WakatimeProjectInfo) Cursor {
			return Cursor{ID: wpi.ID}
		},
	},
}

// ToEdge converts WakatimeProjectInfo into WakatimeProjectInfoEdge.
func (wpi *WakatimeProjectInfo) ToEdge(order *WakatimeProjectInfoOrder) *WakatimeProjectInfoEdge {
	if order == nil {
		order = DefaultWakatimeProjectInfoOrder
	}
	return &WakatimeProjectInfoEdge{
		Node:   wpi,
		Cursor: order.Field.toCursor(wpi),
	}
}

// WakatimeSystemEdge is the edge representation of WakatimeSystem.
type WakatimeSystemEdge struct {
	Node   *WakatimeSystem `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// WakatimeSystemConnection is the connection containing edges to WakatimeSystem.
type WakatimeSystemConnection struct {
	Edges      []*WakatimeSystemEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *WakatimeSystemConnection) build(nodes []*WakatimeSystem, pager *wakatimesystemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WakatimeSystem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WakatimeSystem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WakatimeSystem {
			return nodes[i]
		}
	}
	c.Edges = make([]*WakatimeSystemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WakatimeSystemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WakatimeSystemPaginateOption enables pagination customization.
type WakatimeSystemPaginateOption func(*wakatimesystemPager) error

// WithWakatimeSystemOrder configures pagination ordering.
func WithWakatimeSystemOrder(order *WakatimeSystemOrder) WakatimeSystemPaginateOption {
	if order == nil {
		order = DefaultWakatimeSystemOrder
	}
	o := *order
	return func(pager *wakatimesystemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWakatimeSystemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWakatimeSystemFilter configures pagination filter.
func WithWakatimeSystemFilter(filter func(*WakatimeSystemQuery) (*WakatimeSystemQuery, error)) WakatimeSystemPaginateOption {
	return func(pager *wakatimesystemPager) error {
		if filter == nil {
			return errors.New("WakatimeSystemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type wakatimesystemPager struct {
	reverse bool
	order   *WakatimeSystemOrder
	filter  func(*WakatimeSystemQuery) (*WakatimeSystemQuery, error)
}

func newWakatimeSystemPager(opts []WakatimeSystemPaginateOption, reverse bool) (*wakatimesystemPager, error) {
	pager := &wakatimesystemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWakatimeSystemOrder
	}
	return pager, nil
}

func (p *wakatimesystemPager) applyFilter(query *WakatimeSystemQuery) (*WakatimeSystemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *wakatimesystemPager) toCursor(ws *WakatimeSystem) Cursor {
	return p.order.Field.toCursor(ws)
}

func (p *wakatimesystemPager) applyCursors(query *WakatimeSystemQuery, after, before *Cursor) (*WakatimeSystemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWakatimeSystemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *wakatimesystemPager) applyOrder(query *WakatimeSystemQuery) *WakatimeSystemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWakatimeSystemOrder.Field {
		query = query.Order(DefaultWakatimeSystemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *wakatimesystemPager) orderExpr(query *WakatimeSystemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWakatimeSystemOrder.Field {
			b.Comma().Ident(DefaultWakatimeSystemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WakatimeSystem.
func (ws *WakatimeSystemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WakatimeSystemPaginateOption,
) (*WakatimeSystemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWakatimeSystemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ws, err = pager.applyFilter(ws); err != nil {
		return nil, err
	}
	conn := &WakatimeSystemConnection{Edges: []*WakatimeSystemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ws.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ws, err = pager.applyCursors(ws, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ws.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ws.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ws = pager.applyOrder(ws)
	nodes, err := ws.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WakatimeSystemOrderField defines the ordering field of WakatimeSystem.
type WakatimeSystemOrderField struct {
	// Value extracts the ordering value from the given WakatimeSystem.
	Value    func(*WakatimeSystem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wakatimesystem.OrderOption
	toCursor func(*WakatimeSystem) Cursor
}

// WakatimeSystemOrder defines the ordering of WakatimeSystem.
type WakatimeSystemOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *WakatimeSystemOrderField `json:"field"`
}

// DefaultWakatimeSystemOrder is the default ordering of WakatimeSystem.
var DefaultWakatimeSystemOrder = &WakatimeSystemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WakatimeSystemOrderField{
		Value: func(ws *WakatimeSystem) (ent.Value, error) {
			return ws.ID, nil
		},
		column: wakatimesystem.FieldID,
		toTerm: wakatimesystem.ByID,
		toCursor: func(ws *WakatimeSystem) Cursor {
			return Cursor{ID: ws.ID}
		},
	},
}

// ToEdge converts WakatimeSystem into WakatimeSystemEdge.
func (ws *WakatimeSystem) ToEdge(order *WakatimeSystemOrder) *WakatimeSystemEdge {
	if order == nil {
		order = DefaultWakatimeSystemOrder
	}
	return &WakatimeSystemEdge{
		Node:   ws,
		Cursor: order.Field.toCursor(ws),
	}
}
