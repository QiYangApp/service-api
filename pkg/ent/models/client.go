// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"ent/models/migrate"

	"ent/models/accesstoken"
	"ent/models/accounts"
	"ent/models/memberrolerelatedpermission"
	"ent/models/permissiongroup"
	"ent/models/permissionrelatedrouter"
	"ent/models/router"
	"ent/models/source"
	"ent/models/sourcedata"
	"ent/models/twofactor"
	"ent/models/user"
	"ent/models/userauthsource"
	"ent/models/userrelatedrole"
	"ent/models/userrole"
	"ent/models/wakatime"
	"ent/models/wakatimecategory"
	"ent/models/wakatimedependency"
	"ent/models/wakatimeduration"
	"ent/models/wakatimeeditor"
	"ent/models/wakatimeentity"
	"ent/models/wakatimegrandtotal"
	"ent/models/wakatimeheartbeat"
	"ent/models/wakatimelanguage"
	"ent/models/wakatimeproject"
	"ent/models/wakatimeprojectduration"
	"ent/models/wakatimeprojectinfo"
	"ent/models/wakatimesystem"
	"ent/models/webauthncredential"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccessToken is the client for interacting with the AccessToken builders.
	AccessToken *AccessTokenClient
	// Accounts is the client for interacting with the Accounts builders.
	Accounts *AccountsClient
	// MemberRoleRelatedPermission is the client for interacting with the MemberRoleRelatedPermission builders.
	MemberRoleRelatedPermission *MemberRoleRelatedPermissionClient
	// PermissionGroup is the client for interacting with the PermissionGroup builders.
	PermissionGroup *PermissionGroupClient
	// PermissionRelatedRouter is the client for interacting with the PermissionRelatedRouter builders.
	PermissionRelatedRouter *PermissionRelatedRouterClient
	// Router is the client for interacting with the Router builders.
	Router *RouterClient
	// Source is the client for interacting with the Source builders.
	Source *SourceClient
	// SourceData is the client for interacting with the SourceData builders.
	SourceData *SourceDataClient
	// TwoFactor is the client for interacting with the TwoFactor builders.
	TwoFactor *TwoFactorClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserAuthSource is the client for interacting with the UserAuthSource builders.
	UserAuthSource *UserAuthSourceClient
	// UserRelatedRole is the client for interacting with the UserRelatedRole builders.
	UserRelatedRole *UserRelatedRoleClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
	// Wakatime is the client for interacting with the Wakatime builders.
	Wakatime *WakatimeClient
	// WakatimeCategory is the client for interacting with the WakatimeCategory builders.
	WakatimeCategory *WakatimeCategoryClient
	// WakatimeDependency is the client for interacting with the WakatimeDependency builders.
	WakatimeDependency *WakatimeDependencyClient
	// WakatimeDuration is the client for interacting with the WakatimeDuration builders.
	WakatimeDuration *WakatimeDurationClient
	// WakatimeEditor is the client for interacting with the WakatimeEditor builders.
	WakatimeEditor *WakatimeEditorClient
	// WakatimeEntity is the client for interacting with the WakatimeEntity builders.
	WakatimeEntity *WakatimeEntityClient
	// WakatimeGrandTotal is the client for interacting with the WakatimeGrandTotal builders.
	WakatimeGrandTotal *WakatimeGrandTotalClient
	// WakatimeHeartBeat is the client for interacting with the WakatimeHeartBeat builders.
	WakatimeHeartBeat *WakatimeHeartBeatClient
	// WakatimeLanguage is the client for interacting with the WakatimeLanguage builders.
	WakatimeLanguage *WakatimeLanguageClient
	// WakatimeProject is the client for interacting with the WakatimeProject builders.
	WakatimeProject *WakatimeProjectClient
	// WakatimeProjectDuration is the client for interacting with the WakatimeProjectDuration builders.
	WakatimeProjectDuration *WakatimeProjectDurationClient
	// WakatimeProjectInfo is the client for interacting with the WakatimeProjectInfo builders.
	WakatimeProjectInfo *WakatimeProjectInfoClient
	// WakatimeSystem is the client for interacting with the WakatimeSystem builders.
	WakatimeSystem *WakatimeSystemClient
	// WebAuthnCredential is the client for interacting with the WebAuthnCredential builders.
	WebAuthnCredential *WebAuthnCredentialClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccessToken = NewAccessTokenClient(c.config)
	c.Accounts = NewAccountsClient(c.config)
	c.MemberRoleRelatedPermission = NewMemberRoleRelatedPermissionClient(c.config)
	c.PermissionGroup = NewPermissionGroupClient(c.config)
	c.PermissionRelatedRouter = NewPermissionRelatedRouterClient(c.config)
	c.Router = NewRouterClient(c.config)
	c.Source = NewSourceClient(c.config)
	c.SourceData = NewSourceDataClient(c.config)
	c.TwoFactor = NewTwoFactorClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserAuthSource = NewUserAuthSourceClient(c.config)
	c.UserRelatedRole = NewUserRelatedRoleClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
	c.Wakatime = NewWakatimeClient(c.config)
	c.WakatimeCategory = NewWakatimeCategoryClient(c.config)
	c.WakatimeDependency = NewWakatimeDependencyClient(c.config)
	c.WakatimeDuration = NewWakatimeDurationClient(c.config)
	c.WakatimeEditor = NewWakatimeEditorClient(c.config)
	c.WakatimeEntity = NewWakatimeEntityClient(c.config)
	c.WakatimeGrandTotal = NewWakatimeGrandTotalClient(c.config)
	c.WakatimeHeartBeat = NewWakatimeHeartBeatClient(c.config)
	c.WakatimeLanguage = NewWakatimeLanguageClient(c.config)
	c.WakatimeProject = NewWakatimeProjectClient(c.config)
	c.WakatimeProjectDuration = NewWakatimeProjectDurationClient(c.config)
	c.WakatimeProjectInfo = NewWakatimeProjectInfoClient(c.config)
	c.WakatimeSystem = NewWakatimeSystemClient(c.config)
	c.WebAuthnCredential = NewWebAuthnCredentialClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("models: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("models: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                         ctx,
		config:                      cfg,
		AccessToken:                 NewAccessTokenClient(cfg),
		Accounts:                    NewAccountsClient(cfg),
		MemberRoleRelatedPermission: NewMemberRoleRelatedPermissionClient(cfg),
		PermissionGroup:             NewPermissionGroupClient(cfg),
		PermissionRelatedRouter:     NewPermissionRelatedRouterClient(cfg),
		Router:                      NewRouterClient(cfg),
		Source:                      NewSourceClient(cfg),
		SourceData:                  NewSourceDataClient(cfg),
		TwoFactor:                   NewTwoFactorClient(cfg),
		User:                        NewUserClient(cfg),
		UserAuthSource:              NewUserAuthSourceClient(cfg),
		UserRelatedRole:             NewUserRelatedRoleClient(cfg),
		UserRole:                    NewUserRoleClient(cfg),
		Wakatime:                    NewWakatimeClient(cfg),
		WakatimeCategory:            NewWakatimeCategoryClient(cfg),
		WakatimeDependency:          NewWakatimeDependencyClient(cfg),
		WakatimeDuration:            NewWakatimeDurationClient(cfg),
		WakatimeEditor:              NewWakatimeEditorClient(cfg),
		WakatimeEntity:              NewWakatimeEntityClient(cfg),
		WakatimeGrandTotal:          NewWakatimeGrandTotalClient(cfg),
		WakatimeHeartBeat:           NewWakatimeHeartBeatClient(cfg),
		WakatimeLanguage:            NewWakatimeLanguageClient(cfg),
		WakatimeProject:             NewWakatimeProjectClient(cfg),
		WakatimeProjectDuration:     NewWakatimeProjectDurationClient(cfg),
		WakatimeProjectInfo:         NewWakatimeProjectInfoClient(cfg),
		WakatimeSystem:              NewWakatimeSystemClient(cfg),
		WebAuthnCredential:          NewWebAuthnCredentialClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                         ctx,
		config:                      cfg,
		AccessToken:                 NewAccessTokenClient(cfg),
		Accounts:                    NewAccountsClient(cfg),
		MemberRoleRelatedPermission: NewMemberRoleRelatedPermissionClient(cfg),
		PermissionGroup:             NewPermissionGroupClient(cfg),
		PermissionRelatedRouter:     NewPermissionRelatedRouterClient(cfg),
		Router:                      NewRouterClient(cfg),
		Source:                      NewSourceClient(cfg),
		SourceData:                  NewSourceDataClient(cfg),
		TwoFactor:                   NewTwoFactorClient(cfg),
		User:                        NewUserClient(cfg),
		UserAuthSource:              NewUserAuthSourceClient(cfg),
		UserRelatedRole:             NewUserRelatedRoleClient(cfg),
		UserRole:                    NewUserRoleClient(cfg),
		Wakatime:                    NewWakatimeClient(cfg),
		WakatimeCategory:            NewWakatimeCategoryClient(cfg),
		WakatimeDependency:          NewWakatimeDependencyClient(cfg),
		WakatimeDuration:            NewWakatimeDurationClient(cfg),
		WakatimeEditor:              NewWakatimeEditorClient(cfg),
		WakatimeEntity:              NewWakatimeEntityClient(cfg),
		WakatimeGrandTotal:          NewWakatimeGrandTotalClient(cfg),
		WakatimeHeartBeat:           NewWakatimeHeartBeatClient(cfg),
		WakatimeLanguage:            NewWakatimeLanguageClient(cfg),
		WakatimeProject:             NewWakatimeProjectClient(cfg),
		WakatimeProjectDuration:     NewWakatimeProjectDurationClient(cfg),
		WakatimeProjectInfo:         NewWakatimeProjectInfoClient(cfg),
		WakatimeSystem:              NewWakatimeSystemClient(cfg),
		WebAuthnCredential:          NewWebAuthnCredentialClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccessToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccessToken, c.Accounts, c.MemberRoleRelatedPermission, c.PermissionGroup,
		c.PermissionRelatedRouter, c.Router, c.Source, c.SourceData, c.TwoFactor,
		c.User, c.UserAuthSource, c.UserRelatedRole, c.UserRole, c.Wakatime,
		c.WakatimeCategory, c.WakatimeDependency, c.WakatimeDuration, c.WakatimeEditor,
		c.WakatimeEntity, c.WakatimeGrandTotal, c.WakatimeHeartBeat,
		c.WakatimeLanguage, c.WakatimeProject, c.WakatimeProjectDuration,
		c.WakatimeProjectInfo, c.WakatimeSystem, c.WebAuthnCredential,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccessToken, c.Accounts, c.MemberRoleRelatedPermission, c.PermissionGroup,
		c.PermissionRelatedRouter, c.Router, c.Source, c.SourceData, c.TwoFactor,
		c.User, c.UserAuthSource, c.UserRelatedRole, c.UserRole, c.Wakatime,
		c.WakatimeCategory, c.WakatimeDependency, c.WakatimeDuration, c.WakatimeEditor,
		c.WakatimeEntity, c.WakatimeGrandTotal, c.WakatimeHeartBeat,
		c.WakatimeLanguage, c.WakatimeProject, c.WakatimeProjectDuration,
		c.WakatimeProjectInfo, c.WakatimeSystem, c.WebAuthnCredential,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccessTokenMutation:
		return c.AccessToken.mutate(ctx, m)
	case *AccountsMutation:
		return c.Accounts.mutate(ctx, m)
	case *MemberRoleRelatedPermissionMutation:
		return c.MemberRoleRelatedPermission.mutate(ctx, m)
	case *PermissionGroupMutation:
		return c.PermissionGroup.mutate(ctx, m)
	case *PermissionRelatedRouterMutation:
		return c.PermissionRelatedRouter.mutate(ctx, m)
	case *RouterMutation:
		return c.Router.mutate(ctx, m)
	case *SourceMutation:
		return c.Source.mutate(ctx, m)
	case *SourceDataMutation:
		return c.SourceData.mutate(ctx, m)
	case *TwoFactorMutation:
		return c.TwoFactor.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserAuthSourceMutation:
		return c.UserAuthSource.mutate(ctx, m)
	case *UserRelatedRoleMutation:
		return c.UserRelatedRole.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	case *WakatimeMutation:
		return c.Wakatime.mutate(ctx, m)
	case *WakatimeCategoryMutation:
		return c.WakatimeCategory.mutate(ctx, m)
	case *WakatimeDependencyMutation:
		return c.WakatimeDependency.mutate(ctx, m)
	case *WakatimeDurationMutation:
		return c.WakatimeDuration.mutate(ctx, m)
	case *WakatimeEditorMutation:
		return c.WakatimeEditor.mutate(ctx, m)
	case *WakatimeEntityMutation:
		return c.WakatimeEntity.mutate(ctx, m)
	case *WakatimeGrandTotalMutation:
		return c.WakatimeGrandTotal.mutate(ctx, m)
	case *WakatimeHeartBeatMutation:
		return c.WakatimeHeartBeat.mutate(ctx, m)
	case *WakatimeLanguageMutation:
		return c.WakatimeLanguage.mutate(ctx, m)
	case *WakatimeProjectMutation:
		return c.WakatimeProject.mutate(ctx, m)
	case *WakatimeProjectDurationMutation:
		return c.WakatimeProjectDuration.mutate(ctx, m)
	case *WakatimeProjectInfoMutation:
		return c.WakatimeProjectInfo.mutate(ctx, m)
	case *WakatimeSystemMutation:
		return c.WakatimeSystem.mutate(ctx, m)
	case *WebAuthnCredentialMutation:
		return c.WebAuthnCredential.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("models: unknown mutation type %T", m)
	}
}

// AccessTokenClient is a client for the AccessToken schema.
type AccessTokenClient struct {
	config
}

// NewAccessTokenClient returns a client for the AccessToken from the given config.
func NewAccessTokenClient(c config) *AccessTokenClient {
	return &AccessTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accesstoken.Hooks(f(g(h())))`.
func (c *AccessTokenClient) Use(hooks ...Hook) {
	c.hooks.AccessToken = append(c.hooks.AccessToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accesstoken.Intercept(f(g(h())))`.
func (c *AccessTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccessToken = append(c.inters.AccessToken, interceptors...)
}

// Create returns a builder for creating a AccessToken entity.
func (c *AccessTokenClient) Create() *AccessTokenCreate {
	mutation := newAccessTokenMutation(c.config, OpCreate)
	return &AccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccessToken entities.
func (c *AccessTokenClient) CreateBulk(builders ...*AccessTokenCreate) *AccessTokenCreateBulk {
	return &AccessTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccessTokenClient) MapCreateBulk(slice any, setFunc func(*AccessTokenCreate, int)) *AccessTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccessTokenCreateBulk{err: fmt.Errorf("calling to AccessTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccessTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccessTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccessToken.
func (c *AccessTokenClient) Update() *AccessTokenUpdate {
	mutation := newAccessTokenMutation(c.config, OpUpdate)
	return &AccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccessTokenClient) UpdateOne(at *AccessToken) *AccessTokenUpdateOne {
	mutation := newAccessTokenMutation(c.config, OpUpdateOne, withAccessToken(at))
	return &AccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccessTokenClient) UpdateOneID(id int64) *AccessTokenUpdateOne {
	mutation := newAccessTokenMutation(c.config, OpUpdateOne, withAccessTokenID(id))
	return &AccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccessToken.
func (c *AccessTokenClient) Delete() *AccessTokenDelete {
	mutation := newAccessTokenMutation(c.config, OpDelete)
	return &AccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccessTokenClient) DeleteOne(at *AccessToken) *AccessTokenDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccessTokenClient) DeleteOneID(id int64) *AccessTokenDeleteOne {
	builder := c.Delete().Where(accesstoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccessTokenDeleteOne{builder}
}

// Query returns a query builder for AccessToken.
func (c *AccessTokenClient) Query() *AccessTokenQuery {
	return &AccessTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccessToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AccessToken entity by its id.
func (c *AccessTokenClient) Get(ctx context.Context, id int64) (*AccessToken, error) {
	return c.Query().Where(accesstoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccessTokenClient) GetX(ctx context.Context, id int64) *AccessToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AccessTokenClient) Hooks() []Hook {
	return c.hooks.AccessToken
}

// Interceptors returns the client interceptors.
func (c *AccessTokenClient) Interceptors() []Interceptor {
	return c.inters.AccessToken
}

func (c *AccessTokenClient) mutate(ctx context.Context, m *AccessTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown AccessToken mutation op: %q", m.Op())
	}
}

// AccountsClient is a client for the Accounts schema.
type AccountsClient struct {
	config
}

// NewAccountsClient returns a client for the Accounts from the given config.
func NewAccountsClient(c config) *AccountsClient {
	return &AccountsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accounts.Hooks(f(g(h())))`.
func (c *AccountsClient) Use(hooks ...Hook) {
	c.hooks.Accounts = append(c.hooks.Accounts, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accounts.Intercept(f(g(h())))`.
func (c *AccountsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Accounts = append(c.inters.Accounts, interceptors...)
}

// Create returns a builder for creating a Accounts entity.
func (c *AccountsClient) Create() *AccountsCreate {
	mutation := newAccountsMutation(c.config, OpCreate)
	return &AccountsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Accounts entities.
func (c *AccountsClient) CreateBulk(builders ...*AccountsCreate) *AccountsCreateBulk {
	return &AccountsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountsClient) MapCreateBulk(slice any, setFunc func(*AccountsCreate, int)) *AccountsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountsCreateBulk{err: fmt.Errorf("calling to AccountsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Accounts.
func (c *AccountsClient) Update() *AccountsUpdate {
	mutation := newAccountsMutation(c.config, OpUpdate)
	return &AccountsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountsClient) UpdateOne(a *Accounts) *AccountsUpdateOne {
	mutation := newAccountsMutation(c.config, OpUpdateOne, withAccounts(a))
	return &AccountsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountsClient) UpdateOneID(id int64) *AccountsUpdateOne {
	mutation := newAccountsMutation(c.config, OpUpdateOne, withAccountsID(id))
	return &AccountsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Accounts.
func (c *AccountsClient) Delete() *AccountsDelete {
	mutation := newAccountsMutation(c.config, OpDelete)
	return &AccountsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountsClient) DeleteOne(a *Accounts) *AccountsDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountsClient) DeleteOneID(id int64) *AccountsDeleteOne {
	builder := c.Delete().Where(accounts.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountsDeleteOne{builder}
}

// Query returns a query builder for Accounts.
func (c *AccountsClient) Query() *AccountsQuery {
	return &AccountsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccounts},
		inters: c.Interceptors(),
	}
}

// Get returns a Accounts entity by its id.
func (c *AccountsClient) Get(ctx context.Context, id int64) (*Accounts, error) {
	return c.Query().Where(accounts.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountsClient) GetX(ctx context.Context, id int64) *Accounts {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AccountsClient) Hooks() []Hook {
	return c.hooks.Accounts
}

// Interceptors returns the client interceptors.
func (c *AccountsClient) Interceptors() []Interceptor {
	return c.inters.Accounts
}

func (c *AccountsClient) mutate(ctx context.Context, m *AccountsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Accounts mutation op: %q", m.Op())
	}
}

// MemberRoleRelatedPermissionClient is a client for the MemberRoleRelatedPermission schema.
type MemberRoleRelatedPermissionClient struct {
	config
}

// NewMemberRoleRelatedPermissionClient returns a client for the MemberRoleRelatedPermission from the given config.
func NewMemberRoleRelatedPermissionClient(c config) *MemberRoleRelatedPermissionClient {
	return &MemberRoleRelatedPermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memberrolerelatedpermission.Hooks(f(g(h())))`.
func (c *MemberRoleRelatedPermissionClient) Use(hooks ...Hook) {
	c.hooks.MemberRoleRelatedPermission = append(c.hooks.MemberRoleRelatedPermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memberrolerelatedpermission.Intercept(f(g(h())))`.
func (c *MemberRoleRelatedPermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemberRoleRelatedPermission = append(c.inters.MemberRoleRelatedPermission, interceptors...)
}

// Create returns a builder for creating a MemberRoleRelatedPermission entity.
func (c *MemberRoleRelatedPermissionClient) Create() *MemberRoleRelatedPermissionCreate {
	mutation := newMemberRoleRelatedPermissionMutation(c.config, OpCreate)
	return &MemberRoleRelatedPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemberRoleRelatedPermission entities.
func (c *MemberRoleRelatedPermissionClient) CreateBulk(builders ...*MemberRoleRelatedPermissionCreate) *MemberRoleRelatedPermissionCreateBulk {
	return &MemberRoleRelatedPermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemberRoleRelatedPermissionClient) MapCreateBulk(slice any, setFunc func(*MemberRoleRelatedPermissionCreate, int)) *MemberRoleRelatedPermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemberRoleRelatedPermissionCreateBulk{err: fmt.Errorf("calling to MemberRoleRelatedPermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemberRoleRelatedPermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemberRoleRelatedPermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemberRoleRelatedPermission.
func (c *MemberRoleRelatedPermissionClient) Update() *MemberRoleRelatedPermissionUpdate {
	mutation := newMemberRoleRelatedPermissionMutation(c.config, OpUpdate)
	return &MemberRoleRelatedPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemberRoleRelatedPermissionClient) UpdateOne(mrrp *MemberRoleRelatedPermission) *MemberRoleRelatedPermissionUpdateOne {
	mutation := newMemberRoleRelatedPermissionMutation(c.config, OpUpdateOne, withMemberRoleRelatedPermission(mrrp))
	return &MemberRoleRelatedPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemberRoleRelatedPermissionClient) UpdateOneID(id int64) *MemberRoleRelatedPermissionUpdateOne {
	mutation := newMemberRoleRelatedPermissionMutation(c.config, OpUpdateOne, withMemberRoleRelatedPermissionID(id))
	return &MemberRoleRelatedPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemberRoleRelatedPermission.
func (c *MemberRoleRelatedPermissionClient) Delete() *MemberRoleRelatedPermissionDelete {
	mutation := newMemberRoleRelatedPermissionMutation(c.config, OpDelete)
	return &MemberRoleRelatedPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemberRoleRelatedPermissionClient) DeleteOne(mrrp *MemberRoleRelatedPermission) *MemberRoleRelatedPermissionDeleteOne {
	return c.DeleteOneID(mrrp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemberRoleRelatedPermissionClient) DeleteOneID(id int64) *MemberRoleRelatedPermissionDeleteOne {
	builder := c.Delete().Where(memberrolerelatedpermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemberRoleRelatedPermissionDeleteOne{builder}
}

// Query returns a query builder for MemberRoleRelatedPermission.
func (c *MemberRoleRelatedPermissionClient) Query() *MemberRoleRelatedPermissionQuery {
	return &MemberRoleRelatedPermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemberRoleRelatedPermission},
		inters: c.Interceptors(),
	}
}

// Get returns a MemberRoleRelatedPermission entity by its id.
func (c *MemberRoleRelatedPermissionClient) Get(ctx context.Context, id int64) (*MemberRoleRelatedPermission, error) {
	return c.Query().Where(memberrolerelatedpermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemberRoleRelatedPermissionClient) GetX(ctx context.Context, id int64) *MemberRoleRelatedPermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MemberRoleRelatedPermissionClient) Hooks() []Hook {
	return c.hooks.MemberRoleRelatedPermission
}

// Interceptors returns the client interceptors.
func (c *MemberRoleRelatedPermissionClient) Interceptors() []Interceptor {
	return c.inters.MemberRoleRelatedPermission
}

func (c *MemberRoleRelatedPermissionClient) mutate(ctx context.Context, m *MemberRoleRelatedPermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemberRoleRelatedPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemberRoleRelatedPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemberRoleRelatedPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemberRoleRelatedPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown MemberRoleRelatedPermission mutation op: %q", m.Op())
	}
}

// PermissionGroupClient is a client for the PermissionGroup schema.
type PermissionGroupClient struct {
	config
}

// NewPermissionGroupClient returns a client for the PermissionGroup from the given config.
func NewPermissionGroupClient(c config) *PermissionGroupClient {
	return &PermissionGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permissiongroup.Hooks(f(g(h())))`.
func (c *PermissionGroupClient) Use(hooks ...Hook) {
	c.hooks.PermissionGroup = append(c.hooks.PermissionGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permissiongroup.Intercept(f(g(h())))`.
func (c *PermissionGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.PermissionGroup = append(c.inters.PermissionGroup, interceptors...)
}

// Create returns a builder for creating a PermissionGroup entity.
func (c *PermissionGroupClient) Create() *PermissionGroupCreate {
	mutation := newPermissionGroupMutation(c.config, OpCreate)
	return &PermissionGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PermissionGroup entities.
func (c *PermissionGroupClient) CreateBulk(builders ...*PermissionGroupCreate) *PermissionGroupCreateBulk {
	return &PermissionGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionGroupClient) MapCreateBulk(slice any, setFunc func(*PermissionGroupCreate, int)) *PermissionGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionGroupCreateBulk{err: fmt.Errorf("calling to PermissionGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PermissionGroup.
func (c *PermissionGroupClient) Update() *PermissionGroupUpdate {
	mutation := newPermissionGroupMutation(c.config, OpUpdate)
	return &PermissionGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionGroupClient) UpdateOne(pg *PermissionGroup) *PermissionGroupUpdateOne {
	mutation := newPermissionGroupMutation(c.config, OpUpdateOne, withPermissionGroup(pg))
	return &PermissionGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionGroupClient) UpdateOneID(id int64) *PermissionGroupUpdateOne {
	mutation := newPermissionGroupMutation(c.config, OpUpdateOne, withPermissionGroupID(id))
	return &PermissionGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PermissionGroup.
func (c *PermissionGroupClient) Delete() *PermissionGroupDelete {
	mutation := newPermissionGroupMutation(c.config, OpDelete)
	return &PermissionGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionGroupClient) DeleteOne(pg *PermissionGroup) *PermissionGroupDeleteOne {
	return c.DeleteOneID(pg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionGroupClient) DeleteOneID(id int64) *PermissionGroupDeleteOne {
	builder := c.Delete().Where(permissiongroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionGroupDeleteOne{builder}
}

// Query returns a query builder for PermissionGroup.
func (c *PermissionGroupClient) Query() *PermissionGroupQuery {
	return &PermissionGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermissionGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a PermissionGroup entity by its id.
func (c *PermissionGroupClient) Get(ctx context.Context, id int64) (*PermissionGroup, error) {
	return c.Query().Where(permissiongroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionGroupClient) GetX(ctx context.Context, id int64) *PermissionGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PermissionGroupClient) Hooks() []Hook {
	return c.hooks.PermissionGroup
}

// Interceptors returns the client interceptors.
func (c *PermissionGroupClient) Interceptors() []Interceptor {
	return c.inters.PermissionGroup
}

func (c *PermissionGroupClient) mutate(ctx context.Context, m *PermissionGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown PermissionGroup mutation op: %q", m.Op())
	}
}

// PermissionRelatedRouterClient is a client for the PermissionRelatedRouter schema.
type PermissionRelatedRouterClient struct {
	config
}

// NewPermissionRelatedRouterClient returns a client for the PermissionRelatedRouter from the given config.
func NewPermissionRelatedRouterClient(c config) *PermissionRelatedRouterClient {
	return &PermissionRelatedRouterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permissionrelatedrouter.Hooks(f(g(h())))`.
func (c *PermissionRelatedRouterClient) Use(hooks ...Hook) {
	c.hooks.PermissionRelatedRouter = append(c.hooks.PermissionRelatedRouter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permissionrelatedrouter.Intercept(f(g(h())))`.
func (c *PermissionRelatedRouterClient) Intercept(interceptors ...Interceptor) {
	c.inters.PermissionRelatedRouter = append(c.inters.PermissionRelatedRouter, interceptors...)
}

// Create returns a builder for creating a PermissionRelatedRouter entity.
func (c *PermissionRelatedRouterClient) Create() *PermissionRelatedRouterCreate {
	mutation := newPermissionRelatedRouterMutation(c.config, OpCreate)
	return &PermissionRelatedRouterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PermissionRelatedRouter entities.
func (c *PermissionRelatedRouterClient) CreateBulk(builders ...*PermissionRelatedRouterCreate) *PermissionRelatedRouterCreateBulk {
	return &PermissionRelatedRouterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionRelatedRouterClient) MapCreateBulk(slice any, setFunc func(*PermissionRelatedRouterCreate, int)) *PermissionRelatedRouterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionRelatedRouterCreateBulk{err: fmt.Errorf("calling to PermissionRelatedRouterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionRelatedRouterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionRelatedRouterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PermissionRelatedRouter.
func (c *PermissionRelatedRouterClient) Update() *PermissionRelatedRouterUpdate {
	mutation := newPermissionRelatedRouterMutation(c.config, OpUpdate)
	return &PermissionRelatedRouterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionRelatedRouterClient) UpdateOne(prr *PermissionRelatedRouter) *PermissionRelatedRouterUpdateOne {
	mutation := newPermissionRelatedRouterMutation(c.config, OpUpdateOne, withPermissionRelatedRouter(prr))
	return &PermissionRelatedRouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionRelatedRouterClient) UpdateOneID(id int64) *PermissionRelatedRouterUpdateOne {
	mutation := newPermissionRelatedRouterMutation(c.config, OpUpdateOne, withPermissionRelatedRouterID(id))
	return &PermissionRelatedRouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PermissionRelatedRouter.
func (c *PermissionRelatedRouterClient) Delete() *PermissionRelatedRouterDelete {
	mutation := newPermissionRelatedRouterMutation(c.config, OpDelete)
	return &PermissionRelatedRouterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionRelatedRouterClient) DeleteOne(prr *PermissionRelatedRouter) *PermissionRelatedRouterDeleteOne {
	return c.DeleteOneID(prr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionRelatedRouterClient) DeleteOneID(id int64) *PermissionRelatedRouterDeleteOne {
	builder := c.Delete().Where(permissionrelatedrouter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionRelatedRouterDeleteOne{builder}
}

// Query returns a query builder for PermissionRelatedRouter.
func (c *PermissionRelatedRouterClient) Query() *PermissionRelatedRouterQuery {
	return &PermissionRelatedRouterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermissionRelatedRouter},
		inters: c.Interceptors(),
	}
}

// Get returns a PermissionRelatedRouter entity by its id.
func (c *PermissionRelatedRouterClient) Get(ctx context.Context, id int64) (*PermissionRelatedRouter, error) {
	return c.Query().Where(permissionrelatedrouter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionRelatedRouterClient) GetX(ctx context.Context, id int64) *PermissionRelatedRouter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PermissionRelatedRouterClient) Hooks() []Hook {
	return c.hooks.PermissionRelatedRouter
}

// Interceptors returns the client interceptors.
func (c *PermissionRelatedRouterClient) Interceptors() []Interceptor {
	return c.inters.PermissionRelatedRouter
}

func (c *PermissionRelatedRouterClient) mutate(ctx context.Context, m *PermissionRelatedRouterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionRelatedRouterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionRelatedRouterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionRelatedRouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionRelatedRouterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown PermissionRelatedRouter mutation op: %q", m.Op())
	}
}

// RouterClient is a client for the Router schema.
type RouterClient struct {
	config
}

// NewRouterClient returns a client for the Router from the given config.
func NewRouterClient(c config) *RouterClient {
	return &RouterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `router.Hooks(f(g(h())))`.
func (c *RouterClient) Use(hooks ...Hook) {
	c.hooks.Router = append(c.hooks.Router, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `router.Intercept(f(g(h())))`.
func (c *RouterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Router = append(c.inters.Router, interceptors...)
}

// Create returns a builder for creating a Router entity.
func (c *RouterClient) Create() *RouterCreate {
	mutation := newRouterMutation(c.config, OpCreate)
	return &RouterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Router entities.
func (c *RouterClient) CreateBulk(builders ...*RouterCreate) *RouterCreateBulk {
	return &RouterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouterClient) MapCreateBulk(slice any, setFunc func(*RouterCreate, int)) *RouterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouterCreateBulk{err: fmt.Errorf("calling to RouterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Router.
func (c *RouterClient) Update() *RouterUpdate {
	mutation := newRouterMutation(c.config, OpUpdate)
	return &RouterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouterClient) UpdateOne(r *Router) *RouterUpdateOne {
	mutation := newRouterMutation(c.config, OpUpdateOne, withRouter(r))
	return &RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouterClient) UpdateOneID(id int64) *RouterUpdateOne {
	mutation := newRouterMutation(c.config, OpUpdateOne, withRouterID(id))
	return &RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Router.
func (c *RouterClient) Delete() *RouterDelete {
	mutation := newRouterMutation(c.config, OpDelete)
	return &RouterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouterClient) DeleteOne(r *Router) *RouterDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouterClient) DeleteOneID(id int64) *RouterDeleteOne {
	builder := c.Delete().Where(router.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouterDeleteOne{builder}
}

// Query returns a query builder for Router.
func (c *RouterClient) Query() *RouterQuery {
	return &RouterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRouter},
		inters: c.Interceptors(),
	}
}

// Get returns a Router entity by its id.
func (c *RouterClient) Get(ctx context.Context, id int64) (*Router, error) {
	return c.Query().Where(router.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouterClient) GetX(ctx context.Context, id int64) *Router {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RouterClient) Hooks() []Hook {
	return c.hooks.Router
}

// Interceptors returns the client interceptors.
func (c *RouterClient) Interceptors() []Interceptor {
	return c.inters.Router
}

func (c *RouterClient) mutate(ctx context.Context, m *RouterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Router mutation op: %q", m.Op())
	}
}

// SourceClient is a client for the Source schema.
type SourceClient struct {
	config
}

// NewSourceClient returns a client for the Source from the given config.
func NewSourceClient(c config) *SourceClient {
	return &SourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `source.Hooks(f(g(h())))`.
func (c *SourceClient) Use(hooks ...Hook) {
	c.hooks.Source = append(c.hooks.Source, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `source.Intercept(f(g(h())))`.
func (c *SourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Source = append(c.inters.Source, interceptors...)
}

// Create returns a builder for creating a Source entity.
func (c *SourceClient) Create() *SourceCreate {
	mutation := newSourceMutation(c.config, OpCreate)
	return &SourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Source entities.
func (c *SourceClient) CreateBulk(builders ...*SourceCreate) *SourceCreateBulk {
	return &SourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceClient) MapCreateBulk(slice any, setFunc func(*SourceCreate, int)) *SourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceCreateBulk{err: fmt.Errorf("calling to SourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Source.
func (c *SourceClient) Update() *SourceUpdate {
	mutation := newSourceMutation(c.config, OpUpdate)
	return &SourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceClient) UpdateOne(s *Source) *SourceUpdateOne {
	mutation := newSourceMutation(c.config, OpUpdateOne, withSource(s))
	return &SourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceClient) UpdateOneID(id int64) *SourceUpdateOne {
	mutation := newSourceMutation(c.config, OpUpdateOne, withSourceID(id))
	return &SourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Source.
func (c *SourceClient) Delete() *SourceDelete {
	mutation := newSourceMutation(c.config, OpDelete)
	return &SourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceClient) DeleteOne(s *Source) *SourceDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceClient) DeleteOneID(id int64) *SourceDeleteOne {
	builder := c.Delete().Where(source.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceDeleteOne{builder}
}

// Query returns a query builder for Source.
func (c *SourceClient) Query() *SourceQuery {
	return &SourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSource},
		inters: c.Interceptors(),
	}
}

// Get returns a Source entity by its id.
func (c *SourceClient) Get(ctx context.Context, id int64) (*Source, error) {
	return c.Query().Where(source.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceClient) GetX(ctx context.Context, id int64) *Source {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SourceClient) Hooks() []Hook {
	return c.hooks.Source
}

// Interceptors returns the client interceptors.
func (c *SourceClient) Interceptors() []Interceptor {
	return c.inters.Source
}

func (c *SourceClient) mutate(ctx context.Context, m *SourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Source mutation op: %q", m.Op())
	}
}

// SourceDataClient is a client for the SourceData schema.
type SourceDataClient struct {
	config
}

// NewSourceDataClient returns a client for the SourceData from the given config.
func NewSourceDataClient(c config) *SourceDataClient {
	return &SourceDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sourcedata.Hooks(f(g(h())))`.
func (c *SourceDataClient) Use(hooks ...Hook) {
	c.hooks.SourceData = append(c.hooks.SourceData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sourcedata.Intercept(f(g(h())))`.
func (c *SourceDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.SourceData = append(c.inters.SourceData, interceptors...)
}

// Create returns a builder for creating a SourceData entity.
func (c *SourceDataClient) Create() *SourceDataCreate {
	mutation := newSourceDataMutation(c.config, OpCreate)
	return &SourceDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SourceData entities.
func (c *SourceDataClient) CreateBulk(builders ...*SourceDataCreate) *SourceDataCreateBulk {
	return &SourceDataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SourceDataClient) MapCreateBulk(slice any, setFunc func(*SourceDataCreate, int)) *SourceDataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SourceDataCreateBulk{err: fmt.Errorf("calling to SourceDataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SourceDataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SourceDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SourceData.
func (c *SourceDataClient) Update() *SourceDataUpdate {
	mutation := newSourceDataMutation(c.config, OpUpdate)
	return &SourceDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SourceDataClient) UpdateOne(sd *SourceData) *SourceDataUpdateOne {
	mutation := newSourceDataMutation(c.config, OpUpdateOne, withSourceData(sd))
	return &SourceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SourceDataClient) UpdateOneID(id int64) *SourceDataUpdateOne {
	mutation := newSourceDataMutation(c.config, OpUpdateOne, withSourceDataID(id))
	return &SourceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SourceData.
func (c *SourceDataClient) Delete() *SourceDataDelete {
	mutation := newSourceDataMutation(c.config, OpDelete)
	return &SourceDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SourceDataClient) DeleteOne(sd *SourceData) *SourceDataDeleteOne {
	return c.DeleteOneID(sd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SourceDataClient) DeleteOneID(id int64) *SourceDataDeleteOne {
	builder := c.Delete().Where(sourcedata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SourceDataDeleteOne{builder}
}

// Query returns a query builder for SourceData.
func (c *SourceDataClient) Query() *SourceDataQuery {
	return &SourceDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSourceData},
		inters: c.Interceptors(),
	}
}

// Get returns a SourceData entity by its id.
func (c *SourceDataClient) Get(ctx context.Context, id int64) (*SourceData, error) {
	return c.Query().Where(sourcedata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SourceDataClient) GetX(ctx context.Context, id int64) *SourceData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SourceDataClient) Hooks() []Hook {
	return c.hooks.SourceData
}

// Interceptors returns the client interceptors.
func (c *SourceDataClient) Interceptors() []Interceptor {
	return c.inters.SourceData
}

func (c *SourceDataClient) mutate(ctx context.Context, m *SourceDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SourceDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SourceDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SourceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SourceDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown SourceData mutation op: %q", m.Op())
	}
}

// TwoFactorClient is a client for the TwoFactor schema.
type TwoFactorClient struct {
	config
}

// NewTwoFactorClient returns a client for the TwoFactor from the given config.
func NewTwoFactorClient(c config) *TwoFactorClient {
	return &TwoFactorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `twofactor.Hooks(f(g(h())))`.
func (c *TwoFactorClient) Use(hooks ...Hook) {
	c.hooks.TwoFactor = append(c.hooks.TwoFactor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `twofactor.Intercept(f(g(h())))`.
func (c *TwoFactorClient) Intercept(interceptors ...Interceptor) {
	c.inters.TwoFactor = append(c.inters.TwoFactor, interceptors...)
}

// Create returns a builder for creating a TwoFactor entity.
func (c *TwoFactorClient) Create() *TwoFactorCreate {
	mutation := newTwoFactorMutation(c.config, OpCreate)
	return &TwoFactorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TwoFactor entities.
func (c *TwoFactorClient) CreateBulk(builders ...*TwoFactorCreate) *TwoFactorCreateBulk {
	return &TwoFactorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TwoFactorClient) MapCreateBulk(slice any, setFunc func(*TwoFactorCreate, int)) *TwoFactorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TwoFactorCreateBulk{err: fmt.Errorf("calling to TwoFactorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TwoFactorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TwoFactorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TwoFactor.
func (c *TwoFactorClient) Update() *TwoFactorUpdate {
	mutation := newTwoFactorMutation(c.config, OpUpdate)
	return &TwoFactorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TwoFactorClient) UpdateOne(tf *TwoFactor) *TwoFactorUpdateOne {
	mutation := newTwoFactorMutation(c.config, OpUpdateOne, withTwoFactor(tf))
	return &TwoFactorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TwoFactorClient) UpdateOneID(id int64) *TwoFactorUpdateOne {
	mutation := newTwoFactorMutation(c.config, OpUpdateOne, withTwoFactorID(id))
	return &TwoFactorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TwoFactor.
func (c *TwoFactorClient) Delete() *TwoFactorDelete {
	mutation := newTwoFactorMutation(c.config, OpDelete)
	return &TwoFactorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TwoFactorClient) DeleteOne(tf *TwoFactor) *TwoFactorDeleteOne {
	return c.DeleteOneID(tf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TwoFactorClient) DeleteOneID(id int64) *TwoFactorDeleteOne {
	builder := c.Delete().Where(twofactor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TwoFactorDeleteOne{builder}
}

// Query returns a query builder for TwoFactor.
func (c *TwoFactorClient) Query() *TwoFactorQuery {
	return &TwoFactorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTwoFactor},
		inters: c.Interceptors(),
	}
}

// Get returns a TwoFactor entity by its id.
func (c *TwoFactorClient) Get(ctx context.Context, id int64) (*TwoFactor, error) {
	return c.Query().Where(twofactor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TwoFactorClient) GetX(ctx context.Context, id int64) *TwoFactor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TwoFactorClient) Hooks() []Hook {
	return c.hooks.TwoFactor
}

// Interceptors returns the client interceptors.
func (c *TwoFactorClient) Interceptors() []Interceptor {
	return c.inters.TwoFactor
}

func (c *TwoFactorClient) mutate(ctx context.Context, m *TwoFactorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TwoFactorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TwoFactorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TwoFactorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TwoFactorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown TwoFactor mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown User mutation op: %q", m.Op())
	}
}

// UserAuthSourceClient is a client for the UserAuthSource schema.
type UserAuthSourceClient struct {
	config
}

// NewUserAuthSourceClient returns a client for the UserAuthSource from the given config.
func NewUserAuthSourceClient(c config) *UserAuthSourceClient {
	return &UserAuthSourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userauthsource.Hooks(f(g(h())))`.
func (c *UserAuthSourceClient) Use(hooks ...Hook) {
	c.hooks.UserAuthSource = append(c.hooks.UserAuthSource, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userauthsource.Intercept(f(g(h())))`.
func (c *UserAuthSourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserAuthSource = append(c.inters.UserAuthSource, interceptors...)
}

// Create returns a builder for creating a UserAuthSource entity.
func (c *UserAuthSourceClient) Create() *UserAuthSourceCreate {
	mutation := newUserAuthSourceMutation(c.config, OpCreate)
	return &UserAuthSourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserAuthSource entities.
func (c *UserAuthSourceClient) CreateBulk(builders ...*UserAuthSourceCreate) *UserAuthSourceCreateBulk {
	return &UserAuthSourceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserAuthSourceClient) MapCreateBulk(slice any, setFunc func(*UserAuthSourceCreate, int)) *UserAuthSourceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserAuthSourceCreateBulk{err: fmt.Errorf("calling to UserAuthSourceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserAuthSourceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserAuthSourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserAuthSource.
func (c *UserAuthSourceClient) Update() *UserAuthSourceUpdate {
	mutation := newUserAuthSourceMutation(c.config, OpUpdate)
	return &UserAuthSourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserAuthSourceClient) UpdateOne(uas *UserAuthSource) *UserAuthSourceUpdateOne {
	mutation := newUserAuthSourceMutation(c.config, OpUpdateOne, withUserAuthSource(uas))
	return &UserAuthSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserAuthSourceClient) UpdateOneID(id int64) *UserAuthSourceUpdateOne {
	mutation := newUserAuthSourceMutation(c.config, OpUpdateOne, withUserAuthSourceID(id))
	return &UserAuthSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserAuthSource.
func (c *UserAuthSourceClient) Delete() *UserAuthSourceDelete {
	mutation := newUserAuthSourceMutation(c.config, OpDelete)
	return &UserAuthSourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserAuthSourceClient) DeleteOne(uas *UserAuthSource) *UserAuthSourceDeleteOne {
	return c.DeleteOneID(uas.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserAuthSourceClient) DeleteOneID(id int64) *UserAuthSourceDeleteOne {
	builder := c.Delete().Where(userauthsource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserAuthSourceDeleteOne{builder}
}

// Query returns a query builder for UserAuthSource.
func (c *UserAuthSourceClient) Query() *UserAuthSourceQuery {
	return &UserAuthSourceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserAuthSource},
		inters: c.Interceptors(),
	}
}

// Get returns a UserAuthSource entity by its id.
func (c *UserAuthSourceClient) Get(ctx context.Context, id int64) (*UserAuthSource, error) {
	return c.Query().Where(userauthsource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserAuthSourceClient) GetX(ctx context.Context, id int64) *UserAuthSource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserAuthSourceClient) Hooks() []Hook {
	return c.hooks.UserAuthSource
}

// Interceptors returns the client interceptors.
func (c *UserAuthSourceClient) Interceptors() []Interceptor {
	return c.inters.UserAuthSource
}

func (c *UserAuthSourceClient) mutate(ctx context.Context, m *UserAuthSourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserAuthSourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserAuthSourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserAuthSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserAuthSourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown UserAuthSource mutation op: %q", m.Op())
	}
}

// UserRelatedRoleClient is a client for the UserRelatedRole schema.
type UserRelatedRoleClient struct {
	config
}

// NewUserRelatedRoleClient returns a client for the UserRelatedRole from the given config.
func NewUserRelatedRoleClient(c config) *UserRelatedRoleClient {
	return &UserRelatedRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrelatedrole.Hooks(f(g(h())))`.
func (c *UserRelatedRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRelatedRole = append(c.hooks.UserRelatedRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrelatedrole.Intercept(f(g(h())))`.
func (c *UserRelatedRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRelatedRole = append(c.inters.UserRelatedRole, interceptors...)
}

// Create returns a builder for creating a UserRelatedRole entity.
func (c *UserRelatedRoleClient) Create() *UserRelatedRoleCreate {
	mutation := newUserRelatedRoleMutation(c.config, OpCreate)
	return &UserRelatedRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRelatedRole entities.
func (c *UserRelatedRoleClient) CreateBulk(builders ...*UserRelatedRoleCreate) *UserRelatedRoleCreateBulk {
	return &UserRelatedRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRelatedRoleClient) MapCreateBulk(slice any, setFunc func(*UserRelatedRoleCreate, int)) *UserRelatedRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRelatedRoleCreateBulk{err: fmt.Errorf("calling to UserRelatedRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRelatedRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRelatedRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRelatedRole.
func (c *UserRelatedRoleClient) Update() *UserRelatedRoleUpdate {
	mutation := newUserRelatedRoleMutation(c.config, OpUpdate)
	return &UserRelatedRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRelatedRoleClient) UpdateOne(urr *UserRelatedRole) *UserRelatedRoleUpdateOne {
	mutation := newUserRelatedRoleMutation(c.config, OpUpdateOne, withUserRelatedRole(urr))
	return &UserRelatedRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRelatedRoleClient) UpdateOneID(id int64) *UserRelatedRoleUpdateOne {
	mutation := newUserRelatedRoleMutation(c.config, OpUpdateOne, withUserRelatedRoleID(id))
	return &UserRelatedRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRelatedRole.
func (c *UserRelatedRoleClient) Delete() *UserRelatedRoleDelete {
	mutation := newUserRelatedRoleMutation(c.config, OpDelete)
	return &UserRelatedRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRelatedRoleClient) DeleteOne(urr *UserRelatedRole) *UserRelatedRoleDeleteOne {
	return c.DeleteOneID(urr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRelatedRoleClient) DeleteOneID(id int64) *UserRelatedRoleDeleteOne {
	builder := c.Delete().Where(userrelatedrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRelatedRoleDeleteOne{builder}
}

// Query returns a query builder for UserRelatedRole.
func (c *UserRelatedRoleClient) Query() *UserRelatedRoleQuery {
	return &UserRelatedRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRelatedRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRelatedRole entity by its id.
func (c *UserRelatedRoleClient) Get(ctx context.Context, id int64) (*UserRelatedRole, error) {
	return c.Query().Where(userrelatedrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRelatedRoleClient) GetX(ctx context.Context, id int64) *UserRelatedRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserRelatedRoleClient) Hooks() []Hook {
	return c.hooks.UserRelatedRole
}

// Interceptors returns the client interceptors.
func (c *UserRelatedRoleClient) Interceptors() []Interceptor {
	return c.inters.UserRelatedRole
}

func (c *UserRelatedRoleClient) mutate(ctx context.Context, m *UserRelatedRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRelatedRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRelatedRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRelatedRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRelatedRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown UserRelatedRole mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(ur *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(ur))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id int64) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(ur *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(ur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id int64) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id int64) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id int64) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	return c.hooks.UserRole
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	return c.inters.UserRole
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown UserRole mutation op: %q", m.Op())
	}
}

// WakatimeClient is a client for the Wakatime schema.
type WakatimeClient struct {
	config
}

// NewWakatimeClient returns a client for the Wakatime from the given config.
func NewWakatimeClient(c config) *WakatimeClient {
	return &WakatimeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatime.Hooks(f(g(h())))`.
func (c *WakatimeClient) Use(hooks ...Hook) {
	c.hooks.Wakatime = append(c.hooks.Wakatime, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatime.Intercept(f(g(h())))`.
func (c *WakatimeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Wakatime = append(c.inters.Wakatime, interceptors...)
}

// Create returns a builder for creating a Wakatime entity.
func (c *WakatimeClient) Create() *WakatimeCreate {
	mutation := newWakatimeMutation(c.config, OpCreate)
	return &WakatimeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Wakatime entities.
func (c *WakatimeClient) CreateBulk(builders ...*WakatimeCreate) *WakatimeCreateBulk {
	return &WakatimeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeClient) MapCreateBulk(slice any, setFunc func(*WakatimeCreate, int)) *WakatimeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeCreateBulk{err: fmt.Errorf("calling to WakatimeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Wakatime.
func (c *WakatimeClient) Update() *WakatimeUpdate {
	mutation := newWakatimeMutation(c.config, OpUpdate)
	return &WakatimeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeClient) UpdateOne(w *Wakatime) *WakatimeUpdateOne {
	mutation := newWakatimeMutation(c.config, OpUpdateOne, withWakatime(w))
	return &WakatimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeClient) UpdateOneID(id int64) *WakatimeUpdateOne {
	mutation := newWakatimeMutation(c.config, OpUpdateOne, withWakatimeID(id))
	return &WakatimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Wakatime.
func (c *WakatimeClient) Delete() *WakatimeDelete {
	mutation := newWakatimeMutation(c.config, OpDelete)
	return &WakatimeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeClient) DeleteOne(w *Wakatime) *WakatimeDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeClient) DeleteOneID(id int64) *WakatimeDeleteOne {
	builder := c.Delete().Where(wakatime.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeDeleteOne{builder}
}

// Query returns a query builder for Wakatime.
func (c *WakatimeClient) Query() *WakatimeQuery {
	return &WakatimeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatime},
		inters: c.Interceptors(),
	}
}

// Get returns a Wakatime entity by its id.
func (c *WakatimeClient) Get(ctx context.Context, id int64) (*Wakatime, error) {
	return c.Query().Where(wakatime.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeClient) GetX(ctx context.Context, id int64) *Wakatime {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeClient) Hooks() []Hook {
	return c.hooks.Wakatime
}

// Interceptors returns the client interceptors.
func (c *WakatimeClient) Interceptors() []Interceptor {
	return c.inters.Wakatime
}

func (c *WakatimeClient) mutate(ctx context.Context, m *WakatimeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Wakatime mutation op: %q", m.Op())
	}
}

// WakatimeCategoryClient is a client for the WakatimeCategory schema.
type WakatimeCategoryClient struct {
	config
}

// NewWakatimeCategoryClient returns a client for the WakatimeCategory from the given config.
func NewWakatimeCategoryClient(c config) *WakatimeCategoryClient {
	return &WakatimeCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimecategory.Hooks(f(g(h())))`.
func (c *WakatimeCategoryClient) Use(hooks ...Hook) {
	c.hooks.WakatimeCategory = append(c.hooks.WakatimeCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimecategory.Intercept(f(g(h())))`.
func (c *WakatimeCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeCategory = append(c.inters.WakatimeCategory, interceptors...)
}

// Create returns a builder for creating a WakatimeCategory entity.
func (c *WakatimeCategoryClient) Create() *WakatimeCategoryCreate {
	mutation := newWakatimeCategoryMutation(c.config, OpCreate)
	return &WakatimeCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeCategory entities.
func (c *WakatimeCategoryClient) CreateBulk(builders ...*WakatimeCategoryCreate) *WakatimeCategoryCreateBulk {
	return &WakatimeCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeCategoryClient) MapCreateBulk(slice any, setFunc func(*WakatimeCategoryCreate, int)) *WakatimeCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeCategoryCreateBulk{err: fmt.Errorf("calling to WakatimeCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeCategory.
func (c *WakatimeCategoryClient) Update() *WakatimeCategoryUpdate {
	mutation := newWakatimeCategoryMutation(c.config, OpUpdate)
	return &WakatimeCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeCategoryClient) UpdateOne(wc *WakatimeCategory) *WakatimeCategoryUpdateOne {
	mutation := newWakatimeCategoryMutation(c.config, OpUpdateOne, withWakatimeCategory(wc))
	return &WakatimeCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeCategoryClient) UpdateOneID(id int64) *WakatimeCategoryUpdateOne {
	mutation := newWakatimeCategoryMutation(c.config, OpUpdateOne, withWakatimeCategoryID(id))
	return &WakatimeCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeCategory.
func (c *WakatimeCategoryClient) Delete() *WakatimeCategoryDelete {
	mutation := newWakatimeCategoryMutation(c.config, OpDelete)
	return &WakatimeCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeCategoryClient) DeleteOne(wc *WakatimeCategory) *WakatimeCategoryDeleteOne {
	return c.DeleteOneID(wc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeCategoryClient) DeleteOneID(id int64) *WakatimeCategoryDeleteOne {
	builder := c.Delete().Where(wakatimecategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeCategoryDeleteOne{builder}
}

// Query returns a query builder for WakatimeCategory.
func (c *WakatimeCategoryClient) Query() *WakatimeCategoryQuery {
	return &WakatimeCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeCategory entity by its id.
func (c *WakatimeCategoryClient) Get(ctx context.Context, id int64) (*WakatimeCategory, error) {
	return c.Query().Where(wakatimecategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeCategoryClient) GetX(ctx context.Context, id int64) *WakatimeCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeCategoryClient) Hooks() []Hook {
	return c.hooks.WakatimeCategory
}

// Interceptors returns the client interceptors.
func (c *WakatimeCategoryClient) Interceptors() []Interceptor {
	return c.inters.WakatimeCategory
}

func (c *WakatimeCategoryClient) mutate(ctx context.Context, m *WakatimeCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeCategory mutation op: %q", m.Op())
	}
}

// WakatimeDependencyClient is a client for the WakatimeDependency schema.
type WakatimeDependencyClient struct {
	config
}

// NewWakatimeDependencyClient returns a client for the WakatimeDependency from the given config.
func NewWakatimeDependencyClient(c config) *WakatimeDependencyClient {
	return &WakatimeDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimedependency.Hooks(f(g(h())))`.
func (c *WakatimeDependencyClient) Use(hooks ...Hook) {
	c.hooks.WakatimeDependency = append(c.hooks.WakatimeDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimedependency.Intercept(f(g(h())))`.
func (c *WakatimeDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeDependency = append(c.inters.WakatimeDependency, interceptors...)
}

// Create returns a builder for creating a WakatimeDependency entity.
func (c *WakatimeDependencyClient) Create() *WakatimeDependencyCreate {
	mutation := newWakatimeDependencyMutation(c.config, OpCreate)
	return &WakatimeDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeDependency entities.
func (c *WakatimeDependencyClient) CreateBulk(builders ...*WakatimeDependencyCreate) *WakatimeDependencyCreateBulk {
	return &WakatimeDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeDependencyClient) MapCreateBulk(slice any, setFunc func(*WakatimeDependencyCreate, int)) *WakatimeDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeDependencyCreateBulk{err: fmt.Errorf("calling to WakatimeDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeDependency.
func (c *WakatimeDependencyClient) Update() *WakatimeDependencyUpdate {
	mutation := newWakatimeDependencyMutation(c.config, OpUpdate)
	return &WakatimeDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeDependencyClient) UpdateOne(wd *WakatimeDependency) *WakatimeDependencyUpdateOne {
	mutation := newWakatimeDependencyMutation(c.config, OpUpdateOne, withWakatimeDependency(wd))
	return &WakatimeDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeDependencyClient) UpdateOneID(id int64) *WakatimeDependencyUpdateOne {
	mutation := newWakatimeDependencyMutation(c.config, OpUpdateOne, withWakatimeDependencyID(id))
	return &WakatimeDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeDependency.
func (c *WakatimeDependencyClient) Delete() *WakatimeDependencyDelete {
	mutation := newWakatimeDependencyMutation(c.config, OpDelete)
	return &WakatimeDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeDependencyClient) DeleteOne(wd *WakatimeDependency) *WakatimeDependencyDeleteOne {
	return c.DeleteOneID(wd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeDependencyClient) DeleteOneID(id int64) *WakatimeDependencyDeleteOne {
	builder := c.Delete().Where(wakatimedependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeDependencyDeleteOne{builder}
}

// Query returns a query builder for WakatimeDependency.
func (c *WakatimeDependencyClient) Query() *WakatimeDependencyQuery {
	return &WakatimeDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeDependency entity by its id.
func (c *WakatimeDependencyClient) Get(ctx context.Context, id int64) (*WakatimeDependency, error) {
	return c.Query().Where(wakatimedependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeDependencyClient) GetX(ctx context.Context, id int64) *WakatimeDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeDependencyClient) Hooks() []Hook {
	return c.hooks.WakatimeDependency
}

// Interceptors returns the client interceptors.
func (c *WakatimeDependencyClient) Interceptors() []Interceptor {
	return c.inters.WakatimeDependency
}

func (c *WakatimeDependencyClient) mutate(ctx context.Context, m *WakatimeDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeDependency mutation op: %q", m.Op())
	}
}

// WakatimeDurationClient is a client for the WakatimeDuration schema.
type WakatimeDurationClient struct {
	config
}

// NewWakatimeDurationClient returns a client for the WakatimeDuration from the given config.
func NewWakatimeDurationClient(c config) *WakatimeDurationClient {
	return &WakatimeDurationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimeduration.Hooks(f(g(h())))`.
func (c *WakatimeDurationClient) Use(hooks ...Hook) {
	c.hooks.WakatimeDuration = append(c.hooks.WakatimeDuration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimeduration.Intercept(f(g(h())))`.
func (c *WakatimeDurationClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeDuration = append(c.inters.WakatimeDuration, interceptors...)
}

// Create returns a builder for creating a WakatimeDuration entity.
func (c *WakatimeDurationClient) Create() *WakatimeDurationCreate {
	mutation := newWakatimeDurationMutation(c.config, OpCreate)
	return &WakatimeDurationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeDuration entities.
func (c *WakatimeDurationClient) CreateBulk(builders ...*WakatimeDurationCreate) *WakatimeDurationCreateBulk {
	return &WakatimeDurationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeDurationClient) MapCreateBulk(slice any, setFunc func(*WakatimeDurationCreate, int)) *WakatimeDurationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeDurationCreateBulk{err: fmt.Errorf("calling to WakatimeDurationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeDurationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeDurationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeDuration.
func (c *WakatimeDurationClient) Update() *WakatimeDurationUpdate {
	mutation := newWakatimeDurationMutation(c.config, OpUpdate)
	return &WakatimeDurationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeDurationClient) UpdateOne(wd *WakatimeDuration) *WakatimeDurationUpdateOne {
	mutation := newWakatimeDurationMutation(c.config, OpUpdateOne, withWakatimeDuration(wd))
	return &WakatimeDurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeDurationClient) UpdateOneID(id int64) *WakatimeDurationUpdateOne {
	mutation := newWakatimeDurationMutation(c.config, OpUpdateOne, withWakatimeDurationID(id))
	return &WakatimeDurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeDuration.
func (c *WakatimeDurationClient) Delete() *WakatimeDurationDelete {
	mutation := newWakatimeDurationMutation(c.config, OpDelete)
	return &WakatimeDurationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeDurationClient) DeleteOne(wd *WakatimeDuration) *WakatimeDurationDeleteOne {
	return c.DeleteOneID(wd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeDurationClient) DeleteOneID(id int64) *WakatimeDurationDeleteOne {
	builder := c.Delete().Where(wakatimeduration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeDurationDeleteOne{builder}
}

// Query returns a query builder for WakatimeDuration.
func (c *WakatimeDurationClient) Query() *WakatimeDurationQuery {
	return &WakatimeDurationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeDuration},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeDuration entity by its id.
func (c *WakatimeDurationClient) Get(ctx context.Context, id int64) (*WakatimeDuration, error) {
	return c.Query().Where(wakatimeduration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeDurationClient) GetX(ctx context.Context, id int64) *WakatimeDuration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeDurationClient) Hooks() []Hook {
	return c.hooks.WakatimeDuration
}

// Interceptors returns the client interceptors.
func (c *WakatimeDurationClient) Interceptors() []Interceptor {
	return c.inters.WakatimeDuration
}

func (c *WakatimeDurationClient) mutate(ctx context.Context, m *WakatimeDurationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeDurationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeDurationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeDurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeDurationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeDuration mutation op: %q", m.Op())
	}
}

// WakatimeEditorClient is a client for the WakatimeEditor schema.
type WakatimeEditorClient struct {
	config
}

// NewWakatimeEditorClient returns a client for the WakatimeEditor from the given config.
func NewWakatimeEditorClient(c config) *WakatimeEditorClient {
	return &WakatimeEditorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimeeditor.Hooks(f(g(h())))`.
func (c *WakatimeEditorClient) Use(hooks ...Hook) {
	c.hooks.WakatimeEditor = append(c.hooks.WakatimeEditor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimeeditor.Intercept(f(g(h())))`.
func (c *WakatimeEditorClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeEditor = append(c.inters.WakatimeEditor, interceptors...)
}

// Create returns a builder for creating a WakatimeEditor entity.
func (c *WakatimeEditorClient) Create() *WakatimeEditorCreate {
	mutation := newWakatimeEditorMutation(c.config, OpCreate)
	return &WakatimeEditorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeEditor entities.
func (c *WakatimeEditorClient) CreateBulk(builders ...*WakatimeEditorCreate) *WakatimeEditorCreateBulk {
	return &WakatimeEditorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeEditorClient) MapCreateBulk(slice any, setFunc func(*WakatimeEditorCreate, int)) *WakatimeEditorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeEditorCreateBulk{err: fmt.Errorf("calling to WakatimeEditorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeEditorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeEditorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeEditor.
func (c *WakatimeEditorClient) Update() *WakatimeEditorUpdate {
	mutation := newWakatimeEditorMutation(c.config, OpUpdate)
	return &WakatimeEditorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeEditorClient) UpdateOne(we *WakatimeEditor) *WakatimeEditorUpdateOne {
	mutation := newWakatimeEditorMutation(c.config, OpUpdateOne, withWakatimeEditor(we))
	return &WakatimeEditorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeEditorClient) UpdateOneID(id int64) *WakatimeEditorUpdateOne {
	mutation := newWakatimeEditorMutation(c.config, OpUpdateOne, withWakatimeEditorID(id))
	return &WakatimeEditorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeEditor.
func (c *WakatimeEditorClient) Delete() *WakatimeEditorDelete {
	mutation := newWakatimeEditorMutation(c.config, OpDelete)
	return &WakatimeEditorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeEditorClient) DeleteOne(we *WakatimeEditor) *WakatimeEditorDeleteOne {
	return c.DeleteOneID(we.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeEditorClient) DeleteOneID(id int64) *WakatimeEditorDeleteOne {
	builder := c.Delete().Where(wakatimeeditor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeEditorDeleteOne{builder}
}

// Query returns a query builder for WakatimeEditor.
func (c *WakatimeEditorClient) Query() *WakatimeEditorQuery {
	return &WakatimeEditorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeEditor},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeEditor entity by its id.
func (c *WakatimeEditorClient) Get(ctx context.Context, id int64) (*WakatimeEditor, error) {
	return c.Query().Where(wakatimeeditor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeEditorClient) GetX(ctx context.Context, id int64) *WakatimeEditor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeEditorClient) Hooks() []Hook {
	return c.hooks.WakatimeEditor
}

// Interceptors returns the client interceptors.
func (c *WakatimeEditorClient) Interceptors() []Interceptor {
	return c.inters.WakatimeEditor
}

func (c *WakatimeEditorClient) mutate(ctx context.Context, m *WakatimeEditorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeEditorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeEditorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeEditorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeEditorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeEditor mutation op: %q", m.Op())
	}
}

// WakatimeEntityClient is a client for the WakatimeEntity schema.
type WakatimeEntityClient struct {
	config
}

// NewWakatimeEntityClient returns a client for the WakatimeEntity from the given config.
func NewWakatimeEntityClient(c config) *WakatimeEntityClient {
	return &WakatimeEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimeentity.Hooks(f(g(h())))`.
func (c *WakatimeEntityClient) Use(hooks ...Hook) {
	c.hooks.WakatimeEntity = append(c.hooks.WakatimeEntity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimeentity.Intercept(f(g(h())))`.
func (c *WakatimeEntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeEntity = append(c.inters.WakatimeEntity, interceptors...)
}

// Create returns a builder for creating a WakatimeEntity entity.
func (c *WakatimeEntityClient) Create() *WakatimeEntityCreate {
	mutation := newWakatimeEntityMutation(c.config, OpCreate)
	return &WakatimeEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeEntity entities.
func (c *WakatimeEntityClient) CreateBulk(builders ...*WakatimeEntityCreate) *WakatimeEntityCreateBulk {
	return &WakatimeEntityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeEntityClient) MapCreateBulk(slice any, setFunc func(*WakatimeEntityCreate, int)) *WakatimeEntityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeEntityCreateBulk{err: fmt.Errorf("calling to WakatimeEntityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeEntityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeEntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeEntity.
func (c *WakatimeEntityClient) Update() *WakatimeEntityUpdate {
	mutation := newWakatimeEntityMutation(c.config, OpUpdate)
	return &WakatimeEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeEntityClient) UpdateOne(we *WakatimeEntity) *WakatimeEntityUpdateOne {
	mutation := newWakatimeEntityMutation(c.config, OpUpdateOne, withWakatimeEntity(we))
	return &WakatimeEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeEntityClient) UpdateOneID(id int64) *WakatimeEntityUpdateOne {
	mutation := newWakatimeEntityMutation(c.config, OpUpdateOne, withWakatimeEntityID(id))
	return &WakatimeEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeEntity.
func (c *WakatimeEntityClient) Delete() *WakatimeEntityDelete {
	mutation := newWakatimeEntityMutation(c.config, OpDelete)
	return &WakatimeEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeEntityClient) DeleteOne(we *WakatimeEntity) *WakatimeEntityDeleteOne {
	return c.DeleteOneID(we.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeEntityClient) DeleteOneID(id int64) *WakatimeEntityDeleteOne {
	builder := c.Delete().Where(wakatimeentity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeEntityDeleteOne{builder}
}

// Query returns a query builder for WakatimeEntity.
func (c *WakatimeEntityClient) Query() *WakatimeEntityQuery {
	return &WakatimeEntityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeEntity},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeEntity entity by its id.
func (c *WakatimeEntityClient) Get(ctx context.Context, id int64) (*WakatimeEntity, error) {
	return c.Query().Where(wakatimeentity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeEntityClient) GetX(ctx context.Context, id int64) *WakatimeEntity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeEntityClient) Hooks() []Hook {
	return c.hooks.WakatimeEntity
}

// Interceptors returns the client interceptors.
func (c *WakatimeEntityClient) Interceptors() []Interceptor {
	return c.inters.WakatimeEntity
}

func (c *WakatimeEntityClient) mutate(ctx context.Context, m *WakatimeEntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeEntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeEntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeEntity mutation op: %q", m.Op())
	}
}

// WakatimeGrandTotalClient is a client for the WakatimeGrandTotal schema.
type WakatimeGrandTotalClient struct {
	config
}

// NewWakatimeGrandTotalClient returns a client for the WakatimeGrandTotal from the given config.
func NewWakatimeGrandTotalClient(c config) *WakatimeGrandTotalClient {
	return &WakatimeGrandTotalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimegrandtotal.Hooks(f(g(h())))`.
func (c *WakatimeGrandTotalClient) Use(hooks ...Hook) {
	c.hooks.WakatimeGrandTotal = append(c.hooks.WakatimeGrandTotal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimegrandtotal.Intercept(f(g(h())))`.
func (c *WakatimeGrandTotalClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeGrandTotal = append(c.inters.WakatimeGrandTotal, interceptors...)
}

// Create returns a builder for creating a WakatimeGrandTotal entity.
func (c *WakatimeGrandTotalClient) Create() *WakatimeGrandTotalCreate {
	mutation := newWakatimeGrandTotalMutation(c.config, OpCreate)
	return &WakatimeGrandTotalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeGrandTotal entities.
func (c *WakatimeGrandTotalClient) CreateBulk(builders ...*WakatimeGrandTotalCreate) *WakatimeGrandTotalCreateBulk {
	return &WakatimeGrandTotalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeGrandTotalClient) MapCreateBulk(slice any, setFunc func(*WakatimeGrandTotalCreate, int)) *WakatimeGrandTotalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeGrandTotalCreateBulk{err: fmt.Errorf("calling to WakatimeGrandTotalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeGrandTotalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeGrandTotalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeGrandTotal.
func (c *WakatimeGrandTotalClient) Update() *WakatimeGrandTotalUpdate {
	mutation := newWakatimeGrandTotalMutation(c.config, OpUpdate)
	return &WakatimeGrandTotalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeGrandTotalClient) UpdateOne(wgt *WakatimeGrandTotal) *WakatimeGrandTotalUpdateOne {
	mutation := newWakatimeGrandTotalMutation(c.config, OpUpdateOne, withWakatimeGrandTotal(wgt))
	return &WakatimeGrandTotalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeGrandTotalClient) UpdateOneID(id int64) *WakatimeGrandTotalUpdateOne {
	mutation := newWakatimeGrandTotalMutation(c.config, OpUpdateOne, withWakatimeGrandTotalID(id))
	return &WakatimeGrandTotalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeGrandTotal.
func (c *WakatimeGrandTotalClient) Delete() *WakatimeGrandTotalDelete {
	mutation := newWakatimeGrandTotalMutation(c.config, OpDelete)
	return &WakatimeGrandTotalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeGrandTotalClient) DeleteOne(wgt *WakatimeGrandTotal) *WakatimeGrandTotalDeleteOne {
	return c.DeleteOneID(wgt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeGrandTotalClient) DeleteOneID(id int64) *WakatimeGrandTotalDeleteOne {
	builder := c.Delete().Where(wakatimegrandtotal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeGrandTotalDeleteOne{builder}
}

// Query returns a query builder for WakatimeGrandTotal.
func (c *WakatimeGrandTotalClient) Query() *WakatimeGrandTotalQuery {
	return &WakatimeGrandTotalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeGrandTotal},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeGrandTotal entity by its id.
func (c *WakatimeGrandTotalClient) Get(ctx context.Context, id int64) (*WakatimeGrandTotal, error) {
	return c.Query().Where(wakatimegrandtotal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeGrandTotalClient) GetX(ctx context.Context, id int64) *WakatimeGrandTotal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeGrandTotalClient) Hooks() []Hook {
	return c.hooks.WakatimeGrandTotal
}

// Interceptors returns the client interceptors.
func (c *WakatimeGrandTotalClient) Interceptors() []Interceptor {
	return c.inters.WakatimeGrandTotal
}

func (c *WakatimeGrandTotalClient) mutate(ctx context.Context, m *WakatimeGrandTotalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeGrandTotalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeGrandTotalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeGrandTotalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeGrandTotalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeGrandTotal mutation op: %q", m.Op())
	}
}

// WakatimeHeartBeatClient is a client for the WakatimeHeartBeat schema.
type WakatimeHeartBeatClient struct {
	config
}

// NewWakatimeHeartBeatClient returns a client for the WakatimeHeartBeat from the given config.
func NewWakatimeHeartBeatClient(c config) *WakatimeHeartBeatClient {
	return &WakatimeHeartBeatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimeheartbeat.Hooks(f(g(h())))`.
func (c *WakatimeHeartBeatClient) Use(hooks ...Hook) {
	c.hooks.WakatimeHeartBeat = append(c.hooks.WakatimeHeartBeat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimeheartbeat.Intercept(f(g(h())))`.
func (c *WakatimeHeartBeatClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeHeartBeat = append(c.inters.WakatimeHeartBeat, interceptors...)
}

// Create returns a builder for creating a WakatimeHeartBeat entity.
func (c *WakatimeHeartBeatClient) Create() *WakatimeHeartBeatCreate {
	mutation := newWakatimeHeartBeatMutation(c.config, OpCreate)
	return &WakatimeHeartBeatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeHeartBeat entities.
func (c *WakatimeHeartBeatClient) CreateBulk(builders ...*WakatimeHeartBeatCreate) *WakatimeHeartBeatCreateBulk {
	return &WakatimeHeartBeatCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeHeartBeatClient) MapCreateBulk(slice any, setFunc func(*WakatimeHeartBeatCreate, int)) *WakatimeHeartBeatCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeHeartBeatCreateBulk{err: fmt.Errorf("calling to WakatimeHeartBeatClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeHeartBeatCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeHeartBeatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeHeartBeat.
func (c *WakatimeHeartBeatClient) Update() *WakatimeHeartBeatUpdate {
	mutation := newWakatimeHeartBeatMutation(c.config, OpUpdate)
	return &WakatimeHeartBeatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeHeartBeatClient) UpdateOne(whb *WakatimeHeartBeat) *WakatimeHeartBeatUpdateOne {
	mutation := newWakatimeHeartBeatMutation(c.config, OpUpdateOne, withWakatimeHeartBeat(whb))
	return &WakatimeHeartBeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeHeartBeatClient) UpdateOneID(id int64) *WakatimeHeartBeatUpdateOne {
	mutation := newWakatimeHeartBeatMutation(c.config, OpUpdateOne, withWakatimeHeartBeatID(id))
	return &WakatimeHeartBeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeHeartBeat.
func (c *WakatimeHeartBeatClient) Delete() *WakatimeHeartBeatDelete {
	mutation := newWakatimeHeartBeatMutation(c.config, OpDelete)
	return &WakatimeHeartBeatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeHeartBeatClient) DeleteOne(whb *WakatimeHeartBeat) *WakatimeHeartBeatDeleteOne {
	return c.DeleteOneID(whb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeHeartBeatClient) DeleteOneID(id int64) *WakatimeHeartBeatDeleteOne {
	builder := c.Delete().Where(wakatimeheartbeat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeHeartBeatDeleteOne{builder}
}

// Query returns a query builder for WakatimeHeartBeat.
func (c *WakatimeHeartBeatClient) Query() *WakatimeHeartBeatQuery {
	return &WakatimeHeartBeatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeHeartBeat},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeHeartBeat entity by its id.
func (c *WakatimeHeartBeatClient) Get(ctx context.Context, id int64) (*WakatimeHeartBeat, error) {
	return c.Query().Where(wakatimeheartbeat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeHeartBeatClient) GetX(ctx context.Context, id int64) *WakatimeHeartBeat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeHeartBeatClient) Hooks() []Hook {
	return c.hooks.WakatimeHeartBeat
}

// Interceptors returns the client interceptors.
func (c *WakatimeHeartBeatClient) Interceptors() []Interceptor {
	return c.inters.WakatimeHeartBeat
}

func (c *WakatimeHeartBeatClient) mutate(ctx context.Context, m *WakatimeHeartBeatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeHeartBeatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeHeartBeatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeHeartBeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeHeartBeatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeHeartBeat mutation op: %q", m.Op())
	}
}

// WakatimeLanguageClient is a client for the WakatimeLanguage schema.
type WakatimeLanguageClient struct {
	config
}

// NewWakatimeLanguageClient returns a client for the WakatimeLanguage from the given config.
func NewWakatimeLanguageClient(c config) *WakatimeLanguageClient {
	return &WakatimeLanguageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimelanguage.Hooks(f(g(h())))`.
func (c *WakatimeLanguageClient) Use(hooks ...Hook) {
	c.hooks.WakatimeLanguage = append(c.hooks.WakatimeLanguage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimelanguage.Intercept(f(g(h())))`.
func (c *WakatimeLanguageClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeLanguage = append(c.inters.WakatimeLanguage, interceptors...)
}

// Create returns a builder for creating a WakatimeLanguage entity.
func (c *WakatimeLanguageClient) Create() *WakatimeLanguageCreate {
	mutation := newWakatimeLanguageMutation(c.config, OpCreate)
	return &WakatimeLanguageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeLanguage entities.
func (c *WakatimeLanguageClient) CreateBulk(builders ...*WakatimeLanguageCreate) *WakatimeLanguageCreateBulk {
	return &WakatimeLanguageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeLanguageClient) MapCreateBulk(slice any, setFunc func(*WakatimeLanguageCreate, int)) *WakatimeLanguageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeLanguageCreateBulk{err: fmt.Errorf("calling to WakatimeLanguageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeLanguageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeLanguageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeLanguage.
func (c *WakatimeLanguageClient) Update() *WakatimeLanguageUpdate {
	mutation := newWakatimeLanguageMutation(c.config, OpUpdate)
	return &WakatimeLanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeLanguageClient) UpdateOne(wl *WakatimeLanguage) *WakatimeLanguageUpdateOne {
	mutation := newWakatimeLanguageMutation(c.config, OpUpdateOne, withWakatimeLanguage(wl))
	return &WakatimeLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeLanguageClient) UpdateOneID(id int64) *WakatimeLanguageUpdateOne {
	mutation := newWakatimeLanguageMutation(c.config, OpUpdateOne, withWakatimeLanguageID(id))
	return &WakatimeLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeLanguage.
func (c *WakatimeLanguageClient) Delete() *WakatimeLanguageDelete {
	mutation := newWakatimeLanguageMutation(c.config, OpDelete)
	return &WakatimeLanguageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeLanguageClient) DeleteOne(wl *WakatimeLanguage) *WakatimeLanguageDeleteOne {
	return c.DeleteOneID(wl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeLanguageClient) DeleteOneID(id int64) *WakatimeLanguageDeleteOne {
	builder := c.Delete().Where(wakatimelanguage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeLanguageDeleteOne{builder}
}

// Query returns a query builder for WakatimeLanguage.
func (c *WakatimeLanguageClient) Query() *WakatimeLanguageQuery {
	return &WakatimeLanguageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeLanguage},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeLanguage entity by its id.
func (c *WakatimeLanguageClient) Get(ctx context.Context, id int64) (*WakatimeLanguage, error) {
	return c.Query().Where(wakatimelanguage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeLanguageClient) GetX(ctx context.Context, id int64) *WakatimeLanguage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeLanguageClient) Hooks() []Hook {
	return c.hooks.WakatimeLanguage
}

// Interceptors returns the client interceptors.
func (c *WakatimeLanguageClient) Interceptors() []Interceptor {
	return c.inters.WakatimeLanguage
}

func (c *WakatimeLanguageClient) mutate(ctx context.Context, m *WakatimeLanguageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeLanguageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeLanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeLanguageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeLanguage mutation op: %q", m.Op())
	}
}

// WakatimeProjectClient is a client for the WakatimeProject schema.
type WakatimeProjectClient struct {
	config
}

// NewWakatimeProjectClient returns a client for the WakatimeProject from the given config.
func NewWakatimeProjectClient(c config) *WakatimeProjectClient {
	return &WakatimeProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimeproject.Hooks(f(g(h())))`.
func (c *WakatimeProjectClient) Use(hooks ...Hook) {
	c.hooks.WakatimeProject = append(c.hooks.WakatimeProject, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimeproject.Intercept(f(g(h())))`.
func (c *WakatimeProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeProject = append(c.inters.WakatimeProject, interceptors...)
}

// Create returns a builder for creating a WakatimeProject entity.
func (c *WakatimeProjectClient) Create() *WakatimeProjectCreate {
	mutation := newWakatimeProjectMutation(c.config, OpCreate)
	return &WakatimeProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeProject entities.
func (c *WakatimeProjectClient) CreateBulk(builders ...*WakatimeProjectCreate) *WakatimeProjectCreateBulk {
	return &WakatimeProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeProjectClient) MapCreateBulk(slice any, setFunc func(*WakatimeProjectCreate, int)) *WakatimeProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeProjectCreateBulk{err: fmt.Errorf("calling to WakatimeProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeProject.
func (c *WakatimeProjectClient) Update() *WakatimeProjectUpdate {
	mutation := newWakatimeProjectMutation(c.config, OpUpdate)
	return &WakatimeProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeProjectClient) UpdateOne(wp *WakatimeProject) *WakatimeProjectUpdateOne {
	mutation := newWakatimeProjectMutation(c.config, OpUpdateOne, withWakatimeProject(wp))
	return &WakatimeProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeProjectClient) UpdateOneID(id int64) *WakatimeProjectUpdateOne {
	mutation := newWakatimeProjectMutation(c.config, OpUpdateOne, withWakatimeProjectID(id))
	return &WakatimeProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeProject.
func (c *WakatimeProjectClient) Delete() *WakatimeProjectDelete {
	mutation := newWakatimeProjectMutation(c.config, OpDelete)
	return &WakatimeProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeProjectClient) DeleteOne(wp *WakatimeProject) *WakatimeProjectDeleteOne {
	return c.DeleteOneID(wp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeProjectClient) DeleteOneID(id int64) *WakatimeProjectDeleteOne {
	builder := c.Delete().Where(wakatimeproject.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeProjectDeleteOne{builder}
}

// Query returns a query builder for WakatimeProject.
func (c *WakatimeProjectClient) Query() *WakatimeProjectQuery {
	return &WakatimeProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeProject entity by its id.
func (c *WakatimeProjectClient) Get(ctx context.Context, id int64) (*WakatimeProject, error) {
	return c.Query().Where(wakatimeproject.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeProjectClient) GetX(ctx context.Context, id int64) *WakatimeProject {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeProjectClient) Hooks() []Hook {
	return c.hooks.WakatimeProject
}

// Interceptors returns the client interceptors.
func (c *WakatimeProjectClient) Interceptors() []Interceptor {
	return c.inters.WakatimeProject
}

func (c *WakatimeProjectClient) mutate(ctx context.Context, m *WakatimeProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeProject mutation op: %q", m.Op())
	}
}

// WakatimeProjectDurationClient is a client for the WakatimeProjectDuration schema.
type WakatimeProjectDurationClient struct {
	config
}

// NewWakatimeProjectDurationClient returns a client for the WakatimeProjectDuration from the given config.
func NewWakatimeProjectDurationClient(c config) *WakatimeProjectDurationClient {
	return &WakatimeProjectDurationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimeprojectduration.Hooks(f(g(h())))`.
func (c *WakatimeProjectDurationClient) Use(hooks ...Hook) {
	c.hooks.WakatimeProjectDuration = append(c.hooks.WakatimeProjectDuration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimeprojectduration.Intercept(f(g(h())))`.
func (c *WakatimeProjectDurationClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeProjectDuration = append(c.inters.WakatimeProjectDuration, interceptors...)
}

// Create returns a builder for creating a WakatimeProjectDuration entity.
func (c *WakatimeProjectDurationClient) Create() *WakatimeProjectDurationCreate {
	mutation := newWakatimeProjectDurationMutation(c.config, OpCreate)
	return &WakatimeProjectDurationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeProjectDuration entities.
func (c *WakatimeProjectDurationClient) CreateBulk(builders ...*WakatimeProjectDurationCreate) *WakatimeProjectDurationCreateBulk {
	return &WakatimeProjectDurationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeProjectDurationClient) MapCreateBulk(slice any, setFunc func(*WakatimeProjectDurationCreate, int)) *WakatimeProjectDurationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeProjectDurationCreateBulk{err: fmt.Errorf("calling to WakatimeProjectDurationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeProjectDurationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeProjectDurationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeProjectDuration.
func (c *WakatimeProjectDurationClient) Update() *WakatimeProjectDurationUpdate {
	mutation := newWakatimeProjectDurationMutation(c.config, OpUpdate)
	return &WakatimeProjectDurationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeProjectDurationClient) UpdateOne(wpd *WakatimeProjectDuration) *WakatimeProjectDurationUpdateOne {
	mutation := newWakatimeProjectDurationMutation(c.config, OpUpdateOne, withWakatimeProjectDuration(wpd))
	return &WakatimeProjectDurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeProjectDurationClient) UpdateOneID(id int64) *WakatimeProjectDurationUpdateOne {
	mutation := newWakatimeProjectDurationMutation(c.config, OpUpdateOne, withWakatimeProjectDurationID(id))
	return &WakatimeProjectDurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeProjectDuration.
func (c *WakatimeProjectDurationClient) Delete() *WakatimeProjectDurationDelete {
	mutation := newWakatimeProjectDurationMutation(c.config, OpDelete)
	return &WakatimeProjectDurationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeProjectDurationClient) DeleteOne(wpd *WakatimeProjectDuration) *WakatimeProjectDurationDeleteOne {
	return c.DeleteOneID(wpd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeProjectDurationClient) DeleteOneID(id int64) *WakatimeProjectDurationDeleteOne {
	builder := c.Delete().Where(wakatimeprojectduration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeProjectDurationDeleteOne{builder}
}

// Query returns a query builder for WakatimeProjectDuration.
func (c *WakatimeProjectDurationClient) Query() *WakatimeProjectDurationQuery {
	return &WakatimeProjectDurationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeProjectDuration},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeProjectDuration entity by its id.
func (c *WakatimeProjectDurationClient) Get(ctx context.Context, id int64) (*WakatimeProjectDuration, error) {
	return c.Query().Where(wakatimeprojectduration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeProjectDurationClient) GetX(ctx context.Context, id int64) *WakatimeProjectDuration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeProjectDurationClient) Hooks() []Hook {
	return c.hooks.WakatimeProjectDuration
}

// Interceptors returns the client interceptors.
func (c *WakatimeProjectDurationClient) Interceptors() []Interceptor {
	return c.inters.WakatimeProjectDuration
}

func (c *WakatimeProjectDurationClient) mutate(ctx context.Context, m *WakatimeProjectDurationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeProjectDurationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeProjectDurationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeProjectDurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeProjectDurationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeProjectDuration mutation op: %q", m.Op())
	}
}

// WakatimeProjectInfoClient is a client for the WakatimeProjectInfo schema.
type WakatimeProjectInfoClient struct {
	config
}

// NewWakatimeProjectInfoClient returns a client for the WakatimeProjectInfo from the given config.
func NewWakatimeProjectInfoClient(c config) *WakatimeProjectInfoClient {
	return &WakatimeProjectInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimeprojectinfo.Hooks(f(g(h())))`.
func (c *WakatimeProjectInfoClient) Use(hooks ...Hook) {
	c.hooks.WakatimeProjectInfo = append(c.hooks.WakatimeProjectInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimeprojectinfo.Intercept(f(g(h())))`.
func (c *WakatimeProjectInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeProjectInfo = append(c.inters.WakatimeProjectInfo, interceptors...)
}

// Create returns a builder for creating a WakatimeProjectInfo entity.
func (c *WakatimeProjectInfoClient) Create() *WakatimeProjectInfoCreate {
	mutation := newWakatimeProjectInfoMutation(c.config, OpCreate)
	return &WakatimeProjectInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeProjectInfo entities.
func (c *WakatimeProjectInfoClient) CreateBulk(builders ...*WakatimeProjectInfoCreate) *WakatimeProjectInfoCreateBulk {
	return &WakatimeProjectInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeProjectInfoClient) MapCreateBulk(slice any, setFunc func(*WakatimeProjectInfoCreate, int)) *WakatimeProjectInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeProjectInfoCreateBulk{err: fmt.Errorf("calling to WakatimeProjectInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeProjectInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeProjectInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeProjectInfo.
func (c *WakatimeProjectInfoClient) Update() *WakatimeProjectInfoUpdate {
	mutation := newWakatimeProjectInfoMutation(c.config, OpUpdate)
	return &WakatimeProjectInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeProjectInfoClient) UpdateOne(wpi *WakatimeProjectInfo) *WakatimeProjectInfoUpdateOne {
	mutation := newWakatimeProjectInfoMutation(c.config, OpUpdateOne, withWakatimeProjectInfo(wpi))
	return &WakatimeProjectInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeProjectInfoClient) UpdateOneID(id int64) *WakatimeProjectInfoUpdateOne {
	mutation := newWakatimeProjectInfoMutation(c.config, OpUpdateOne, withWakatimeProjectInfoID(id))
	return &WakatimeProjectInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeProjectInfo.
func (c *WakatimeProjectInfoClient) Delete() *WakatimeProjectInfoDelete {
	mutation := newWakatimeProjectInfoMutation(c.config, OpDelete)
	return &WakatimeProjectInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeProjectInfoClient) DeleteOne(wpi *WakatimeProjectInfo) *WakatimeProjectInfoDeleteOne {
	return c.DeleteOneID(wpi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeProjectInfoClient) DeleteOneID(id int64) *WakatimeProjectInfoDeleteOne {
	builder := c.Delete().Where(wakatimeprojectinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeProjectInfoDeleteOne{builder}
}

// Query returns a query builder for WakatimeProjectInfo.
func (c *WakatimeProjectInfoClient) Query() *WakatimeProjectInfoQuery {
	return &WakatimeProjectInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeProjectInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeProjectInfo entity by its id.
func (c *WakatimeProjectInfoClient) Get(ctx context.Context, id int64) (*WakatimeProjectInfo, error) {
	return c.Query().Where(wakatimeprojectinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeProjectInfoClient) GetX(ctx context.Context, id int64) *WakatimeProjectInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeProjectInfoClient) Hooks() []Hook {
	return c.hooks.WakatimeProjectInfo
}

// Interceptors returns the client interceptors.
func (c *WakatimeProjectInfoClient) Interceptors() []Interceptor {
	return c.inters.WakatimeProjectInfo
}

func (c *WakatimeProjectInfoClient) mutate(ctx context.Context, m *WakatimeProjectInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeProjectInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeProjectInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeProjectInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeProjectInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeProjectInfo mutation op: %q", m.Op())
	}
}

// WakatimeSystemClient is a client for the WakatimeSystem schema.
type WakatimeSystemClient struct {
	config
}

// NewWakatimeSystemClient returns a client for the WakatimeSystem from the given config.
func NewWakatimeSystemClient(c config) *WakatimeSystemClient {
	return &WakatimeSystemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wakatimesystem.Hooks(f(g(h())))`.
func (c *WakatimeSystemClient) Use(hooks ...Hook) {
	c.hooks.WakatimeSystem = append(c.hooks.WakatimeSystem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wakatimesystem.Intercept(f(g(h())))`.
func (c *WakatimeSystemClient) Intercept(interceptors ...Interceptor) {
	c.inters.WakatimeSystem = append(c.inters.WakatimeSystem, interceptors...)
}

// Create returns a builder for creating a WakatimeSystem entity.
func (c *WakatimeSystemClient) Create() *WakatimeSystemCreate {
	mutation := newWakatimeSystemMutation(c.config, OpCreate)
	return &WakatimeSystemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WakatimeSystem entities.
func (c *WakatimeSystemClient) CreateBulk(builders ...*WakatimeSystemCreate) *WakatimeSystemCreateBulk {
	return &WakatimeSystemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WakatimeSystemClient) MapCreateBulk(slice any, setFunc func(*WakatimeSystemCreate, int)) *WakatimeSystemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WakatimeSystemCreateBulk{err: fmt.Errorf("calling to WakatimeSystemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WakatimeSystemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WakatimeSystemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WakatimeSystem.
func (c *WakatimeSystemClient) Update() *WakatimeSystemUpdate {
	mutation := newWakatimeSystemMutation(c.config, OpUpdate)
	return &WakatimeSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WakatimeSystemClient) UpdateOne(ws *WakatimeSystem) *WakatimeSystemUpdateOne {
	mutation := newWakatimeSystemMutation(c.config, OpUpdateOne, withWakatimeSystem(ws))
	return &WakatimeSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WakatimeSystemClient) UpdateOneID(id int64) *WakatimeSystemUpdateOne {
	mutation := newWakatimeSystemMutation(c.config, OpUpdateOne, withWakatimeSystemID(id))
	return &WakatimeSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WakatimeSystem.
func (c *WakatimeSystemClient) Delete() *WakatimeSystemDelete {
	mutation := newWakatimeSystemMutation(c.config, OpDelete)
	return &WakatimeSystemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WakatimeSystemClient) DeleteOne(ws *WakatimeSystem) *WakatimeSystemDeleteOne {
	return c.DeleteOneID(ws.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WakatimeSystemClient) DeleteOneID(id int64) *WakatimeSystemDeleteOne {
	builder := c.Delete().Where(wakatimesystem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WakatimeSystemDeleteOne{builder}
}

// Query returns a query builder for WakatimeSystem.
func (c *WakatimeSystemClient) Query() *WakatimeSystemQuery {
	return &WakatimeSystemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWakatimeSystem},
		inters: c.Interceptors(),
	}
}

// Get returns a WakatimeSystem entity by its id.
func (c *WakatimeSystemClient) Get(ctx context.Context, id int64) (*WakatimeSystem, error) {
	return c.Query().Where(wakatimesystem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WakatimeSystemClient) GetX(ctx context.Context, id int64) *WakatimeSystem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WakatimeSystemClient) Hooks() []Hook {
	return c.hooks.WakatimeSystem
}

// Interceptors returns the client interceptors.
func (c *WakatimeSystemClient) Interceptors() []Interceptor {
	return c.inters.WakatimeSystem
}

func (c *WakatimeSystemClient) mutate(ctx context.Context, m *WakatimeSystemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WakatimeSystemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WakatimeSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WakatimeSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WakatimeSystemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WakatimeSystem mutation op: %q", m.Op())
	}
}

// WebAuthnCredentialClient is a client for the WebAuthnCredential schema.
type WebAuthnCredentialClient struct {
	config
}

// NewWebAuthnCredentialClient returns a client for the WebAuthnCredential from the given config.
func NewWebAuthnCredentialClient(c config) *WebAuthnCredentialClient {
	return &WebAuthnCredentialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `webauthncredential.Hooks(f(g(h())))`.
func (c *WebAuthnCredentialClient) Use(hooks ...Hook) {
	c.hooks.WebAuthnCredential = append(c.hooks.WebAuthnCredential, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `webauthncredential.Intercept(f(g(h())))`.
func (c *WebAuthnCredentialClient) Intercept(interceptors ...Interceptor) {
	c.inters.WebAuthnCredential = append(c.inters.WebAuthnCredential, interceptors...)
}

// Create returns a builder for creating a WebAuthnCredential entity.
func (c *WebAuthnCredentialClient) Create() *WebAuthnCredentialCreate {
	mutation := newWebAuthnCredentialMutation(c.config, OpCreate)
	return &WebAuthnCredentialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WebAuthnCredential entities.
func (c *WebAuthnCredentialClient) CreateBulk(builders ...*WebAuthnCredentialCreate) *WebAuthnCredentialCreateBulk {
	return &WebAuthnCredentialCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebAuthnCredentialClient) MapCreateBulk(slice any, setFunc func(*WebAuthnCredentialCreate, int)) *WebAuthnCredentialCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebAuthnCredentialCreateBulk{err: fmt.Errorf("calling to WebAuthnCredentialClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebAuthnCredentialCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebAuthnCredentialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WebAuthnCredential.
func (c *WebAuthnCredentialClient) Update() *WebAuthnCredentialUpdate {
	mutation := newWebAuthnCredentialMutation(c.config, OpUpdate)
	return &WebAuthnCredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebAuthnCredentialClient) UpdateOne(wac *WebAuthnCredential) *WebAuthnCredentialUpdateOne {
	mutation := newWebAuthnCredentialMutation(c.config, OpUpdateOne, withWebAuthnCredential(wac))
	return &WebAuthnCredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebAuthnCredentialClient) UpdateOneID(id int64) *WebAuthnCredentialUpdateOne {
	mutation := newWebAuthnCredentialMutation(c.config, OpUpdateOne, withWebAuthnCredentialID(id))
	return &WebAuthnCredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WebAuthnCredential.
func (c *WebAuthnCredentialClient) Delete() *WebAuthnCredentialDelete {
	mutation := newWebAuthnCredentialMutation(c.config, OpDelete)
	return &WebAuthnCredentialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebAuthnCredentialClient) DeleteOne(wac *WebAuthnCredential) *WebAuthnCredentialDeleteOne {
	return c.DeleteOneID(wac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebAuthnCredentialClient) DeleteOneID(id int64) *WebAuthnCredentialDeleteOne {
	builder := c.Delete().Where(webauthncredential.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebAuthnCredentialDeleteOne{builder}
}

// Query returns a query builder for WebAuthnCredential.
func (c *WebAuthnCredentialClient) Query() *WebAuthnCredentialQuery {
	return &WebAuthnCredentialQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebAuthnCredential},
		inters: c.Interceptors(),
	}
}

// Get returns a WebAuthnCredential entity by its id.
func (c *WebAuthnCredentialClient) Get(ctx context.Context, id int64) (*WebAuthnCredential, error) {
	return c.Query().Where(webauthncredential.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebAuthnCredentialClient) GetX(ctx context.Context, id int64) *WebAuthnCredential {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WebAuthnCredentialClient) Hooks() []Hook {
	return c.hooks.WebAuthnCredential
}

// Interceptors returns the client interceptors.
func (c *WebAuthnCredentialClient) Interceptors() []Interceptor {
	return c.inters.WebAuthnCredential
}

func (c *WebAuthnCredentialClient) mutate(ctx context.Context, m *WebAuthnCredentialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebAuthnCredentialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebAuthnCredentialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebAuthnCredentialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebAuthnCredentialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown WebAuthnCredential mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccessToken, Accounts, MemberRoleRelatedPermission, PermissionGroup,
		PermissionRelatedRouter, Router, Source, SourceData, TwoFactor, User,
		UserAuthSource, UserRelatedRole, UserRole, Wakatime, WakatimeCategory,
		WakatimeDependency, WakatimeDuration, WakatimeEditor, WakatimeEntity,
		WakatimeGrandTotal, WakatimeHeartBeat, WakatimeLanguage, WakatimeProject,
		WakatimeProjectDuration, WakatimeProjectInfo, WakatimeSystem,
		WebAuthnCredential []ent.Hook
	}
	inters struct {
		AccessToken, Accounts, MemberRoleRelatedPermission, PermissionGroup,
		PermissionRelatedRouter, Router, Source, SourceData, TwoFactor, User,
		UserAuthSource, UserRelatedRole, UserRole, Wakatime, WakatimeCategory,
		WakatimeDependency, WakatimeDuration, WakatimeEditor, WakatimeEntity,
		WakatimeGrandTotal, WakatimeHeartBeat, WakatimeLanguage, WakatimeProject,
		WakatimeProjectDuration, WakatimeProjectInfo, WakatimeSystem,
		WebAuthnCredential []ent.Interceptor
	}
)
