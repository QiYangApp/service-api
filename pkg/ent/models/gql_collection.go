// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"ent/models/accesstoken"
	"ent/models/accounts"
	"ent/models/memberrolerelatedpermission"
	"ent/models/permissiongroup"
	"ent/models/permissionrelatedrouter"
	"ent/models/router"
	"ent/models/source"
	"ent/models/sourcedata"
	"ent/models/user"
	"ent/models/userauthsource"
	"ent/models/userrelatedrole"
	"ent/models/userrole"
	"ent/models/wakatime"
	"ent/models/wakatimecategory"
	"ent/models/wakatimedependency"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (at *AccessTokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*AccessTokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return at, nil
	}
	if err := at.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return at, nil
}

func (at *AccessTokenQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(accesstoken.Columns))
		selectedFields = []string{accesstoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "userID":
			if _, ok := fieldSeen[accesstoken.FieldUserID]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldUserID)
				fieldSeen[accesstoken.FieldUserID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[accesstoken.FieldName]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldName)
				fieldSeen[accesstoken.FieldName] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[accesstoken.FieldToken]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldToken)
				fieldSeen[accesstoken.FieldToken] = struct{}{}
			}
		case "tokenHash":
			if _, ok := fieldSeen[accesstoken.FieldTokenHash]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldTokenHash)
				fieldSeen[accesstoken.FieldTokenHash] = struct{}{}
			}
		case "tokenSalt":
			if _, ok := fieldSeen[accesstoken.FieldTokenSalt]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldTokenSalt)
				fieldSeen[accesstoken.FieldTokenSalt] = struct{}{}
			}
		case "tokenLastEight":
			if _, ok := fieldSeen[accesstoken.FieldTokenLastEight]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldTokenLastEight)
				fieldSeen[accesstoken.FieldTokenLastEight] = struct{}{}
			}
		case "scope":
			if _, ok := fieldSeen[accesstoken.FieldScope]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldScope)
				fieldSeen[accesstoken.FieldScope] = struct{}{}
			}
		case "hasRecentActivity":
			if _, ok := fieldSeen[accesstoken.FieldHasRecentActivity]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldHasRecentActivity)
				fieldSeen[accesstoken.FieldHasRecentActivity] = struct{}{}
			}
		case "hasUsed":
			if _, ok := fieldSeen[accesstoken.FieldHasUsed]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldHasUsed)
				fieldSeen[accesstoken.FieldHasUsed] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[accesstoken.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldCreateTime)
				fieldSeen[accesstoken.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[accesstoken.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, accesstoken.FieldUpdateTime)
				fieldSeen[accesstoken.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		at.Select(selectedFields...)
	}
	return nil
}

type accesstokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AccessTokenPaginateOption
}

func newAccessTokenPaginateArgs(rv map[string]any) *accesstokenPaginateArgs {
	args := &accesstokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AccountsQuery) CollectFields(ctx context.Context, satisfies ...string) (*AccountsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AccountsQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(accounts.Columns))
		selectedFields = []string{accounts.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "userID":
			if _, ok := fieldSeen[accounts.FieldUserID]; !ok {
				selectedFields = append(selectedFields, accounts.FieldUserID)
				fieldSeen[accounts.FieldUserID] = struct{}{}
			}
		case "account":
			if _, ok := fieldSeen[accounts.FieldAccount]; !ok {
				selectedFields = append(selectedFields, accounts.FieldAccount)
				fieldSeen[accounts.FieldAccount] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[accounts.FieldType]; !ok {
				selectedFields = append(selectedFields, accounts.FieldType)
				fieldSeen[accounts.FieldType] = struct{}{}
			}
		case "desc":
			if _, ok := fieldSeen[accounts.FieldDesc]; !ok {
				selectedFields = append(selectedFields, accounts.FieldDesc)
				fieldSeen[accounts.FieldDesc] = struct{}{}
			}
		case "isPrivate":
			if _, ok := fieldSeen[accounts.FieldIsPrivate]; !ok {
				selectedFields = append(selectedFields, accounts.FieldIsPrivate)
				fieldSeen[accounts.FieldIsPrivate] = struct{}{}
			}
		case "isActivated":
			if _, ok := fieldSeen[accounts.FieldIsActivated]; !ok {
				selectedFields = append(selectedFields, accounts.FieldIsActivated)
				fieldSeen[accounts.FieldIsActivated] = struct{}{}
			}
		case "isPrimary":
			if _, ok := fieldSeen[accounts.FieldIsPrimary]; !ok {
				selectedFields = append(selectedFields, accounts.FieldIsPrimary)
				fieldSeen[accounts.FieldIsPrimary] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[accounts.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, accounts.FieldCreateTime)
				fieldSeen[accounts.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[accounts.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, accounts.FieldUpdateTime)
				fieldSeen[accounts.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type accountsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AccountsPaginateOption
}

func newAccountsPaginateArgs(rv map[string]any) *accountsPaginateArgs {
	args := &accountsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (mrrp *MemberRoleRelatedPermissionQuery) CollectFields(ctx context.Context, satisfies ...string) (*MemberRoleRelatedPermissionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return mrrp, nil
	}
	if err := mrrp.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return mrrp, nil
}

func (mrrp *MemberRoleRelatedPermissionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(memberrolerelatedpermission.Columns))
		selectedFields = []string{memberrolerelatedpermission.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "roleID":
			if _, ok := fieldSeen[memberrolerelatedpermission.FieldRoleID]; !ok {
				selectedFields = append(selectedFields, memberrolerelatedpermission.FieldRoleID)
				fieldSeen[memberrolerelatedpermission.FieldRoleID] = struct{}{}
			}
		case "permissionGroupID":
			if _, ok := fieldSeen[memberrolerelatedpermission.FieldPermissionGroupID]; !ok {
				selectedFields = append(selectedFields, memberrolerelatedpermission.FieldPermissionGroupID)
				fieldSeen[memberrolerelatedpermission.FieldPermissionGroupID] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[memberrolerelatedpermission.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, memberrolerelatedpermission.FieldCreateTime)
				fieldSeen[memberrolerelatedpermission.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[memberrolerelatedpermission.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, memberrolerelatedpermission.FieldUpdateTime)
				fieldSeen[memberrolerelatedpermission.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		mrrp.Select(selectedFields...)
	}
	return nil
}

type memberrolerelatedpermissionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MemberRoleRelatedPermissionPaginateOption
}

func newMemberRoleRelatedPermissionPaginateArgs(rv map[string]any) *memberrolerelatedpermissionPaginateArgs {
	args := &memberrolerelatedpermissionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pg *PermissionGroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*PermissionGroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pg, nil
	}
	if err := pg.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pg, nil
}

func (pg *PermissionGroupQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(permissiongroup.Columns))
		selectedFields = []string{permissiongroup.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "permissionName":
			if _, ok := fieldSeen[permissiongroup.FieldPermissionName]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldPermissionName)
				fieldSeen[permissiongroup.FieldPermissionName] = struct{}{}
			}
		case "ioc":
			if _, ok := fieldSeen[permissiongroup.FieldIoc]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldIoc)
				fieldSeen[permissiongroup.FieldIoc] = struct{}{}
			}
		case "sort":
			if _, ok := fieldSeen[permissiongroup.FieldSort]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldSort)
				fieldSeen[permissiongroup.FieldSort] = struct{}{}
			}
		case "left":
			if _, ok := fieldSeen[permissiongroup.FieldLeft]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldLeft)
				fieldSeen[permissiongroup.FieldLeft] = struct{}{}
			}
		case "right":
			if _, ok := fieldSeen[permissiongroup.FieldRight]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldRight)
				fieldSeen[permissiongroup.FieldRight] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[permissiongroup.FieldState]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldState)
				fieldSeen[permissiongroup.FieldState] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[permissiongroup.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldCreateTime)
				fieldSeen[permissiongroup.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[permissiongroup.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, permissiongroup.FieldUpdateTime)
				fieldSeen[permissiongroup.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pg.Select(selectedFields...)
	}
	return nil
}

type permissiongroupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PermissionGroupPaginateOption
}

func newPermissionGroupPaginateArgs(rv map[string]any) *permissiongroupPaginateArgs {
	args := &permissiongroupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (prr *PermissionRelatedRouterQuery) CollectFields(ctx context.Context, satisfies ...string) (*PermissionRelatedRouterQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return prr, nil
	}
	if err := prr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return prr, nil
}

func (prr *PermissionRelatedRouterQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(permissionrelatedrouter.Columns))
		selectedFields = []string{permissionrelatedrouter.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "routerID":
			if _, ok := fieldSeen[permissionrelatedrouter.FieldRouterID]; !ok {
				selectedFields = append(selectedFields, permissionrelatedrouter.FieldRouterID)
				fieldSeen[permissionrelatedrouter.FieldRouterID] = struct{}{}
			}
		case "permissionGroupID":
			if _, ok := fieldSeen[permissionrelatedrouter.FieldPermissionGroupID]; !ok {
				selectedFields = append(selectedFields, permissionrelatedrouter.FieldPermissionGroupID)
				fieldSeen[permissionrelatedrouter.FieldPermissionGroupID] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[permissionrelatedrouter.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, permissionrelatedrouter.FieldCreateTime)
				fieldSeen[permissionrelatedrouter.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[permissionrelatedrouter.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, permissionrelatedrouter.FieldUpdateTime)
				fieldSeen[permissionrelatedrouter.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		prr.Select(selectedFields...)
	}
	return nil
}

type permissionrelatedrouterPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PermissionRelatedRouterPaginateOption
}

func newPermissionRelatedRouterPaginateArgs(rv map[string]any) *permissionrelatedrouterPaginateArgs {
	args := &permissionrelatedrouterPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RouterQuery) CollectFields(ctx context.Context, satisfies ...string) (*RouterQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if err := r.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return r, nil
}

func (r *RouterQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(router.Columns))
		selectedFields = []string{router.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "routeName":
			if _, ok := fieldSeen[router.FieldRouteName]; !ok {
				selectedFields = append(selectedFields, router.FieldRouteName)
				fieldSeen[router.FieldRouteName] = struct{}{}
			}
		case "route":
			if _, ok := fieldSeen[router.FieldRoute]; !ok {
				selectedFields = append(selectedFields, router.FieldRoute)
				fieldSeen[router.FieldRoute] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[router.FieldDescription]; !ok {
				selectedFields = append(selectedFields, router.FieldDescription)
				fieldSeen[router.FieldDescription] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[router.FieldState]; !ok {
				selectedFields = append(selectedFields, router.FieldState)
				fieldSeen[router.FieldState] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[router.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, router.FieldCreateTime)
				fieldSeen[router.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[router.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, router.FieldUpdateTime)
				fieldSeen[router.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		r.Select(selectedFields...)
	}
	return nil
}

type routerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RouterPaginateOption
}

func newRouterPaginateArgs(rv map[string]any) *routerPaginateArgs {
	args := &routerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SourceQuery) CollectFields(ctx context.Context, satisfies ...string) (*SourceQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SourceQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(source.Columns))
		selectedFields = []string{source.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "type":
			if _, ok := fieldSeen[source.FieldType]; !ok {
				selectedFields = append(selectedFields, source.FieldType)
				fieldSeen[source.FieldType] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[source.FieldName]; !ok {
				selectedFields = append(selectedFields, source.FieldName)
				fieldSeen[source.FieldName] = struct{}{}
			}
		case "isActive":
			if _, ok := fieldSeen[source.FieldIsActive]; !ok {
				selectedFields = append(selectedFields, source.FieldIsActive)
				fieldSeen[source.FieldIsActive] = struct{}{}
			}
		case "isSyncEnabled":
			if _, ok := fieldSeen[source.FieldIsSyncEnabled]; !ok {
				selectedFields = append(selectedFields, source.FieldIsSyncEnabled)
				fieldSeen[source.FieldIsSyncEnabled] = struct{}{}
			}
		case "cfg":
			if _, ok := fieldSeen[source.FieldCfg]; !ok {
				selectedFields = append(selectedFields, source.FieldCfg)
				fieldSeen[source.FieldCfg] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[source.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, source.FieldCreateTime)
				fieldSeen[source.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[source.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, source.FieldUpdateTime)
				fieldSeen[source.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type sourcePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SourcePaginateOption
}

func newSourcePaginateArgs(rv map[string]any) *sourcePaginateArgs {
	args := &sourcePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sd *SourceDataQuery) CollectFields(ctx context.Context, satisfies ...string) (*SourceDataQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sd, nil
	}
	if err := sd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sd, nil
}

func (sd *SourceDataQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(sourcedata.Columns))
		selectedFields = []string{sourcedata.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "userID":
			if _, ok := fieldSeen[sourcedata.FieldUserID]; !ok {
				selectedFields = append(selectedFields, sourcedata.FieldUserID)
				fieldSeen[sourcedata.FieldUserID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[sourcedata.FieldType]; !ok {
				selectedFields = append(selectedFields, sourcedata.FieldType)
				fieldSeen[sourcedata.FieldType] = struct{}{}
			}
		case "subType":
			if _, ok := fieldSeen[sourcedata.FieldSubType]; !ok {
				selectedFields = append(selectedFields, sourcedata.FieldSubType)
				fieldSeen[sourcedata.FieldSubType] = struct{}{}
			}
		case "info":
			if _, ok := fieldSeen[sourcedata.FieldInfo]; !ok {
				selectedFields = append(selectedFields, sourcedata.FieldInfo)
				fieldSeen[sourcedata.FieldInfo] = struct{}{}
			}
		case "snapshot":
			if _, ok := fieldSeen[sourcedata.FieldSnapshot]; !ok {
				selectedFields = append(selectedFields, sourcedata.FieldSnapshot)
				fieldSeen[sourcedata.FieldSnapshot] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[sourcedata.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, sourcedata.FieldCreateTime)
				fieldSeen[sourcedata.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[sourcedata.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, sourcedata.FieldUpdateTime)
				fieldSeen[sourcedata.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sd.Select(selectedFields...)
	}
	return nil
}

type sourcedataPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SourceDataPaginateOption
}

func newSourceDataPaginateArgs(rv map[string]any) *sourcedataPaginateArgs {
	args := &sourcedataPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "avatar":
			if _, ok := fieldSeen[user.FieldAvatar]; !ok {
				selectedFields = append(selectedFields, user.FieldAvatar)
				fieldSeen[user.FieldAvatar] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "lowerName":
			if _, ok := fieldSeen[user.FieldLowerName]; !ok {
				selectedFields = append(selectedFields, user.FieldLowerName)
				fieldSeen[user.FieldLowerName] = struct{}{}
			}
		case "fullName":
			if _, ok := fieldSeen[user.FieldFullName]; !ok {
				selectedFields = append(selectedFields, user.FieldFullName)
				fieldSeen[user.FieldFullName] = struct{}{}
			}
		case "passwdSalt":
			if _, ok := fieldSeen[user.FieldPasswdSalt]; !ok {
				selectedFields = append(selectedFields, user.FieldPasswdSalt)
				fieldSeen[user.FieldPasswdSalt] = struct{}{}
			}
		case "passwdHashAlgo":
			if _, ok := fieldSeen[user.FieldPasswdHashAlgo]; !ok {
				selectedFields = append(selectedFields, user.FieldPasswdHashAlgo)
				fieldSeen[user.FieldPasswdHashAlgo] = struct{}{}
			}
		case "passwd":
			if _, ok := fieldSeen[user.FieldPasswd]; !ok {
				selectedFields = append(selectedFields, user.FieldPasswd)
				fieldSeen[user.FieldPasswd] = struct{}{}
			}
		case "language":
			if _, ok := fieldSeen[user.FieldLanguage]; !ok {
				selectedFields = append(selectedFields, user.FieldLanguage)
				fieldSeen[user.FieldLanguage] = struct{}{}
			}
		case "loginName":
			if _, ok := fieldSeen[user.FieldLoginName]; !ok {
				selectedFields = append(selectedFields, user.FieldLoginName)
				fieldSeen[user.FieldLoginName] = struct{}{}
			}
		case "loginSource":
			if _, ok := fieldSeen[user.FieldLoginSource]; !ok {
				selectedFields = append(selectedFields, user.FieldLoginSource)
				fieldSeen[user.FieldLoginSource] = struct{}{}
			}
		case "loginType":
			if _, ok := fieldSeen[user.FieldLoginType]; !ok {
				selectedFields = append(selectedFields, user.FieldLoginType)
				fieldSeen[user.FieldLoginType] = struct{}{}
			}
		case "isRestricted":
			if _, ok := fieldSeen[user.FieldIsRestricted]; !ok {
				selectedFields = append(selectedFields, user.FieldIsRestricted)
				fieldSeen[user.FieldIsRestricted] = struct{}{}
			}
		case "isActive":
			if _, ok := fieldSeen[user.FieldIsActive]; !ok {
				selectedFields = append(selectedFields, user.FieldIsActive)
				fieldSeen[user.FieldIsActive] = struct{}{}
			}
		case "prohibitLogin":
			if _, ok := fieldSeen[user.FieldProhibitLogin]; !ok {
				selectedFields = append(selectedFields, user.FieldProhibitLogin)
				fieldSeen[user.FieldProhibitLogin] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[user.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, user.FieldCreateTime)
				fieldSeen[user.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[user.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdateTime)
				fieldSeen[user.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (uas *UserAuthSourceQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserAuthSourceQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return uas, nil
	}
	if err := uas.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return uas, nil
}

func (uas *UserAuthSourceQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userauthsource.Columns))
		selectedFields = []string{userauthsource.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "userID":
			if _, ok := fieldSeen[userauthsource.FieldUserID]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldUserID)
				fieldSeen[userauthsource.FieldUserID] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[userauthsource.FieldToken]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldToken)
				fieldSeen[userauthsource.FieldToken] = struct{}{}
			}
		case "channel":
			if _, ok := fieldSeen[userauthsource.FieldChannel]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldChannel)
				fieldSeen[userauthsource.FieldChannel] = struct{}{}
			}
		case "device":
			if _, ok := fieldSeen[userauthsource.FieldDevice]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldDevice)
				fieldSeen[userauthsource.FieldDevice] = struct{}{}
			}
		case "deviceDetail":
			if _, ok := fieldSeen[userauthsource.FieldDeviceDetail]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldDeviceDetail)
				fieldSeen[userauthsource.FieldDeviceDetail] = struct{}{}
			}
		case "clientIP":
			if _, ok := fieldSeen[userauthsource.FieldClientIP]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldClientIP)
				fieldSeen[userauthsource.FieldClientIP] = struct{}{}
			}
		case "remoteIP":
			if _, ok := fieldSeen[userauthsource.FieldRemoteIP]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldRemoteIP)
				fieldSeen[userauthsource.FieldRemoteIP] = struct{}{}
			}
		case "snapshot":
			if _, ok := fieldSeen[userauthsource.FieldSnapshot]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldSnapshot)
				fieldSeen[userauthsource.FieldSnapshot] = struct{}{}
			}
		case "loginName":
			if _, ok := fieldSeen[userauthsource.FieldLoginName]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldLoginName)
				fieldSeen[userauthsource.FieldLoginName] = struct{}{}
			}
		case "loginSource":
			if _, ok := fieldSeen[userauthsource.FieldLoginSource]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldLoginSource)
				fieldSeen[userauthsource.FieldLoginSource] = struct{}{}
			}
		case "loginType":
			if _, ok := fieldSeen[userauthsource.FieldLoginType]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldLoginType)
				fieldSeen[userauthsource.FieldLoginType] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[userauthsource.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldCreateTime)
				fieldSeen[userauthsource.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[userauthsource.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, userauthsource.FieldUpdateTime)
				fieldSeen[userauthsource.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		uas.Select(selectedFields...)
	}
	return nil
}

type userauthsourcePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserAuthSourcePaginateOption
}

func newUserAuthSourcePaginateArgs(rv map[string]any) *userauthsourcePaginateArgs {
	args := &userauthsourcePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (urr *UserRelatedRoleQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserRelatedRoleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return urr, nil
	}
	if err := urr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return urr, nil
}

func (urr *UserRelatedRoleQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userrelatedrole.Columns))
		selectedFields = []string{userrelatedrole.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "userID":
			if _, ok := fieldSeen[userrelatedrole.FieldUserID]; !ok {
				selectedFields = append(selectedFields, userrelatedrole.FieldUserID)
				fieldSeen[userrelatedrole.FieldUserID] = struct{}{}
			}
		case "roleID":
			if _, ok := fieldSeen[userrelatedrole.FieldRoleID]; !ok {
				selectedFields = append(selectedFields, userrelatedrole.FieldRoleID)
				fieldSeen[userrelatedrole.FieldRoleID] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[userrelatedrole.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, userrelatedrole.FieldCreateTime)
				fieldSeen[userrelatedrole.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[userrelatedrole.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, userrelatedrole.FieldUpdateTime)
				fieldSeen[userrelatedrole.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		urr.Select(selectedFields...)
	}
	return nil
}

type userrelatedrolePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserRelatedRolePaginateOption
}

func newUserRelatedRolePaginateArgs(rv map[string]any) *userrelatedrolePaginateArgs {
	args := &userrelatedrolePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ur *UserRoleQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserRoleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ur, nil
	}
	if err := ur.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ur, nil
}

func (ur *UserRoleQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userrole.Columns))
		selectedFields = []string{userrole.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "roleName":
			if _, ok := fieldSeen[userrole.FieldRoleName]; !ok {
				selectedFields = append(selectedFields, userrole.FieldRoleName)
				fieldSeen[userrole.FieldRoleName] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[userrole.FieldState]; !ok {
				selectedFields = append(selectedFields, userrole.FieldState)
				fieldSeen[userrole.FieldState] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[userrole.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, userrole.FieldCreateTime)
				fieldSeen[userrole.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[userrole.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, userrole.FieldUpdateTime)
				fieldSeen[userrole.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ur.Select(selectedFields...)
	}
	return nil
}

type userrolePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserRolePaginateOption
}

func newUserRolePaginateArgs(rv map[string]any) *userrolePaginateArgs {
	args := &userrolePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (w *WakatimeQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return w, nil
	}
	if err := w.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return w, nil
}

func (w *WakatimeQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(wakatime.Columns))
		selectedFields = []string{wakatime.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "userID":
			if _, ok := fieldSeen[wakatime.FieldUserID]; !ok {
				selectedFields = append(selectedFields, wakatime.FieldUserID)
				fieldSeen[wakatime.FieldUserID] = struct{}{}
			}
		case "key":
			if _, ok := fieldSeen[wakatime.FieldKey]; !ok {
				selectedFields = append(selectedFields, wakatime.FieldKey)
				fieldSeen[wakatime.FieldKey] = struct{}{}
			}
		case "api":
			if _, ok := fieldSeen[wakatime.FieldAPI]; !ok {
				selectedFields = append(selectedFields, wakatime.FieldAPI)
				fieldSeen[wakatime.FieldAPI] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[wakatime.FieldState]; !ok {
				selectedFields = append(selectedFields, wakatime.FieldState)
				fieldSeen[wakatime.FieldState] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[wakatime.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, wakatime.FieldCreateTime)
				fieldSeen[wakatime.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[wakatime.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, wakatime.FieldUpdateTime)
				fieldSeen[wakatime.FieldUpdateTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		w.Select(selectedFields...)
	}
	return nil
}

type wakatimePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimePaginateOption
}

func newWakatimePaginateArgs(rv map[string]any) *wakatimePaginateArgs {
	args := &wakatimePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wc *WakatimeCategoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeCategoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wc, nil
	}
	if err := wc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wc, nil
}

func (wc *WakatimeCategoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(wakatimecategory.Columns))
		selectedFields = []string{wakatimecategory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createTime":
			if _, ok := fieldSeen[wakatimecategory.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, wakatimecategory.FieldCreateTime)
				fieldSeen[wakatimecategory.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[wakatimecategory.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, wakatimecategory.FieldUpdateTime)
				fieldSeen[wakatimecategory.FieldUpdateTime] = struct{}{}
			}
		case "wakatimeID":
			if _, ok := fieldSeen[wakatimecategory.FieldWakatimeID]; !ok {
				selectedFields = append(selectedFields, wakatimecategory.FieldWakatimeID)
				fieldSeen[wakatimecategory.FieldWakatimeID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[wakatimecategory.FieldUserID]; !ok {
				selectedFields = append(selectedFields, wakatimecategory.FieldUserID)
				fieldSeen[wakatimecategory.FieldUserID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[wakatimecategory.FieldName]; !ok {
				selectedFields = append(selectedFields, wakatimecategory.FieldName)
				fieldSeen[wakatimecategory.FieldName] = struct{}{}
			}
		case "totalSeconds":
			if _, ok := fieldSeen[wakatimecategory.FieldTotalSeconds]; !ok {
				selectedFields = append(selectedFields, wakatimecategory.FieldTotalSeconds)
				fieldSeen[wakatimecategory.FieldTotalSeconds] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		wc.Select(selectedFields...)
	}
	return nil
}

type wakatimecategoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeCategoryPaginateOption
}

func newWakatimeCategoryPaginateArgs(rv map[string]any) *wakatimecategoryPaginateArgs {
	args := &wakatimecategoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wd *WakatimeDependencyQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeDependencyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wd, nil
	}
	if err := wd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wd, nil
}

func (wd *WakatimeDependencyQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(wakatimedependency.Columns))
		selectedFields = []string{wakatimedependency.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createTime":
			if _, ok := fieldSeen[wakatimedependency.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, wakatimedependency.FieldCreateTime)
				fieldSeen[wakatimedependency.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[wakatimedependency.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, wakatimedependency.FieldUpdateTime)
				fieldSeen[wakatimedependency.FieldUpdateTime] = struct{}{}
			}
		case "wakatimeID":
			if _, ok := fieldSeen[wakatimedependency.FieldWakatimeID]; !ok {
				selectedFields = append(selectedFields, wakatimedependency.FieldWakatimeID)
				fieldSeen[wakatimedependency.FieldWakatimeID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[wakatimedependency.FieldUserID]; !ok {
				selectedFields = append(selectedFields, wakatimedependency.FieldUserID)
				fieldSeen[wakatimedependency.FieldUserID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[wakatimedependency.FieldName]; !ok {
				selectedFields = append(selectedFields, wakatimedependency.FieldName)
				fieldSeen[wakatimedependency.FieldName] = struct{}{}
			}
		case "totalSeconds":
			if _, ok := fieldSeen[wakatimedependency.FieldTotalSeconds]; !ok {
				selectedFields = append(selectedFields, wakatimedependency.FieldTotalSeconds)
				fieldSeen[wakatimedependency.FieldTotalSeconds] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		wd.Select(selectedFields...)
	}
	return nil
}

type wakatimedependencyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeDependencyPaginateOption
}

func newWakatimeDependencyPaginateArgs(rv map[string]any) *wakatimedependencyPaginateArgs {
	args := &wakatimedependencyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wd *WakatimeDurationQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeDurationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wd, nil
	}
	if err := wd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wd, nil
}

func (wd *WakatimeDurationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimedurationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeDurationPaginateOption
}

func newWakatimeDurationPaginateArgs(rv map[string]any) *wakatimedurationPaginateArgs {
	args := &wakatimedurationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (we *WakatimeEditorQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeEditorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return we, nil
	}
	if err := we.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return we, nil
}

func (we *WakatimeEditorQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimeeditorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeEditorPaginateOption
}

func newWakatimeEditorPaginateArgs(rv map[string]any) *wakatimeeditorPaginateArgs {
	args := &wakatimeeditorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (we *WakatimeEntityQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeEntityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return we, nil
	}
	if err := we.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return we, nil
}

func (we *WakatimeEntityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimeentityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeEntityPaginateOption
}

func newWakatimeEntityPaginateArgs(rv map[string]any) *wakatimeentityPaginateArgs {
	args := &wakatimeentityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wgt *WakatimeGrandTotalQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeGrandTotalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wgt, nil
	}
	if err := wgt.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wgt, nil
}

func (wgt *WakatimeGrandTotalQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimegrandtotalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeGrandTotalPaginateOption
}

func newWakatimeGrandTotalPaginateArgs(rv map[string]any) *wakatimegrandtotalPaginateArgs {
	args := &wakatimegrandtotalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (whb *WakatimeHeartBeatQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeHeartBeatQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return whb, nil
	}
	if err := whb.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return whb, nil
}

func (whb *WakatimeHeartBeatQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimeheartbeatPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeHeartBeatPaginateOption
}

func newWakatimeHeartBeatPaginateArgs(rv map[string]any) *wakatimeheartbeatPaginateArgs {
	args := &wakatimeheartbeatPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wl *WakatimeLanguageQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeLanguageQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wl, nil
	}
	if err := wl.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wl, nil
}

func (wl *WakatimeLanguageQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimelanguagePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeLanguagePaginateOption
}

func newWakatimeLanguagePaginateArgs(rv map[string]any) *wakatimelanguagePaginateArgs {
	args := &wakatimelanguagePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wp *WakatimeProjectQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeProjectQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wp, nil
	}
	if err := wp.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wp, nil
}

func (wp *WakatimeProjectQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimeprojectPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeProjectPaginateOption
}

func newWakatimeProjectPaginateArgs(rv map[string]any) *wakatimeprojectPaginateArgs {
	args := &wakatimeprojectPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wpd *WakatimeProjectDurationQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeProjectDurationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wpd, nil
	}
	if err := wpd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wpd, nil
}

func (wpd *WakatimeProjectDurationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimeprojectdurationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeProjectDurationPaginateOption
}

func newWakatimeProjectDurationPaginateArgs(rv map[string]any) *wakatimeprojectdurationPaginateArgs {
	args := &wakatimeprojectdurationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wpi *WakatimeProjectInfoQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeProjectInfoQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wpi, nil
	}
	if err := wpi.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wpi, nil
}

func (wpi *WakatimeProjectInfoQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimeprojectinfoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeProjectInfoPaginateOption
}

func newWakatimeProjectInfoPaginateArgs(rv map[string]any) *wakatimeprojectinfoPaginateArgs {
	args := &wakatimeprojectinfoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ws *WakatimeSystemQuery) CollectFields(ctx context.Context, satisfies ...string) (*WakatimeSystemQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ws, nil
	}
	if err := ws.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ws, nil
}

func (ws *WakatimeSystemQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type wakatimesystemPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WakatimeSystemPaginateOption
}

func newWakatimeSystemPaginateArgs(rv map[string]any) *wakatimesystemPaginateArgs {
	args := &wakatimesystemPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if condition is enabled (Node/Nodes) and it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond string) []string {
	if len(satisfies) == 0 {
		return satisfies
	}
	for _, s := range satisfies {
		if typeCond == s {
			return satisfies
		}
	}
	return append(satisfies, typeCond)
}
