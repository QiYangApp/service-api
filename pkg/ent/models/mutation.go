// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"ent/enums/state"
	"ent/models/accesstoken"
	"ent/models/accounts"
	"ent/models/memberrolerelatedpermission"
	"ent/models/permissiongroup"
	"ent/models/permissionrelatedrouter"
	"ent/models/predicate"
	"ent/models/router"
	"ent/models/source"
	"ent/models/sourcedata"
	"ent/models/user"
	"ent/models/userauthsource"
	"ent/models/userrelatedrole"
	"ent/models/userrole"
	"ent/models/wakatime"
	"ent/models/wakatimecategory"
	"ent/models/wakatimedependency"
	"ent/types/auth"
	"ent/utils/timeutil"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessToken                 = "AccessToken"
	TypeAccounts                    = "Accounts"
	TypeMemberRoleRelatedPermission = "MemberRoleRelatedPermission"
	TypePermissionGroup             = "PermissionGroup"
	TypePermissionRelatedRouter     = "PermissionRelatedRouter"
	TypeRouter                      = "Router"
	TypeSource                      = "Source"
	TypeSourceData                  = "SourceData"
	TypeUser                        = "User"
	TypeUserAuthSource              = "UserAuthSource"
	TypeUserRelatedRole             = "UserRelatedRole"
	TypeUserRole                    = "UserRole"
	TypeWakatime                    = "Wakatime"
	TypeWakatimeCategory            = "WakatimeCategory"
	TypeWakatimeDependency          = "WakatimeDependency"
	TypeWakatimeDuration            = "WakatimeDuration"
	TypeWakatimeEditor              = "WakatimeEditor"
	TypeWakatimeEntity              = "WakatimeEntity"
	TypeWakatimeGrandTotal          = "WakatimeGrandTotal"
	TypeWakatimeHeartBeat           = "WakatimeHeartBeat"
	TypeWakatimeLanguage            = "WakatimeLanguage"
	TypeWakatimeProject             = "WakatimeProject"
	TypeWakatimeProjectDuration     = "WakatimeProjectDuration"
	TypeWakatimeProjectInfo         = "WakatimeProjectInfo"
	TypeWakatimeSystem              = "WakatimeSystem"
)

// AccessTokenMutation represents an operation that mutates the AccessToken nodes in the graph.
type AccessTokenMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	user_id             *int
	adduser_id          *int
	name                *string
	token               *string
	token_hash          *string
	token_salt          *string
	token_last_eight    *string
	scope               *string
	has_recent_activity *string
	has_used            *string
	create_time         *timeutil.TimeStamp
	addcreate_time      *timeutil.TimeStamp
	update_time         *timeutil.TimeStamp
	addupdate_time      *timeutil.TimeStamp
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*AccessToken, error)
	predicates          []predicate.AccessToken
}

var _ ent.Mutation = (*AccessTokenMutation)(nil)

// accesstokenOption allows management of the mutation configuration using functional options.
type accesstokenOption func(*AccessTokenMutation)

// newAccessTokenMutation creates new mutation for the AccessToken entity.
func newAccessTokenMutation(c config, op Op, opts ...accesstokenOption) *AccessTokenMutation {
	m := &AccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessTokenID sets the ID field of the mutation.
func withAccessTokenID(id int64) accesstokenOption {
	return func(m *AccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessToken
		)
		m.oldValue = func(ctx context.Context) (*AccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessToken sets the old AccessToken of the mutation.
func withAccessToken(node *AccessToken) accesstokenOption {
	return func(m *AccessTokenMutation) {
		m.oldValue = func(context.Context) (*AccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccessToken entities.
func (m *AccessTokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessTokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessTokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AccessTokenMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccessTokenMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AccessTokenMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccessTokenMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccessTokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetName sets the "name" field.
func (m *AccessTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccessTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccessTokenMutation) ResetName() {
	m.name = nil
}

// SetToken sets the "token" field.
func (m *AccessTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AccessTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AccessTokenMutation) ResetToken() {
	m.token = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *AccessTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *AccessTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *AccessTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetTokenSalt sets the "token_salt" field.
func (m *AccessTokenMutation) SetTokenSalt(s string) {
	m.token_salt = &s
}

// TokenSalt returns the value of the "token_salt" field in the mutation.
func (m *AccessTokenMutation) TokenSalt() (r string, exists bool) {
	v := m.token_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenSalt returns the old "token_salt" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldTokenSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenSalt: %w", err)
	}
	return oldValue.TokenSalt, nil
}

// ResetTokenSalt resets all changes to the "token_salt" field.
func (m *AccessTokenMutation) ResetTokenSalt() {
	m.token_salt = nil
}

// SetTokenLastEight sets the "token_last_eight" field.
func (m *AccessTokenMutation) SetTokenLastEight(s string) {
	m.token_last_eight = &s
}

// TokenLastEight returns the value of the "token_last_eight" field in the mutation.
func (m *AccessTokenMutation) TokenLastEight() (r string, exists bool) {
	v := m.token_last_eight
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenLastEight returns the old "token_last_eight" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldTokenLastEight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenLastEight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenLastEight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenLastEight: %w", err)
	}
	return oldValue.TokenLastEight, nil
}

// ResetTokenLastEight resets all changes to the "token_last_eight" field.
func (m *AccessTokenMutation) ResetTokenLastEight() {
	m.token_last_eight = nil
}

// SetScope sets the "scope" field.
func (m *AccessTokenMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AccessTokenMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *AccessTokenMutation) ResetScope() {
	m.scope = nil
}

// SetHasRecentActivity sets the "has_recent_activity" field.
func (m *AccessTokenMutation) SetHasRecentActivity(s string) {
	m.has_recent_activity = &s
}

// HasRecentActivity returns the value of the "has_recent_activity" field in the mutation.
func (m *AccessTokenMutation) HasRecentActivity() (r string, exists bool) {
	v := m.has_recent_activity
	if v == nil {
		return
	}
	return *v, true
}

// OldHasRecentActivity returns the old "has_recent_activity" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldHasRecentActivity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasRecentActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasRecentActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasRecentActivity: %w", err)
	}
	return oldValue.HasRecentActivity, nil
}

// ResetHasRecentActivity resets all changes to the "has_recent_activity" field.
func (m *AccessTokenMutation) ResetHasRecentActivity() {
	m.has_recent_activity = nil
}

// SetHasUsed sets the "has_used" field.
func (m *AccessTokenMutation) SetHasUsed(s string) {
	m.has_used = &s
}

// HasUsed returns the value of the "has_used" field in the mutation.
func (m *AccessTokenMutation) HasUsed() (r string, exists bool) {
	v := m.has_used
	if v == nil {
		return
	}
	return *v, true
}

// OldHasUsed returns the old "has_used" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldHasUsed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasUsed: %w", err)
	}
	return oldValue.HasUsed, nil
}

// ResetHasUsed resets all changes to the "has_used" field.
func (m *AccessTokenMutation) ResetHasUsed() {
	m.has_used = nil
}

// SetCreateTime sets the "create_time" field.
func (m *AccessTokenMutation) SetCreateTime(ts timeutil.TimeStamp) {
	m.create_time = &ts
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccessTokenMutation) CreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldCreateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds ts to the "create_time" field.
func (m *AccessTokenMutation) AddCreateTime(ts timeutil.TimeStamp) {
	if m.addcreate_time != nil {
		*m.addcreate_time += ts
	} else {
		m.addcreate_time = &ts
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *AccessTokenMutation) AddedCreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccessTokenMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccessTokenMutation) SetUpdateTime(ts timeutil.TimeStamp) {
	m.update_time = &ts
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccessTokenMutation) UpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUpdateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds ts to the "update_time" field.
func (m *AccessTokenMutation) AddUpdateTime(ts timeutil.TimeStamp) {
	if m.addupdate_time != nil {
		*m.addupdate_time += ts
	} else {
		m.addupdate_time = &ts
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *AccessTokenMutation) AddedUpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccessTokenMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// Where appends a list predicates to the AccessTokenMutation builder.
func (m *AccessTokenMutation) Where(ps ...predicate.AccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessToken).
func (m *AccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user_id != nil {
		fields = append(fields, accesstoken.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, accesstoken.FieldName)
	}
	if m.token != nil {
		fields = append(fields, accesstoken.FieldToken)
	}
	if m.token_hash != nil {
		fields = append(fields, accesstoken.FieldTokenHash)
	}
	if m.token_salt != nil {
		fields = append(fields, accesstoken.FieldTokenSalt)
	}
	if m.token_last_eight != nil {
		fields = append(fields, accesstoken.FieldTokenLastEight)
	}
	if m.scope != nil {
		fields = append(fields, accesstoken.FieldScope)
	}
	if m.has_recent_activity != nil {
		fields = append(fields, accesstoken.FieldHasRecentActivity)
	}
	if m.has_used != nil {
		fields = append(fields, accesstoken.FieldHasUsed)
	}
	if m.create_time != nil {
		fields = append(fields, accesstoken.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, accesstoken.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accesstoken.FieldUserID:
		return m.UserID()
	case accesstoken.FieldName:
		return m.Name()
	case accesstoken.FieldToken:
		return m.Token()
	case accesstoken.FieldTokenHash:
		return m.TokenHash()
	case accesstoken.FieldTokenSalt:
		return m.TokenSalt()
	case accesstoken.FieldTokenLastEight:
		return m.TokenLastEight()
	case accesstoken.FieldScope:
		return m.Scope()
	case accesstoken.FieldHasRecentActivity:
		return m.HasRecentActivity()
	case accesstoken.FieldHasUsed:
		return m.HasUsed()
	case accesstoken.FieldCreateTime:
		return m.CreateTime()
	case accesstoken.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accesstoken.FieldUserID:
		return m.OldUserID(ctx)
	case accesstoken.FieldName:
		return m.OldName(ctx)
	case accesstoken.FieldToken:
		return m.OldToken(ctx)
	case accesstoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case accesstoken.FieldTokenSalt:
		return m.OldTokenSalt(ctx)
	case accesstoken.FieldTokenLastEight:
		return m.OldTokenLastEight(ctx)
	case accesstoken.FieldScope:
		return m.OldScope(ctx)
	case accesstoken.FieldHasRecentActivity:
		return m.OldHasRecentActivity(ctx)
	case accesstoken.FieldHasUsed:
		return m.OldHasUsed(ctx)
	case accesstoken.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case accesstoken.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accesstoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accesstoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case accesstoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case accesstoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case accesstoken.FieldTokenSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenSalt(v)
		return nil
	case accesstoken.FieldTokenLastEight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenLastEight(v)
		return nil
	case accesstoken.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case accesstoken.FieldHasRecentActivity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasRecentActivity(v)
		return nil
	case accesstoken.FieldHasUsed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasUsed(v)
		return nil
	case accesstoken.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case accesstoken.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessTokenMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, accesstoken.FieldUserID)
	}
	if m.addcreate_time != nil {
		fields = append(fields, accesstoken.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, accesstoken.FieldUpdateTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accesstoken.FieldUserID:
		return m.AddedUserID()
	case accesstoken.FieldCreateTime:
		return m.AddedCreateTime()
	case accesstoken.FieldUpdateTime:
		return m.AddedUpdateTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accesstoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case accesstoken.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case accesstoken.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessTokenMutation) ResetField(name string) error {
	switch name {
	case accesstoken.FieldUserID:
		m.ResetUserID()
		return nil
	case accesstoken.FieldName:
		m.ResetName()
		return nil
	case accesstoken.FieldToken:
		m.ResetToken()
		return nil
	case accesstoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case accesstoken.FieldTokenSalt:
		m.ResetTokenSalt()
		return nil
	case accesstoken.FieldTokenLastEight:
		m.ResetTokenLastEight()
		return nil
	case accesstoken.FieldScope:
		m.ResetScope()
		return nil
	case accesstoken.FieldHasRecentActivity:
		m.ResetHasRecentActivity()
		return nil
	case accesstoken.FieldHasUsed:
		m.ResetHasUsed()
		return nil
	case accesstoken.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case accesstoken.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccessToken edge %s", name)
}

// AccountsMutation represents an operation that mutates the Accounts nodes in the graph.
type AccountsMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	user_id        *int
	adduser_id     *int
	account        *string
	_type          *uint8
	add_type       *int8
	desc           *string
	is_activated   *bool
	is_primary     *bool
	create_time    *timeutil.TimeStamp
	addcreate_time *timeutil.TimeStamp
	update_time    *timeutil.TimeStamp
	addupdate_time *timeutil.TimeStamp
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Accounts, error)
	predicates     []predicate.Accounts
}

var _ ent.Mutation = (*AccountsMutation)(nil)

// accountsOption allows management of the mutation configuration using functional options.
type accountsOption func(*AccountsMutation)

// newAccountsMutation creates new mutation for the Accounts entity.
func newAccountsMutation(c config, op Op, opts ...accountsOption) *AccountsMutation {
	m := &AccountsMutation{
		config:        c,
		op:            op,
		typ:           TypeAccounts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountsID sets the ID field of the mutation.
func withAccountsID(id int64) accountsOption {
	return func(m *AccountsMutation) {
		var (
			err   error
			once  sync.Once
			value *Accounts
		)
		m.oldValue = func(ctx context.Context) (*Accounts, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Accounts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccounts sets the old Accounts of the mutation.
func withAccounts(node *Accounts) accountsOption {
	return func(m *AccountsMutation) {
		m.oldValue = func(context.Context) (*Accounts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Accounts entities.
func (m *AccountsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Accounts.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AccountsMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountsMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *AccountsMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccountsMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountsMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetAccount sets the "account" field.
func (m *AccountsMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountsMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountsMutation) ResetAccount() {
	m.account = nil
}

// SetType sets the "type" field.
func (m *AccountsMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountsMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *AccountsMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AccountsMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *AccountsMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetDesc sets the "desc" field.
func (m *AccountsMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AccountsMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *AccountsMutation) ResetDesc() {
	m.desc = nil
}

// SetIsActivated sets the "is_activated" field.
func (m *AccountsMutation) SetIsActivated(b bool) {
	m.is_activated = &b
}

// IsActivated returns the value of the "is_activated" field in the mutation.
func (m *AccountsMutation) IsActivated() (r bool, exists bool) {
	v := m.is_activated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActivated returns the old "is_activated" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldIsActivated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActivated: %w", err)
	}
	return oldValue.IsActivated, nil
}

// ResetIsActivated resets all changes to the "is_activated" field.
func (m *AccountsMutation) ResetIsActivated() {
	m.is_activated = nil
}

// SetIsPrimary sets the "is_primary" field.
func (m *AccountsMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *AccountsMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *AccountsMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetCreateTime sets the "create_time" field.
func (m *AccountsMutation) SetCreateTime(ts timeutil.TimeStamp) {
	m.create_time = &ts
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountsMutation) CreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldCreateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds ts to the "create_time" field.
func (m *AccountsMutation) AddCreateTime(ts timeutil.TimeStamp) {
	if m.addcreate_time != nil {
		*m.addcreate_time += ts
	} else {
		m.addcreate_time = &ts
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *AccountsMutation) AddedCreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountsMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountsMutation) SetUpdateTime(ts timeutil.TimeStamp) {
	m.update_time = &ts
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountsMutation) UpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldUpdateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds ts to the "update_time" field.
func (m *AccountsMutation) AddUpdateTime(ts timeutil.TimeStamp) {
	if m.addupdate_time != nil {
		*m.addupdate_time += ts
	} else {
		m.addupdate_time = &ts
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *AccountsMutation) AddedUpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountsMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// Where appends a list predicates to the AccountsMutation builder.
func (m *AccountsMutation) Where(ps ...predicate.Accounts) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Accounts, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Accounts).
func (m *AccountsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user_id != nil {
		fields = append(fields, accounts.FieldUserID)
	}
	if m.account != nil {
		fields = append(fields, accounts.FieldAccount)
	}
	if m._type != nil {
		fields = append(fields, accounts.FieldType)
	}
	if m.desc != nil {
		fields = append(fields, accounts.FieldDesc)
	}
	if m.is_activated != nil {
		fields = append(fields, accounts.FieldIsActivated)
	}
	if m.is_primary != nil {
		fields = append(fields, accounts.FieldIsPrimary)
	}
	if m.create_time != nil {
		fields = append(fields, accounts.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, accounts.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accounts.FieldUserID:
		return m.UserID()
	case accounts.FieldAccount:
		return m.Account()
	case accounts.FieldType:
		return m.GetType()
	case accounts.FieldDesc:
		return m.Desc()
	case accounts.FieldIsActivated:
		return m.IsActivated()
	case accounts.FieldIsPrimary:
		return m.IsPrimary()
	case accounts.FieldCreateTime:
		return m.CreateTime()
	case accounts.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accounts.FieldUserID:
		return m.OldUserID(ctx)
	case accounts.FieldAccount:
		return m.OldAccount(ctx)
	case accounts.FieldType:
		return m.OldType(ctx)
	case accounts.FieldDesc:
		return m.OldDesc(ctx)
	case accounts.FieldIsActivated:
		return m.OldIsActivated(ctx)
	case accounts.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case accounts.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case accounts.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Accounts field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accounts.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accounts.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case accounts.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case accounts.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case accounts.FieldIsActivated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActivated(v)
		return nil
	case accounts.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case accounts.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case accounts.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Accounts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountsMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, accounts.FieldUserID)
	}
	if m.add_type != nil {
		fields = append(fields, accounts.FieldType)
	}
	if m.addcreate_time != nil {
		fields = append(fields, accounts.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, accounts.FieldUpdateTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accounts.FieldUserID:
		return m.AddedUserID()
	case accounts.FieldType:
		return m.AddedType()
	case accounts.FieldCreateTime:
		return m.AddedCreateTime()
	case accounts.FieldUpdateTime:
		return m.AddedUpdateTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accounts.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case accounts.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case accounts.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case accounts.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Accounts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Accounts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountsMutation) ResetField(name string) error {
	switch name {
	case accounts.FieldUserID:
		m.ResetUserID()
		return nil
	case accounts.FieldAccount:
		m.ResetAccount()
		return nil
	case accounts.FieldType:
		m.ResetType()
		return nil
	case accounts.FieldDesc:
		m.ResetDesc()
		return nil
	case accounts.FieldIsActivated:
		m.ResetIsActivated()
		return nil
	case accounts.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case accounts.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case accounts.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Accounts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Accounts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Accounts edge %s", name)
}

// MemberRoleRelatedPermissionMutation represents an operation that mutates the MemberRoleRelatedPermission nodes in the graph.
type MemberRoleRelatedPermissionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	role_id             *uuid.UUID
	permission_group_id *uuid.UUID
	create_time         *time.Time
	update_time         *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*MemberRoleRelatedPermission, error)
	predicates          []predicate.MemberRoleRelatedPermission
}

var _ ent.Mutation = (*MemberRoleRelatedPermissionMutation)(nil)

// memberrolerelatedpermissionOption allows management of the mutation configuration using functional options.
type memberrolerelatedpermissionOption func(*MemberRoleRelatedPermissionMutation)

// newMemberRoleRelatedPermissionMutation creates new mutation for the MemberRoleRelatedPermission entity.
func newMemberRoleRelatedPermissionMutation(c config, op Op, opts ...memberrolerelatedpermissionOption) *MemberRoleRelatedPermissionMutation {
	m := &MemberRoleRelatedPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberRoleRelatedPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberRoleRelatedPermissionID sets the ID field of the mutation.
func withMemberRoleRelatedPermissionID(id int) memberrolerelatedpermissionOption {
	return func(m *MemberRoleRelatedPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberRoleRelatedPermission
		)
		m.oldValue = func(ctx context.Context) (*MemberRoleRelatedPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberRoleRelatedPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberRoleRelatedPermission sets the old MemberRoleRelatedPermission of the mutation.
func withMemberRoleRelatedPermission(node *MemberRoleRelatedPermission) memberrolerelatedpermissionOption {
	return func(m *MemberRoleRelatedPermissionMutation) {
		m.oldValue = func(context.Context) (*MemberRoleRelatedPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberRoleRelatedPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberRoleRelatedPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberRoleRelatedPermission entities.
func (m *MemberRoleRelatedPermissionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberRoleRelatedPermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberRoleRelatedPermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberRoleRelatedPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *MemberRoleRelatedPermissionMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *MemberRoleRelatedPermissionMutation) ResetRoleID() {
	m.role_id = nil
}

// SetPermissionGroupID sets the "permission_group_id" field.
func (m *MemberRoleRelatedPermissionMutation) SetPermissionGroupID(u uuid.UUID) {
	m.permission_group_id = &u
}

// PermissionGroupID returns the value of the "permission_group_id" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) PermissionGroupID() (r uuid.UUID, exists bool) {
	v := m.permission_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionGroupID returns the old "permission_group_id" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldPermissionGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionGroupID: %w", err)
	}
	return oldValue.PermissionGroupID, nil
}

// ResetPermissionGroupID resets all changes to the "permission_group_id" field.
func (m *MemberRoleRelatedPermissionMutation) ResetPermissionGroupID() {
	m.permission_group_id = nil
}

// SetCreateTime sets the "create_time" field.
func (m *MemberRoleRelatedPermissionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MemberRoleRelatedPermissionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MemberRoleRelatedPermissionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MemberRoleRelatedPermissionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MemberRoleRelatedPermission entity.
// If the MemberRoleRelatedPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberRoleRelatedPermissionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MemberRoleRelatedPermissionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the MemberRoleRelatedPermissionMutation builder.
func (m *MemberRoleRelatedPermissionMutation) Where(ps ...predicate.MemberRoleRelatedPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberRoleRelatedPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberRoleRelatedPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberRoleRelatedPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberRoleRelatedPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberRoleRelatedPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberRoleRelatedPermission).
func (m *MemberRoleRelatedPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberRoleRelatedPermissionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.role_id != nil {
		fields = append(fields, memberrolerelatedpermission.FieldRoleID)
	}
	if m.permission_group_id != nil {
		fields = append(fields, memberrolerelatedpermission.FieldPermissionGroupID)
	}
	if m.create_time != nil {
		fields = append(fields, memberrolerelatedpermission.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, memberrolerelatedpermission.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberRoleRelatedPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberrolerelatedpermission.FieldRoleID:
		return m.RoleID()
	case memberrolerelatedpermission.FieldPermissionGroupID:
		return m.PermissionGroupID()
	case memberrolerelatedpermission.FieldCreateTime:
		return m.CreateTime()
	case memberrolerelatedpermission.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberRoleRelatedPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberrolerelatedpermission.FieldRoleID:
		return m.OldRoleID(ctx)
	case memberrolerelatedpermission.FieldPermissionGroupID:
		return m.OldPermissionGroupID(ctx)
	case memberrolerelatedpermission.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case memberrolerelatedpermission.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown MemberRoleRelatedPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRoleRelatedPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberrolerelatedpermission.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case memberrolerelatedpermission.FieldPermissionGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionGroupID(v)
		return nil
	case memberrolerelatedpermission.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case memberrolerelatedpermission.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown MemberRoleRelatedPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberRoleRelatedPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberRoleRelatedPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MemberRoleRelatedPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberRoleRelatedPermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberRoleRelatedPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MemberRoleRelatedPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ResetField(name string) error {
	switch name {
	case memberrolerelatedpermission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case memberrolerelatedpermission.FieldPermissionGroupID:
		m.ResetPermissionGroupID()
		return nil
	case memberrolerelatedpermission.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case memberrolerelatedpermission.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown MemberRoleRelatedPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberRoleRelatedPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberRoleRelatedPermissionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberRoleRelatedPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberRoleRelatedPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberRoleRelatedPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberRoleRelatedPermissionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MemberRoleRelatedPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberRoleRelatedPermissionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MemberRoleRelatedPermission edge %s", name)
}

// PermissionGroupMutation represents an operation that mutates the PermissionGroup nodes in the graph.
type PermissionGroupMutation struct {
	config
	op              Op
	typ             string
	id              *int
	permission_name *string
	ioc             *string
	sort            *int32
	addsort         *int32
	left            *int32
	addleft         *int32
	right           *int32
	addright        *int32
	state           *state.SwitchState
	addstate        *state.SwitchState
	create_time     *timeutil.TimeStamp
	addcreate_time  *timeutil.TimeStamp
	update_time     *timeutil.TimeStamp
	addupdate_time  *timeutil.TimeStamp
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PermissionGroup, error)
	predicates      []predicate.PermissionGroup
}

var _ ent.Mutation = (*PermissionGroupMutation)(nil)

// permissiongroupOption allows management of the mutation configuration using functional options.
type permissiongroupOption func(*PermissionGroupMutation)

// newPermissionGroupMutation creates new mutation for the PermissionGroup entity.
func newPermissionGroupMutation(c config, op Op, opts ...permissiongroupOption) *PermissionGroupMutation {
	m := &PermissionGroupMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionGroupID sets the ID field of the mutation.
func withPermissionGroupID(id int) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionGroup
		)
		m.oldValue = func(ctx context.Context) (*PermissionGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionGroup sets the old PermissionGroup of the mutation.
func withPermissionGroup(node *PermissionGroup) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		m.oldValue = func(context.Context) (*PermissionGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionGroup entities.
func (m *PermissionGroupMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPermissionName sets the "permission_name" field.
func (m *PermissionGroupMutation) SetPermissionName(s string) {
	m.permission_name = &s
}

// PermissionName returns the value of the "permission_name" field in the mutation.
func (m *PermissionGroupMutation) PermissionName() (r string, exists bool) {
	v := m.permission_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionName returns the old "permission_name" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldPermissionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionName: %w", err)
	}
	return oldValue.PermissionName, nil
}

// ResetPermissionName resets all changes to the "permission_name" field.
func (m *PermissionGroupMutation) ResetPermissionName() {
	m.permission_name = nil
}

// SetIoc sets the "ioc" field.
func (m *PermissionGroupMutation) SetIoc(s string) {
	m.ioc = &s
}

// Ioc returns the value of the "ioc" field in the mutation.
func (m *PermissionGroupMutation) Ioc() (r string, exists bool) {
	v := m.ioc
	if v == nil {
		return
	}
	return *v, true
}

// OldIoc returns the old "ioc" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldIoc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIoc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIoc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIoc: %w", err)
	}
	return oldValue.Ioc, nil
}

// ResetIoc resets all changes to the "ioc" field.
func (m *PermissionGroupMutation) ResetIoc() {
	m.ioc = nil
}

// SetSort sets the "sort" field.
func (m *PermissionGroupMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PermissionGroupMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *PermissionGroupMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PermissionGroupMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *PermissionGroupMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetLeft sets the "left" field.
func (m *PermissionGroupMutation) SetLeft(i int32) {
	m.left = &i
	m.addleft = nil
}

// Left returns the value of the "left" field in the mutation.
func (m *PermissionGroupMutation) Left() (r int32, exists bool) {
	v := m.left
	if v == nil {
		return
	}
	return *v, true
}

// OldLeft returns the old "left" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldLeft(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeft: %w", err)
	}
	return oldValue.Left, nil
}

// AddLeft adds i to the "left" field.
func (m *PermissionGroupMutation) AddLeft(i int32) {
	if m.addleft != nil {
		*m.addleft += i
	} else {
		m.addleft = &i
	}
}

// AddedLeft returns the value that was added to the "left" field in this mutation.
func (m *PermissionGroupMutation) AddedLeft() (r int32, exists bool) {
	v := m.addleft
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeft resets all changes to the "left" field.
func (m *PermissionGroupMutation) ResetLeft() {
	m.left = nil
	m.addleft = nil
}

// SetRight sets the "right" field.
func (m *PermissionGroupMutation) SetRight(i int32) {
	m.right = &i
	m.addright = nil
}

// Right returns the value of the "right" field in the mutation.
func (m *PermissionGroupMutation) Right() (r int32, exists bool) {
	v := m.right
	if v == nil {
		return
	}
	return *v, true
}

// OldRight returns the old "right" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldRight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRight: %w", err)
	}
	return oldValue.Right, nil
}

// AddRight adds i to the "right" field.
func (m *PermissionGroupMutation) AddRight(i int32) {
	if m.addright != nil {
		*m.addright += i
	} else {
		m.addright = &i
	}
}

// AddedRight returns the value that was added to the "right" field in this mutation.
func (m *PermissionGroupMutation) AddedRight() (r int32, exists bool) {
	v := m.addright
	if v == nil {
		return
	}
	return *v, true
}

// ResetRight resets all changes to the "right" field.
func (m *PermissionGroupMutation) ResetRight() {
	m.right = nil
	m.addright = nil
}

// SetState sets the "state" field.
func (m *PermissionGroupMutation) SetState(ss state.SwitchState) {
	m.state = &ss
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *PermissionGroupMutation) State() (r state.SwitchState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldState(ctx context.Context) (v state.SwitchState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds ss to the "state" field.
func (m *PermissionGroupMutation) AddState(ss state.SwitchState) {
	if m.addstate != nil {
		*m.addstate += ss
	} else {
		m.addstate = &ss
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *PermissionGroupMutation) AddedState() (r state.SwitchState, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *PermissionGroupMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreateTime sets the "create_time" field.
func (m *PermissionGroupMutation) SetCreateTime(ts timeutil.TimeStamp) {
	m.create_time = &ts
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PermissionGroupMutation) CreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldCreateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds ts to the "create_time" field.
func (m *PermissionGroupMutation) AddCreateTime(ts timeutil.TimeStamp) {
	if m.addcreate_time != nil {
		*m.addcreate_time += ts
	} else {
		m.addcreate_time = &ts
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *PermissionGroupMutation) AddedCreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PermissionGroupMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PermissionGroupMutation) SetUpdateTime(ts timeutil.TimeStamp) {
	m.update_time = &ts
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PermissionGroupMutation) UpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldUpdateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds ts to the "update_time" field.
func (m *PermissionGroupMutation) AddUpdateTime(ts timeutil.TimeStamp) {
	if m.addupdate_time != nil {
		*m.addupdate_time += ts
	} else {
		m.addupdate_time = &ts
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *PermissionGroupMutation) AddedUpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PermissionGroupMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// Where appends a list predicates to the PermissionGroupMutation builder.
func (m *PermissionGroupMutation) Where(ps ...predicate.PermissionGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionGroup).
func (m *PermissionGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionGroupMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.permission_name != nil {
		fields = append(fields, permissiongroup.FieldPermissionName)
	}
	if m.ioc != nil {
		fields = append(fields, permissiongroup.FieldIoc)
	}
	if m.sort != nil {
		fields = append(fields, permissiongroup.FieldSort)
	}
	if m.left != nil {
		fields = append(fields, permissiongroup.FieldLeft)
	}
	if m.right != nil {
		fields = append(fields, permissiongroup.FieldRight)
	}
	if m.state != nil {
		fields = append(fields, permissiongroup.FieldState)
	}
	if m.create_time != nil {
		fields = append(fields, permissiongroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, permissiongroup.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldPermissionName:
		return m.PermissionName()
	case permissiongroup.FieldIoc:
		return m.Ioc()
	case permissiongroup.FieldSort:
		return m.Sort()
	case permissiongroup.FieldLeft:
		return m.Left()
	case permissiongroup.FieldRight:
		return m.Right()
	case permissiongroup.FieldState:
		return m.State()
	case permissiongroup.FieldCreateTime:
		return m.CreateTime()
	case permissiongroup.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissiongroup.FieldPermissionName:
		return m.OldPermissionName(ctx)
	case permissiongroup.FieldIoc:
		return m.OldIoc(ctx)
	case permissiongroup.FieldSort:
		return m.OldSort(ctx)
	case permissiongroup.FieldLeft:
		return m.OldLeft(ctx)
	case permissiongroup.FieldRight:
		return m.OldRight(ctx)
	case permissiongroup.FieldState:
		return m.OldState(ctx)
	case permissiongroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case permissiongroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldPermissionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionName(v)
		return nil
	case permissiongroup.FieldIoc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIoc(v)
		return nil
	case permissiongroup.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case permissiongroup.FieldLeft:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeft(v)
		return nil
	case permissiongroup.FieldRight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRight(v)
		return nil
	case permissiongroup.FieldState:
		v, ok := value.(state.SwitchState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case permissiongroup.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case permissiongroup.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionGroupMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, permissiongroup.FieldSort)
	}
	if m.addleft != nil {
		fields = append(fields, permissiongroup.FieldLeft)
	}
	if m.addright != nil {
		fields = append(fields, permissiongroup.FieldRight)
	}
	if m.addstate != nil {
		fields = append(fields, permissiongroup.FieldState)
	}
	if m.addcreate_time != nil {
		fields = append(fields, permissiongroup.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, permissiongroup.FieldUpdateTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldSort:
		return m.AddedSort()
	case permissiongroup.FieldLeft:
		return m.AddedLeft()
	case permissiongroup.FieldRight:
		return m.AddedRight()
	case permissiongroup.FieldState:
		return m.AddedState()
	case permissiongroup.FieldCreateTime:
		return m.AddedCreateTime()
	case permissiongroup.FieldUpdateTime:
		return m.AddedUpdateTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case permissiongroup.FieldLeft:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeft(v)
		return nil
	case permissiongroup.FieldRight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRight(v)
		return nil
	case permissiongroup.FieldState:
		v, ok := value.(state.SwitchState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case permissiongroup.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case permissiongroup.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PermissionGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ResetField(name string) error {
	switch name {
	case permissiongroup.FieldPermissionName:
		m.ResetPermissionName()
		return nil
	case permissiongroup.FieldIoc:
		m.ResetIoc()
		return nil
	case permissiongroup.FieldSort:
		m.ResetSort()
		return nil
	case permissiongroup.FieldLeft:
		m.ResetLeft()
		return nil
	case permissiongroup.FieldRight:
		m.ResetRight()
		return nil
	case permissiongroup.FieldState:
		m.ResetState()
		return nil
	case permissiongroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case permissiongroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionGroup edge %s", name)
}

// PermissionRelatedRouterMutation represents an operation that mutates the PermissionRelatedRouter nodes in the graph.
type PermissionRelatedRouterMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	router_id           *uuid.UUID
	permission_group_id *uuid.UUID
	create_time         *timeutil.TimeStamp
	addcreate_time      *timeutil.TimeStamp
	update_time         *timeutil.TimeStamp
	addupdate_time      *timeutil.TimeStamp
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*PermissionRelatedRouter, error)
	predicates          []predicate.PermissionRelatedRouter
}

var _ ent.Mutation = (*PermissionRelatedRouterMutation)(nil)

// permissionrelatedrouterOption allows management of the mutation configuration using functional options.
type permissionrelatedrouterOption func(*PermissionRelatedRouterMutation)

// newPermissionRelatedRouterMutation creates new mutation for the PermissionRelatedRouter entity.
func newPermissionRelatedRouterMutation(c config, op Op, opts ...permissionrelatedrouterOption) *PermissionRelatedRouterMutation {
	m := &PermissionRelatedRouterMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionRelatedRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionRelatedRouterID sets the ID field of the mutation.
func withPermissionRelatedRouterID(id int) permissionrelatedrouterOption {
	return func(m *PermissionRelatedRouterMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionRelatedRouter
		)
		m.oldValue = func(ctx context.Context) (*PermissionRelatedRouter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionRelatedRouter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionRelatedRouter sets the old PermissionRelatedRouter of the mutation.
func withPermissionRelatedRouter(node *PermissionRelatedRouter) permissionrelatedrouterOption {
	return func(m *PermissionRelatedRouterMutation) {
		m.oldValue = func(context.Context) (*PermissionRelatedRouter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionRelatedRouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionRelatedRouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionRelatedRouter entities.
func (m *PermissionRelatedRouterMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionRelatedRouterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionRelatedRouterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionRelatedRouter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouterID sets the "router_id" field.
func (m *PermissionRelatedRouterMutation) SetRouterID(u uuid.UUID) {
	m.router_id = &u
}

// RouterID returns the value of the "router_id" field in the mutation.
func (m *PermissionRelatedRouterMutation) RouterID() (r uuid.UUID, exists bool) {
	v := m.router_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRouterID returns the old "router_id" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldRouterID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouterID: %w", err)
	}
	return oldValue.RouterID, nil
}

// ResetRouterID resets all changes to the "router_id" field.
func (m *PermissionRelatedRouterMutation) ResetRouterID() {
	m.router_id = nil
}

// SetPermissionGroupID sets the "permission_group_id" field.
func (m *PermissionRelatedRouterMutation) SetPermissionGroupID(u uuid.UUID) {
	m.permission_group_id = &u
}

// PermissionGroupID returns the value of the "permission_group_id" field in the mutation.
func (m *PermissionRelatedRouterMutation) PermissionGroupID() (r uuid.UUID, exists bool) {
	v := m.permission_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionGroupID returns the old "permission_group_id" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldPermissionGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionGroupID: %w", err)
	}
	return oldValue.PermissionGroupID, nil
}

// ResetPermissionGroupID resets all changes to the "permission_group_id" field.
func (m *PermissionRelatedRouterMutation) ResetPermissionGroupID() {
	m.permission_group_id = nil
}

// SetCreateTime sets the "create_time" field.
func (m *PermissionRelatedRouterMutation) SetCreateTime(ts timeutil.TimeStamp) {
	m.create_time = &ts
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PermissionRelatedRouterMutation) CreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldCreateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds ts to the "create_time" field.
func (m *PermissionRelatedRouterMutation) AddCreateTime(ts timeutil.TimeStamp) {
	if m.addcreate_time != nil {
		*m.addcreate_time += ts
	} else {
		m.addcreate_time = &ts
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *PermissionRelatedRouterMutation) AddedCreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PermissionRelatedRouterMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PermissionRelatedRouterMutation) SetUpdateTime(ts timeutil.TimeStamp) {
	m.update_time = &ts
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PermissionRelatedRouterMutation) UpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PermissionRelatedRouter entity.
// If the PermissionRelatedRouter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionRelatedRouterMutation) OldUpdateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds ts to the "update_time" field.
func (m *PermissionRelatedRouterMutation) AddUpdateTime(ts timeutil.TimeStamp) {
	if m.addupdate_time != nil {
		*m.addupdate_time += ts
	} else {
		m.addupdate_time = &ts
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *PermissionRelatedRouterMutation) AddedUpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PermissionRelatedRouterMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// Where appends a list predicates to the PermissionRelatedRouterMutation builder.
func (m *PermissionRelatedRouterMutation) Where(ps ...predicate.PermissionRelatedRouter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionRelatedRouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionRelatedRouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PermissionRelatedRouter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionRelatedRouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionRelatedRouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PermissionRelatedRouter).
func (m *PermissionRelatedRouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionRelatedRouterMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.router_id != nil {
		fields = append(fields, permissionrelatedrouter.FieldRouterID)
	}
	if m.permission_group_id != nil {
		fields = append(fields, permissionrelatedrouter.FieldPermissionGroupID)
	}
	if m.create_time != nil {
		fields = append(fields, permissionrelatedrouter.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, permissionrelatedrouter.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionRelatedRouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissionrelatedrouter.FieldRouterID:
		return m.RouterID()
	case permissionrelatedrouter.FieldPermissionGroupID:
		return m.PermissionGroupID()
	case permissionrelatedrouter.FieldCreateTime:
		return m.CreateTime()
	case permissionrelatedrouter.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionRelatedRouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissionrelatedrouter.FieldRouterID:
		return m.OldRouterID(ctx)
	case permissionrelatedrouter.FieldPermissionGroupID:
		return m.OldPermissionGroupID(ctx)
	case permissionrelatedrouter.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case permissionrelatedrouter.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionRelatedRouter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionRelatedRouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissionrelatedrouter.FieldRouterID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouterID(v)
		return nil
	case permissionrelatedrouter.FieldPermissionGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionGroupID(v)
		return nil
	case permissionrelatedrouter.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case permissionrelatedrouter.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionRelatedRouter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionRelatedRouterMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, permissionrelatedrouter.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, permissionrelatedrouter.FieldUpdateTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionRelatedRouterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissionrelatedrouter.FieldCreateTime:
		return m.AddedCreateTime()
	case permissionrelatedrouter.FieldUpdateTime:
		return m.AddedUpdateTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionRelatedRouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissionrelatedrouter.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case permissionrelatedrouter.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionRelatedRouter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionRelatedRouterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionRelatedRouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PermissionRelatedRouter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ResetField(name string) error {
	switch name {
	case permissionrelatedrouter.FieldRouterID:
		m.ResetRouterID()
		return nil
	case permissionrelatedrouter.FieldPermissionGroupID:
		m.ResetPermissionGroupID()
		return nil
	case permissionrelatedrouter.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case permissionrelatedrouter.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown PermissionRelatedRouter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionRelatedRouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionRelatedRouterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionRelatedRouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionRelatedRouterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionRelatedRouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionRelatedRouterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PermissionRelatedRouter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionRelatedRouterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PermissionRelatedRouter edge %s", name)
}

// RouterMutation represents an operation that mutates the Router nodes in the graph.
type RouterMutation struct {
	config
	op             Op
	typ            string
	id             *int
	route_name     *string
	route          *string
	description    *string
	state          *state.SwitchState
	addstate       *state.SwitchState
	create_time    *timeutil.TimeStamp
	addcreate_time *timeutil.TimeStamp
	update_time    *timeutil.TimeStamp
	addupdate_time *timeutil.TimeStamp
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Router, error)
	predicates     []predicate.Router
}

var _ ent.Mutation = (*RouterMutation)(nil)

// routerOption allows management of the mutation configuration using functional options.
type routerOption func(*RouterMutation)

// newRouterMutation creates new mutation for the Router entity.
func newRouterMutation(c config, op Op, opts ...routerOption) *RouterMutation {
	m := &RouterMutation{
		config:        c,
		op:            op,
		typ:           TypeRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterID sets the ID field of the mutation.
func withRouterID(id int) routerOption {
	return func(m *RouterMutation) {
		var (
			err   error
			once  sync.Once
			value *Router
		)
		m.oldValue = func(ctx context.Context) (*Router, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Router.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouter sets the old Router of the mutation.
func withRouter(node *Router) routerOption {
	return func(m *RouterMutation) {
		m.oldValue = func(context.Context) (*Router, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Router entities.
func (m *RouterMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Router.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRouteName sets the "route_name" field.
func (m *RouterMutation) SetRouteName(s string) {
	m.route_name = &s
}

// RouteName returns the value of the "route_name" field in the mutation.
func (m *RouterMutation) RouteName() (r string, exists bool) {
	v := m.route_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteName returns the old "route_name" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldRouteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteName: %w", err)
	}
	return oldValue.RouteName, nil
}

// ResetRouteName resets all changes to the "route_name" field.
func (m *RouterMutation) ResetRouteName() {
	m.route_name = nil
}

// SetRoute sets the "route" field.
func (m *RouterMutation) SetRoute(s string) {
	m.route = &s
}

// Route returns the value of the "route" field in the mutation.
func (m *RouterMutation) Route() (r string, exists bool) {
	v := m.route
	if v == nil {
		return
	}
	return *v, true
}

// OldRoute returns the old "route" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldRoute(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoute: %w", err)
	}
	return oldValue.Route, nil
}

// ResetRoute resets all changes to the "route" field.
func (m *RouterMutation) ResetRoute() {
	m.route = nil
}

// SetDescription sets the "description" field.
func (m *RouterMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RouterMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RouterMutation) ResetDescription() {
	m.description = nil
}

// SetState sets the "state" field.
func (m *RouterMutation) SetState(ss state.SwitchState) {
	m.state = &ss
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *RouterMutation) State() (r state.SwitchState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldState(ctx context.Context) (v state.SwitchState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds ss to the "state" field.
func (m *RouterMutation) AddState(ss state.SwitchState) {
	if m.addstate != nil {
		*m.addstate += ss
	} else {
		m.addstate = &ss
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *RouterMutation) AddedState() (r state.SwitchState, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *RouterMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreateTime sets the "create_time" field.
func (m *RouterMutation) SetCreateTime(ts timeutil.TimeStamp) {
	m.create_time = &ts
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RouterMutation) CreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldCreateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds ts to the "create_time" field.
func (m *RouterMutation) AddCreateTime(ts timeutil.TimeStamp) {
	if m.addcreate_time != nil {
		*m.addcreate_time += ts
	} else {
		m.addcreate_time = &ts
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *RouterMutation) AddedCreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RouterMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RouterMutation) SetUpdateTime(ts timeutil.TimeStamp) {
	m.update_time = &ts
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RouterMutation) UpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldUpdateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds ts to the "update_time" field.
func (m *RouterMutation) AddUpdateTime(ts timeutil.TimeStamp) {
	if m.addupdate_time != nil {
		*m.addupdate_time += ts
	} else {
		m.addupdate_time = &ts
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *RouterMutation) AddedUpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RouterMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// Where appends a list predicates to the RouterMutation builder.
func (m *RouterMutation) Where(ps ...predicate.Router) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Router, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Router).
func (m *RouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.route_name != nil {
		fields = append(fields, router.FieldRouteName)
	}
	if m.route != nil {
		fields = append(fields, router.FieldRoute)
	}
	if m.description != nil {
		fields = append(fields, router.FieldDescription)
	}
	if m.state != nil {
		fields = append(fields, router.FieldState)
	}
	if m.create_time != nil {
		fields = append(fields, router.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, router.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case router.FieldRouteName:
		return m.RouteName()
	case router.FieldRoute:
		return m.Route()
	case router.FieldDescription:
		return m.Description()
	case router.FieldState:
		return m.State()
	case router.FieldCreateTime:
		return m.CreateTime()
	case router.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case router.FieldRouteName:
		return m.OldRouteName(ctx)
	case router.FieldRoute:
		return m.OldRoute(ctx)
	case router.FieldDescription:
		return m.OldDescription(ctx)
	case router.FieldState:
		return m.OldState(ctx)
	case router.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case router.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Router field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case router.FieldRouteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteName(v)
		return nil
	case router.FieldRoute:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoute(v)
		return nil
	case router.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case router.FieldState:
		v, ok := value.(state.SwitchState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case router.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case router.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, router.FieldState)
	}
	if m.addcreate_time != nil {
		fields = append(fields, router.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, router.FieldUpdateTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case router.FieldState:
		return m.AddedState()
	case router.FieldCreateTime:
		return m.AddedCreateTime()
	case router.FieldUpdateTime:
		return m.AddedUpdateTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case router.FieldState:
		v, ok := value.(state.SwitchState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case router.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case router.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Router numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Router nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterMutation) ResetField(name string) error {
	switch name {
	case router.FieldRouteName:
		m.ResetRouteName()
		return nil
	case router.FieldRoute:
		m.ResetRoute()
		return nil
	case router.FieldDescription:
		m.ResetDescription()
		return nil
	case router.FieldState:
		m.ResetState()
		return nil
	case router.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case router.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Router unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Router edge %s", name)
}

// SourceMutation represents an operation that mutates the Source nodes in the graph.
type SourceMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	_type           *auth.Type
	add_type        *auth.Type
	name            *string
	is_active       *bool
	is_sync_enabled *bool
	cfg             *auth.Config
	create_time     *timeutil.TimeStamp
	addcreate_time  *timeutil.TimeStamp
	update_time     *timeutil.TimeStamp
	addupdate_time  *timeutil.TimeStamp
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Source, error)
	predicates      []predicate.Source
}

var _ ent.Mutation = (*SourceMutation)(nil)

// sourceOption allows management of the mutation configuration using functional options.
type sourceOption func(*SourceMutation)

// newSourceMutation creates new mutation for the Source entity.
func newSourceMutation(c config, op Op, opts ...sourceOption) *SourceMutation {
	m := &SourceMutation{
		config:        c,
		op:            op,
		typ:           TypeSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceID sets the ID field of the mutation.
func withSourceID(id int64) sourceOption {
	return func(m *SourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Source
		)
		m.oldValue = func(ctx context.Context) (*Source, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Source.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSource sets the old Source of the mutation.
func withSource(node *Source) sourceOption {
	return func(m *SourceMutation) {
		m.oldValue = func(context.Context) (*Source, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Source entities.
func (m *SourceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Source.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SourceMutation) SetType(a auth.Type) {
	m._type = &a
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *SourceMutation) GetType() (r auth.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldType(ctx context.Context) (v auth.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds a to the "type" field.
func (m *SourceMutation) AddType(a auth.Type) {
	if m.add_type != nil {
		*m.add_type += a
	} else {
		m.add_type = &a
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *SourceMutation) AddedType() (r auth.Type, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *SourceMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetName sets the "name" field.
func (m *SourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SourceMutation) ResetName() {
	m.name = nil
}

// SetIsActive sets the "is_active" field.
func (m *SourceMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SourceMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SourceMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsSyncEnabled sets the "is_sync_enabled" field.
func (m *SourceMutation) SetIsSyncEnabled(b bool) {
	m.is_sync_enabled = &b
}

// IsSyncEnabled returns the value of the "is_sync_enabled" field in the mutation.
func (m *SourceMutation) IsSyncEnabled() (r bool, exists bool) {
	v := m.is_sync_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSyncEnabled returns the old "is_sync_enabled" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldIsSyncEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSyncEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSyncEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSyncEnabled: %w", err)
	}
	return oldValue.IsSyncEnabled, nil
}

// ResetIsSyncEnabled resets all changes to the "is_sync_enabled" field.
func (m *SourceMutation) ResetIsSyncEnabled() {
	m.is_sync_enabled = nil
}

// SetCfg sets the "cfg" field.
func (m *SourceMutation) SetCfg(a auth.Config) {
	m.cfg = &a
}

// Cfg returns the value of the "cfg" field in the mutation.
func (m *SourceMutation) Cfg() (r auth.Config, exists bool) {
	v := m.cfg
	if v == nil {
		return
	}
	return *v, true
}

// OldCfg returns the old "cfg" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldCfg(ctx context.Context) (v auth.Config, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfg: %w", err)
	}
	return oldValue.Cfg, nil
}

// ResetCfg resets all changes to the "cfg" field.
func (m *SourceMutation) ResetCfg() {
	m.cfg = nil
}

// SetCreateTime sets the "create_time" field.
func (m *SourceMutation) SetCreateTime(ts timeutil.TimeStamp) {
	m.create_time = &ts
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SourceMutation) CreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldCreateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds ts to the "create_time" field.
func (m *SourceMutation) AddCreateTime(ts timeutil.TimeStamp) {
	if m.addcreate_time != nil {
		*m.addcreate_time += ts
	} else {
		m.addcreate_time = &ts
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *SourceMutation) AddedCreateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SourceMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SourceMutation) SetUpdateTime(ts timeutil.TimeStamp) {
	m.update_time = &ts
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SourceMutation) UpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldUpdateTime(ctx context.Context) (v timeutil.TimeStamp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds ts to the "update_time" field.
func (m *SourceMutation) AddUpdateTime(ts timeutil.TimeStamp) {
	if m.addupdate_time != nil {
		*m.addupdate_time += ts
	} else {
		m.addupdate_time = &ts
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *SourceMutation) AddedUpdateTime() (r timeutil.TimeStamp, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SourceMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// Where appends a list predicates to the SourceMutation builder.
func (m *SourceMutation) Where(ps ...predicate.Source) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Source, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Source).
func (m *SourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, source.FieldType)
	}
	if m.name != nil {
		fields = append(fields, source.FieldName)
	}
	if m.is_active != nil {
		fields = append(fields, source.FieldIsActive)
	}
	if m.is_sync_enabled != nil {
		fields = append(fields, source.FieldIsSyncEnabled)
	}
	if m.cfg != nil {
		fields = append(fields, source.FieldCfg)
	}
	if m.create_time != nil {
		fields = append(fields, source.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, source.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case source.FieldType:
		return m.GetType()
	case source.FieldName:
		return m.Name()
	case source.FieldIsActive:
		return m.IsActive()
	case source.FieldIsSyncEnabled:
		return m.IsSyncEnabled()
	case source.FieldCfg:
		return m.Cfg()
	case source.FieldCreateTime:
		return m.CreateTime()
	case source.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case source.FieldType:
		return m.OldType(ctx)
	case source.FieldName:
		return m.OldName(ctx)
	case source.FieldIsActive:
		return m.OldIsActive(ctx)
	case source.FieldIsSyncEnabled:
		return m.OldIsSyncEnabled(ctx)
	case source.FieldCfg:
		return m.OldCfg(ctx)
	case source.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case source.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Source field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case source.FieldType:
		v, ok := value.(auth.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case source.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case source.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case source.FieldIsSyncEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSyncEnabled(v)
		return nil
	case source.FieldCfg:
		v, ok := value.(auth.Config)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfg(v)
		return nil
	case source.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case source.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, source.FieldType)
	}
	if m.addcreate_time != nil {
		fields = append(fields, source.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, source.FieldUpdateTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case source.FieldType:
		return m.AddedType()
	case source.FieldCreateTime:
		return m.AddedCreateTime()
	case source.FieldUpdateTime:
		return m.AddedUpdateTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case source.FieldType:
		v, ok := value.(auth.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case source.FieldCreateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case source.FieldUpdateTime:
		v, ok := value.(timeutil.TimeStamp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Source numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Source nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceMutation) ResetField(name string) error {
	switch name {
	case source.FieldType:
		m.ResetType()
		return nil
	case source.FieldName:
		m.ResetName()
		return nil
	case source.FieldIsActive:
		m.ResetIsActive()
		return nil
	case source.FieldIsSyncEnabled:
		m.ResetIsSyncEnabled()
		return nil
	case source.FieldCfg:
		m.ResetCfg()
		return nil
	case source.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case source.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Source unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Source edge %s", name)
}

// SourceDataMutation represents an operation that mutates the SourceData nodes in the graph.
type SourceDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *uuid.UUID
	_type         *string
	sub_type      *string
	info          *string
	snapshot      *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SourceData, error)
	predicates    []predicate.SourceData
}

var _ ent.Mutation = (*SourceDataMutation)(nil)

// sourcedataOption allows management of the mutation configuration using functional options.
type sourcedataOption func(*SourceDataMutation)

// newSourceDataMutation creates new mutation for the SourceData entity.
func newSourceDataMutation(c config, op Op, opts ...sourcedataOption) *SourceDataMutation {
	m := &SourceDataMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceDataID sets the ID field of the mutation.
func withSourceDataID(id int) sourcedataOption {
	return func(m *SourceDataMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceData
		)
		m.oldValue = func(ctx context.Context) (*SourceData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceData sets the old SourceData of the mutation.
func withSourceData(node *SourceData) sourcedataOption {
	return func(m *SourceDataMutation) {
		m.oldValue = func(context.Context) (*SourceData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceData entities.
func (m *SourceDataMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SourceDataMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SourceDataMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SourceDataMutation) ResetUserID() {
	m.user_id = nil
}

// SetType sets the "type" field.
func (m *SourceDataMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SourceDataMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SourceDataMutation) ResetType() {
	m._type = nil
}

// SetSubType sets the "sub_type" field.
func (m *SourceDataMutation) SetSubType(s string) {
	m.sub_type = &s
}

// SubType returns the value of the "sub_type" field in the mutation.
func (m *SourceDataMutation) SubType() (r string, exists bool) {
	v := m.sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubType returns the old "sub_type" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubType: %w", err)
	}
	return oldValue.SubType, nil
}

// ResetSubType resets all changes to the "sub_type" field.
func (m *SourceDataMutation) ResetSubType() {
	m.sub_type = nil
}

// SetInfo sets the "info" field.
func (m *SourceDataMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *SourceDataMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *SourceDataMutation) ResetInfo() {
	m.info = nil
}

// SetSnapshot sets the "snapshot" field.
func (m *SourceDataMutation) SetSnapshot(s string) {
	m.snapshot = &s
}

// Snapshot returns the value of the "snapshot" field in the mutation.
func (m *SourceDataMutation) Snapshot() (r string, exists bool) {
	v := m.snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshot returns the old "snapshot" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldSnapshot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshot: %w", err)
	}
	return oldValue.Snapshot, nil
}

// ResetSnapshot resets all changes to the "snapshot" field.
func (m *SourceDataMutation) ResetSnapshot() {
	m.snapshot = nil
}

// SetCreateTime sets the "create_time" field.
func (m *SourceDataMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SourceDataMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SourceDataMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SourceDataMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SourceDataMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SourceData entity.
// If the SourceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceDataMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SourceDataMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the SourceDataMutation builder.
func (m *SourceDataMutation) Where(ps ...predicate.SourceData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceData).
func (m *SourceDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceDataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_id != nil {
		fields = append(fields, sourcedata.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, sourcedata.FieldType)
	}
	if m.sub_type != nil {
		fields = append(fields, sourcedata.FieldSubType)
	}
	if m.info != nil {
		fields = append(fields, sourcedata.FieldInfo)
	}
	if m.snapshot != nil {
		fields = append(fields, sourcedata.FieldSnapshot)
	}
	if m.create_time != nil {
		fields = append(fields, sourcedata.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, sourcedata.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcedata.FieldUserID:
		return m.UserID()
	case sourcedata.FieldType:
		return m.GetType()
	case sourcedata.FieldSubType:
		return m.SubType()
	case sourcedata.FieldInfo:
		return m.Info()
	case sourcedata.FieldSnapshot:
		return m.Snapshot()
	case sourcedata.FieldCreateTime:
		return m.CreateTime()
	case sourcedata.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcedata.FieldUserID:
		return m.OldUserID(ctx)
	case sourcedata.FieldType:
		return m.OldType(ctx)
	case sourcedata.FieldSubType:
		return m.OldSubType(ctx)
	case sourcedata.FieldInfo:
		return m.OldInfo(ctx)
	case sourcedata.FieldSnapshot:
		return m.OldSnapshot(ctx)
	case sourcedata.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sourcedata.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown SourceData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcedata.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case sourcedata.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case sourcedata.FieldSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubType(v)
		return nil
	case sourcedata.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case sourcedata.FieldSnapshot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshot(v)
		return nil
	case sourcedata.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sourcedata.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown SourceData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SourceData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceDataMutation) ResetField(name string) error {
	switch name {
	case sourcedata.FieldUserID:
		m.ResetUserID()
		return nil
	case sourcedata.FieldType:
		m.ResetType()
		return nil
	case sourcedata.FieldSubType:
		m.ResetSubType()
		return nil
	case sourcedata.FieldInfo:
		m.ResetInfo()
		return nil
	case sourcedata.FieldSnapshot:
		m.ResetSnapshot()
		return nil
	case sourcedata.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sourcedata.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown SourceData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SourceData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SourceData edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	email            *string
	avatar           *string
	passwd_salt      *string
	passwd_hash_algo *string
	passwd           *string
	nickname         *string
	language         *string
	login_name       *string
	login_source     *int64
	addlogin_source  *int64
	login_type       *auth.Type
	addlogin_type    *auth.Type
	is_restricted    *bool
	is_active        *bool
	prohibit_login   *bool
	create_time      *time.Time
	update_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetPasswdSalt sets the "passwd_salt" field.
func (m *UserMutation) SetPasswdSalt(s string) {
	m.passwd_salt = &s
}

// PasswdSalt returns the value of the "passwd_salt" field in the mutation.
func (m *UserMutation) PasswdSalt() (r string, exists bool) {
	v := m.passwd_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswdSalt returns the old "passwd_salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswdSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswdSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswdSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswdSalt: %w", err)
	}
	return oldValue.PasswdSalt, nil
}

// ResetPasswdSalt resets all changes to the "passwd_salt" field.
func (m *UserMutation) ResetPasswdSalt() {
	m.passwd_salt = nil
}

// SetPasswdHashAlgo sets the "passwd_hash_algo" field.
func (m *UserMutation) SetPasswdHashAlgo(s string) {
	m.passwd_hash_algo = &s
}

// PasswdHashAlgo returns the value of the "passwd_hash_algo" field in the mutation.
func (m *UserMutation) PasswdHashAlgo() (r string, exists bool) {
	v := m.passwd_hash_algo
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswdHashAlgo returns the old "passwd_hash_algo" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswdHashAlgo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswdHashAlgo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswdHashAlgo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswdHashAlgo: %w", err)
	}
	return oldValue.PasswdHashAlgo, nil
}

// ResetPasswdHashAlgo resets all changes to the "passwd_hash_algo" field.
func (m *UserMutation) ResetPasswdHashAlgo() {
	m.passwd_hash_algo = nil
}

// SetPasswd sets the "passwd" field.
func (m *UserMutation) SetPasswd(s string) {
	m.passwd = &s
}

// Passwd returns the value of the "passwd" field in the mutation.
func (m *UserMutation) Passwd() (r string, exists bool) {
	v := m.passwd
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswd returns the old "passwd" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswd: %w", err)
	}
	return oldValue.Passwd, nil
}

// ResetPasswd resets all changes to the "passwd" field.
func (m *UserMutation) ResetPasswd() {
	m.passwd = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetLanguage sets the "language" field.
func (m *UserMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *UserMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *UserMutation) ResetLanguage() {
	m.language = nil
}

// SetLoginName sets the "login_name" field.
func (m *UserMutation) SetLoginName(s string) {
	m.login_name = &s
}

// LoginName returns the value of the "login_name" field in the mutation.
func (m *UserMutation) LoginName() (r string, exists bool) {
	v := m.login_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginName returns the old "login_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoginName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginName: %w", err)
	}
	return oldValue.LoginName, nil
}

// ResetLoginName resets all changes to the "login_name" field.
func (m *UserMutation) ResetLoginName() {
	m.login_name = nil
}

// SetLoginSource sets the "login_source" field.
func (m *UserMutation) SetLoginSource(i int64) {
	m.login_source = &i
	m.addlogin_source = nil
}

// LoginSource returns the value of the "login_source" field in the mutation.
func (m *UserMutation) LoginSource() (r int64, exists bool) {
	v := m.login_source
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginSource returns the old "login_source" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoginSource(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginSource: %w", err)
	}
	return oldValue.LoginSource, nil
}

// AddLoginSource adds i to the "login_source" field.
func (m *UserMutation) AddLoginSource(i int64) {
	if m.addlogin_source != nil {
		*m.addlogin_source += i
	} else {
		m.addlogin_source = &i
	}
}

// AddedLoginSource returns the value that was added to the "login_source" field in this mutation.
func (m *UserMutation) AddedLoginSource() (r int64, exists bool) {
	v := m.addlogin_source
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginSource resets all changes to the "login_source" field.
func (m *UserMutation) ResetLoginSource() {
	m.login_source = nil
	m.addlogin_source = nil
}

// SetLoginType sets the "login_type" field.
func (m *UserMutation) SetLoginType(a auth.Type) {
	m.login_type = &a
	m.addlogin_type = nil
}

// LoginType returns the value of the "login_type" field in the mutation.
func (m *UserMutation) LoginType() (r auth.Type, exists bool) {
	v := m.login_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginType returns the old "login_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoginType(ctx context.Context) (v auth.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginType: %w", err)
	}
	return oldValue.LoginType, nil
}

// AddLoginType adds a to the "login_type" field.
func (m *UserMutation) AddLoginType(a auth.Type) {
	if m.addlogin_type != nil {
		*m.addlogin_type += a
	} else {
		m.addlogin_type = &a
	}
}

// AddedLoginType returns the value that was added to the "login_type" field in this mutation.
func (m *UserMutation) AddedLoginType() (r auth.Type, exists bool) {
	v := m.addlogin_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginType resets all changes to the "login_type" field.
func (m *UserMutation) ResetLoginType() {
	m.login_type = nil
	m.addlogin_type = nil
}

// SetIsRestricted sets the "is_restricted" field.
func (m *UserMutation) SetIsRestricted(b bool) {
	m.is_restricted = &b
}

// IsRestricted returns the value of the "is_restricted" field in the mutation.
func (m *UserMutation) IsRestricted() (r bool, exists bool) {
	v := m.is_restricted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRestricted returns the old "is_restricted" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsRestricted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRestricted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRestricted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRestricted: %w", err)
	}
	return oldValue.IsRestricted, nil
}

// ResetIsRestricted resets all changes to the "is_restricted" field.
func (m *UserMutation) ResetIsRestricted() {
	m.is_restricted = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetProhibitLogin sets the "prohibit_login" field.
func (m *UserMutation) SetProhibitLogin(b bool) {
	m.prohibit_login = &b
}

// ProhibitLogin returns the value of the "prohibit_login" field in the mutation.
func (m *UserMutation) ProhibitLogin() (r bool, exists bool) {
	v := m.prohibit_login
	if v == nil {
		return
	}
	return *v, true
}

// OldProhibitLogin returns the old "prohibit_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProhibitLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProhibitLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProhibitLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProhibitLogin: %w", err)
	}
	return oldValue.ProhibitLogin, nil
}

// ResetProhibitLogin resets all changes to the "prohibit_login" field.
func (m *UserMutation) ResetProhibitLogin() {
	m.prohibit_login = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.passwd_salt != nil {
		fields = append(fields, user.FieldPasswdSalt)
	}
	if m.passwd_hash_algo != nil {
		fields = append(fields, user.FieldPasswdHashAlgo)
	}
	if m.passwd != nil {
		fields = append(fields, user.FieldPasswd)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.language != nil {
		fields = append(fields, user.FieldLanguage)
	}
	if m.login_name != nil {
		fields = append(fields, user.FieldLoginName)
	}
	if m.login_source != nil {
		fields = append(fields, user.FieldLoginSource)
	}
	if m.login_type != nil {
		fields = append(fields, user.FieldLoginType)
	}
	if m.is_restricted != nil {
		fields = append(fields, user.FieldIsRestricted)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.prohibit_login != nil {
		fields = append(fields, user.FieldProhibitLogin)
	}
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldPasswdSalt:
		return m.PasswdSalt()
	case user.FieldPasswdHashAlgo:
		return m.PasswdHashAlgo()
	case user.FieldPasswd:
		return m.Passwd()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldLanguage:
		return m.Language()
	case user.FieldLoginName:
		return m.LoginName()
	case user.FieldLoginSource:
		return m.LoginSource()
	case user.FieldLoginType:
		return m.LoginType()
	case user.FieldIsRestricted:
		return m.IsRestricted()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldProhibitLogin:
		return m.ProhibitLogin()
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldPasswdSalt:
		return m.OldPasswdSalt(ctx)
	case user.FieldPasswdHashAlgo:
		return m.OldPasswdHashAlgo(ctx)
	case user.FieldPasswd:
		return m.OldPasswd(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldLanguage:
		return m.OldLanguage(ctx)
	case user.FieldLoginName:
		return m.OldLoginName(ctx)
	case user.FieldLoginSource:
		return m.OldLoginSource(ctx)
	case user.FieldLoginType:
		return m.OldLoginType(ctx)
	case user.FieldIsRestricted:
		return m.OldIsRestricted(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldProhibitLogin:
		return m.OldProhibitLogin(ctx)
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldPasswdSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswdSalt(v)
		return nil
	case user.FieldPasswdHashAlgo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswdHashAlgo(v)
		return nil
	case user.FieldPasswd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswd(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case user.FieldLoginName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginName(v)
		return nil
	case user.FieldLoginSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginSource(v)
		return nil
	case user.FieldLoginType:
		v, ok := value.(auth.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginType(v)
		return nil
	case user.FieldIsRestricted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRestricted(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldProhibitLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProhibitLogin(v)
		return nil
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addlogin_source != nil {
		fields = append(fields, user.FieldLoginSource)
	}
	if m.addlogin_type != nil {
		fields = append(fields, user.FieldLoginType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLoginSource:
		return m.AddedLoginSource()
	case user.FieldLoginType:
		return m.AddedLoginType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldLoginSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginSource(v)
		return nil
	case user.FieldLoginType:
		v, ok := value.(auth.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginType(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldPasswdSalt:
		m.ResetPasswdSalt()
		return nil
	case user.FieldPasswdHashAlgo:
		m.ResetPasswdHashAlgo()
		return nil
	case user.FieldPasswd:
		m.ResetPasswd()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldLanguage:
		m.ResetLanguage()
		return nil
	case user.FieldLoginName:
		m.ResetLoginName()
		return nil
	case user.FieldLoginSource:
		m.ResetLoginSource()
		return nil
	case user.FieldLoginType:
		m.ResetLoginType()
		return nil
	case user.FieldIsRestricted:
		m.ResetIsRestricted()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldProhibitLogin:
		m.ResetProhibitLogin()
		return nil
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAuthSourceMutation represents an operation that mutates the UserAuthSource nodes in the graph.
type UserAuthSourceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	user_id         *uuid.UUID
	token           *string
	channel         *string
	device          *string
	device_detail   *string
	client_ip       *string
	remote_ip       *string
	snapshot        *string
	login_name      *string
	login_source    *int
	addlogin_source *int
	login_type      *int
	addlogin_type   *int
	create_time     *time.Time
	update_time     *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UserAuthSource, error)
	predicates      []predicate.UserAuthSource
}

var _ ent.Mutation = (*UserAuthSourceMutation)(nil)

// userauthsourceOption allows management of the mutation configuration using functional options.
type userauthsourceOption func(*UserAuthSourceMutation)

// newUserAuthSourceMutation creates new mutation for the UserAuthSource entity.
func newUserAuthSourceMutation(c config, op Op, opts ...userauthsourceOption) *UserAuthSourceMutation {
	m := &UserAuthSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAuthSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAuthSourceID sets the ID field of the mutation.
func withUserAuthSourceID(id int) userauthsourceOption {
	return func(m *UserAuthSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAuthSource
		)
		m.oldValue = func(ctx context.Context) (*UserAuthSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAuthSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAuthSource sets the old UserAuthSource of the mutation.
func withUserAuthSource(node *UserAuthSource) userauthsourceOption {
	return func(m *UserAuthSourceMutation) {
		m.oldValue = func(context.Context) (*UserAuthSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAuthSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAuthSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserAuthSource entities.
func (m *UserAuthSourceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAuthSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAuthSourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAuthSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserAuthSourceMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAuthSourceMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAuthSourceMutation) ResetUserID() {
	m.user_id = nil
}

// SetToken sets the "token" field.
func (m *UserAuthSourceMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *UserAuthSourceMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *UserAuthSourceMutation) ResetToken() {
	m.token = nil
}

// SetChannel sets the "channel" field.
func (m *UserAuthSourceMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *UserAuthSourceMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *UserAuthSourceMutation) ResetChannel() {
	m.channel = nil
}

// SetDevice sets the "device" field.
func (m *UserAuthSourceMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *UserAuthSourceMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ResetDevice resets all changes to the "device" field.
func (m *UserAuthSourceMutation) ResetDevice() {
	m.device = nil
}

// SetDeviceDetail sets the "device_detail" field.
func (m *UserAuthSourceMutation) SetDeviceDetail(s string) {
	m.device_detail = &s
}

// DeviceDetail returns the value of the "device_detail" field in the mutation.
func (m *UserAuthSourceMutation) DeviceDetail() (r string, exists bool) {
	v := m.device_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceDetail returns the old "device_detail" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldDeviceDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceDetail: %w", err)
	}
	return oldValue.DeviceDetail, nil
}

// ResetDeviceDetail resets all changes to the "device_detail" field.
func (m *UserAuthSourceMutation) ResetDeviceDetail() {
	m.device_detail = nil
}

// SetClientIP sets the "client_ip" field.
func (m *UserAuthSourceMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *UserAuthSourceMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *UserAuthSourceMutation) ResetClientIP() {
	m.client_ip = nil
}

// SetRemoteIP sets the "remote_ip" field.
func (m *UserAuthSourceMutation) SetRemoteIP(s string) {
	m.remote_ip = &s
}

// RemoteIP returns the value of the "remote_ip" field in the mutation.
func (m *UserAuthSourceMutation) RemoteIP() (r string, exists bool) {
	v := m.remote_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteIP returns the old "remote_ip" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldRemoteIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteIP: %w", err)
	}
	return oldValue.RemoteIP, nil
}

// ResetRemoteIP resets all changes to the "remote_ip" field.
func (m *UserAuthSourceMutation) ResetRemoteIP() {
	m.remote_ip = nil
}

// SetSnapshot sets the "snapshot" field.
func (m *UserAuthSourceMutation) SetSnapshot(s string) {
	m.snapshot = &s
}

// Snapshot returns the value of the "snapshot" field in the mutation.
func (m *UserAuthSourceMutation) Snapshot() (r string, exists bool) {
	v := m.snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshot returns the old "snapshot" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldSnapshot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshot: %w", err)
	}
	return oldValue.Snapshot, nil
}

// ResetSnapshot resets all changes to the "snapshot" field.
func (m *UserAuthSourceMutation) ResetSnapshot() {
	m.snapshot = nil
}

// SetLoginName sets the "login_name" field.
func (m *UserAuthSourceMutation) SetLoginName(s string) {
	m.login_name = &s
}

// LoginName returns the value of the "login_name" field in the mutation.
func (m *UserAuthSourceMutation) LoginName() (r string, exists bool) {
	v := m.login_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginName returns the old "login_name" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldLoginName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginName: %w", err)
	}
	return oldValue.LoginName, nil
}

// ResetLoginName resets all changes to the "login_name" field.
func (m *UserAuthSourceMutation) ResetLoginName() {
	m.login_name = nil
}

// SetLoginSource sets the "login_source" field.
func (m *UserAuthSourceMutation) SetLoginSource(i int) {
	m.login_source = &i
	m.addlogin_source = nil
}

// LoginSource returns the value of the "login_source" field in the mutation.
func (m *UserAuthSourceMutation) LoginSource() (r int, exists bool) {
	v := m.login_source
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginSource returns the old "login_source" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldLoginSource(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginSource: %w", err)
	}
	return oldValue.LoginSource, nil
}

// AddLoginSource adds i to the "login_source" field.
func (m *UserAuthSourceMutation) AddLoginSource(i int) {
	if m.addlogin_source != nil {
		*m.addlogin_source += i
	} else {
		m.addlogin_source = &i
	}
}

// AddedLoginSource returns the value that was added to the "login_source" field in this mutation.
func (m *UserAuthSourceMutation) AddedLoginSource() (r int, exists bool) {
	v := m.addlogin_source
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginSource resets all changes to the "login_source" field.
func (m *UserAuthSourceMutation) ResetLoginSource() {
	m.login_source = nil
	m.addlogin_source = nil
}

// SetLoginType sets the "login_type" field.
func (m *UserAuthSourceMutation) SetLoginType(i int) {
	m.login_type = &i
	m.addlogin_type = nil
}

// LoginType returns the value of the "login_type" field in the mutation.
func (m *UserAuthSourceMutation) LoginType() (r int, exists bool) {
	v := m.login_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginType returns the old "login_type" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldLoginType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginType: %w", err)
	}
	return oldValue.LoginType, nil
}

// AddLoginType adds i to the "login_type" field.
func (m *UserAuthSourceMutation) AddLoginType(i int) {
	if m.addlogin_type != nil {
		*m.addlogin_type += i
	} else {
		m.addlogin_type = &i
	}
}

// AddedLoginType returns the value that was added to the "login_type" field in this mutation.
func (m *UserAuthSourceMutation) AddedLoginType() (r int, exists bool) {
	v := m.addlogin_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginType resets all changes to the "login_type" field.
func (m *UserAuthSourceMutation) ResetLoginType() {
	m.login_type = nil
	m.addlogin_type = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserAuthSourceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserAuthSourceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserAuthSourceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserAuthSourceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserAuthSourceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserAuthSource entity.
// If the UserAuthSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthSourceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserAuthSourceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserAuthSourceMutation builder.
func (m *UserAuthSourceMutation) Where(ps ...predicate.UserAuthSource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAuthSourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAuthSourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAuthSource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAuthSourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAuthSourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAuthSource).
func (m *UserAuthSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAuthSourceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user_id != nil {
		fields = append(fields, userauthsource.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, userauthsource.FieldToken)
	}
	if m.channel != nil {
		fields = append(fields, userauthsource.FieldChannel)
	}
	if m.device != nil {
		fields = append(fields, userauthsource.FieldDevice)
	}
	if m.device_detail != nil {
		fields = append(fields, userauthsource.FieldDeviceDetail)
	}
	if m.client_ip != nil {
		fields = append(fields, userauthsource.FieldClientIP)
	}
	if m.remote_ip != nil {
		fields = append(fields, userauthsource.FieldRemoteIP)
	}
	if m.snapshot != nil {
		fields = append(fields, userauthsource.FieldSnapshot)
	}
	if m.login_name != nil {
		fields = append(fields, userauthsource.FieldLoginName)
	}
	if m.login_source != nil {
		fields = append(fields, userauthsource.FieldLoginSource)
	}
	if m.login_type != nil {
		fields = append(fields, userauthsource.FieldLoginType)
	}
	if m.create_time != nil {
		fields = append(fields, userauthsource.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userauthsource.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAuthSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userauthsource.FieldUserID:
		return m.UserID()
	case userauthsource.FieldToken:
		return m.Token()
	case userauthsource.FieldChannel:
		return m.Channel()
	case userauthsource.FieldDevice:
		return m.Device()
	case userauthsource.FieldDeviceDetail:
		return m.DeviceDetail()
	case userauthsource.FieldClientIP:
		return m.ClientIP()
	case userauthsource.FieldRemoteIP:
		return m.RemoteIP()
	case userauthsource.FieldSnapshot:
		return m.Snapshot()
	case userauthsource.FieldLoginName:
		return m.LoginName()
	case userauthsource.FieldLoginSource:
		return m.LoginSource()
	case userauthsource.FieldLoginType:
		return m.LoginType()
	case userauthsource.FieldCreateTime:
		return m.CreateTime()
	case userauthsource.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAuthSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userauthsource.FieldUserID:
		return m.OldUserID(ctx)
	case userauthsource.FieldToken:
		return m.OldToken(ctx)
	case userauthsource.FieldChannel:
		return m.OldChannel(ctx)
	case userauthsource.FieldDevice:
		return m.OldDevice(ctx)
	case userauthsource.FieldDeviceDetail:
		return m.OldDeviceDetail(ctx)
	case userauthsource.FieldClientIP:
		return m.OldClientIP(ctx)
	case userauthsource.FieldRemoteIP:
		return m.OldRemoteIP(ctx)
	case userauthsource.FieldSnapshot:
		return m.OldSnapshot(ctx)
	case userauthsource.FieldLoginName:
		return m.OldLoginName(ctx)
	case userauthsource.FieldLoginSource:
		return m.OldLoginSource(ctx)
	case userauthsource.FieldLoginType:
		return m.OldLoginType(ctx)
	case userauthsource.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userauthsource.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserAuthSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAuthSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userauthsource.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userauthsource.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case userauthsource.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case userauthsource.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case userauthsource.FieldDeviceDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceDetail(v)
		return nil
	case userauthsource.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case userauthsource.FieldRemoteIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteIP(v)
		return nil
	case userauthsource.FieldSnapshot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshot(v)
		return nil
	case userauthsource.FieldLoginName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginName(v)
		return nil
	case userauthsource.FieldLoginSource:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginSource(v)
		return nil
	case userauthsource.FieldLoginType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginType(v)
		return nil
	case userauthsource.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userauthsource.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserAuthSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAuthSourceMutation) AddedFields() []string {
	var fields []string
	if m.addlogin_source != nil {
		fields = append(fields, userauthsource.FieldLoginSource)
	}
	if m.addlogin_type != nil {
		fields = append(fields, userauthsource.FieldLoginType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAuthSourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userauthsource.FieldLoginSource:
		return m.AddedLoginSource()
	case userauthsource.FieldLoginType:
		return m.AddedLoginType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAuthSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userauthsource.FieldLoginSource:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginSource(v)
		return nil
	case userauthsource.FieldLoginType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginType(v)
		return nil
	}
	return fmt.Errorf("unknown UserAuthSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAuthSourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAuthSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAuthSourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAuthSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAuthSourceMutation) ResetField(name string) error {
	switch name {
	case userauthsource.FieldUserID:
		m.ResetUserID()
		return nil
	case userauthsource.FieldToken:
		m.ResetToken()
		return nil
	case userauthsource.FieldChannel:
		m.ResetChannel()
		return nil
	case userauthsource.FieldDevice:
		m.ResetDevice()
		return nil
	case userauthsource.FieldDeviceDetail:
		m.ResetDeviceDetail()
		return nil
	case userauthsource.FieldClientIP:
		m.ResetClientIP()
		return nil
	case userauthsource.FieldRemoteIP:
		m.ResetRemoteIP()
		return nil
	case userauthsource.FieldSnapshot:
		m.ResetSnapshot()
		return nil
	case userauthsource.FieldLoginName:
		m.ResetLoginName()
		return nil
	case userauthsource.FieldLoginSource:
		m.ResetLoginSource()
		return nil
	case userauthsource.FieldLoginType:
		m.ResetLoginType()
		return nil
	case userauthsource.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userauthsource.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserAuthSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAuthSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAuthSourceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAuthSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAuthSourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAuthSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAuthSourceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAuthSourceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserAuthSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAuthSourceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserAuthSource edge %s", name)
}

// UserRelatedRoleMutation represents an operation that mutates the UserRelatedRole nodes in the graph.
type UserRelatedRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *uuid.UUID
	role_id       *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserRelatedRole, error)
	predicates    []predicate.UserRelatedRole
}

var _ ent.Mutation = (*UserRelatedRoleMutation)(nil)

// userrelatedroleOption allows management of the mutation configuration using functional options.
type userrelatedroleOption func(*UserRelatedRoleMutation)

// newUserRelatedRoleMutation creates new mutation for the UserRelatedRole entity.
func newUserRelatedRoleMutation(c config, op Op, opts ...userrelatedroleOption) *UserRelatedRoleMutation {
	m := &UserRelatedRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRelatedRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRelatedRoleID sets the ID field of the mutation.
func withUserRelatedRoleID(id int) userrelatedroleOption {
	return func(m *UserRelatedRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRelatedRole
		)
		m.oldValue = func(ctx context.Context) (*UserRelatedRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRelatedRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRelatedRole sets the old UserRelatedRole of the mutation.
func withUserRelatedRole(node *UserRelatedRole) userrelatedroleOption {
	return func(m *UserRelatedRoleMutation) {
		m.oldValue = func(context.Context) (*UserRelatedRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRelatedRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRelatedRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRelatedRole entities.
func (m *UserRelatedRoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRelatedRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRelatedRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRelatedRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserRelatedRoleMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRelatedRoleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRelatedRole entity.
// If the UserRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRelatedRoleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRelatedRoleMutation) ResetUserID() {
	m.user_id = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRelatedRoleMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRelatedRoleMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRelatedRole entity.
// If the UserRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRelatedRoleMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRelatedRoleMutation) ResetRoleID() {
	m.role_id = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserRelatedRoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserRelatedRoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserRelatedRole entity.
// If the UserRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRelatedRoleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserRelatedRoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserRelatedRoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserRelatedRoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserRelatedRole entity.
// If the UserRelatedRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRelatedRoleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserRelatedRoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserRelatedRoleMutation builder.
func (m *UserRelatedRoleMutation) Where(ps ...predicate.UserRelatedRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRelatedRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRelatedRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRelatedRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRelatedRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRelatedRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRelatedRole).
func (m *UserRelatedRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRelatedRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_id != nil {
		fields = append(fields, userrelatedrole.FieldUserID)
	}
	if m.role_id != nil {
		fields = append(fields, userrelatedrole.FieldRoleID)
	}
	if m.create_time != nil {
		fields = append(fields, userrelatedrole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userrelatedrole.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRelatedRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrelatedrole.FieldUserID:
		return m.UserID()
	case userrelatedrole.FieldRoleID:
		return m.RoleID()
	case userrelatedrole.FieldCreateTime:
		return m.CreateTime()
	case userrelatedrole.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRelatedRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrelatedrole.FieldUserID:
		return m.OldUserID(ctx)
	case userrelatedrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrelatedrole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userrelatedrole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserRelatedRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRelatedRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrelatedrole.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userrelatedrole.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrelatedrole.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userrelatedrole.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserRelatedRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRelatedRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRelatedRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRelatedRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRelatedRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRelatedRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRelatedRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRelatedRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRelatedRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRelatedRoleMutation) ResetField(name string) error {
	switch name {
	case userrelatedrole.FieldUserID:
		m.ResetUserID()
		return nil
	case userrelatedrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrelatedrole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userrelatedrole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserRelatedRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRelatedRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRelatedRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRelatedRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRelatedRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRelatedRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRelatedRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRelatedRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserRelatedRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRelatedRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserRelatedRole edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role_name     *string
	state         *state.SwitchState
	addstate      *state.SwitchState
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserRole, error)
	predicates    []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id int) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRole entities.
func (m *UserRoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleName sets the "role_name" field.
func (m *UserRoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *UserRoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *UserRoleMutation) ResetRoleName() {
	m.role_name = nil
}

// SetState sets the "state" field.
func (m *UserRoleMutation) SetState(ss state.SwitchState) {
	m.state = &ss
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *UserRoleMutation) State() (r state.SwitchState, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldState(ctx context.Context) (v state.SwitchState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds ss to the "state" field.
func (m *UserRoleMutation) AddState(ss state.SwitchState) {
	if m.addstate != nil {
		*m.addstate += ss
	} else {
		m.addstate = &ss
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *UserRoleMutation) AddedState() (r state.SwitchState, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *UserRoleMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserRoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserRoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserRoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserRoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserRoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserRoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.role_name != nil {
		fields = append(fields, userrole.FieldRoleName)
	}
	if m.state != nil {
		fields = append(fields, userrole.FieldState)
	}
	if m.create_time != nil {
		fields = append(fields, userrole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userrole.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldRoleName:
		return m.RoleName()
	case userrole.FieldState:
		return m.State()
	case userrole.FieldCreateTime:
		return m.CreateTime()
	case userrole.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldRoleName:
		return m.OldRoleName(ctx)
	case userrole.FieldState:
		return m.OldState(ctx)
	case userrole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userrole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case userrole.FieldState:
		v, ok := value.(state.SwitchState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case userrole.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userrole.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, userrole.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldState:
		v, ok := value.(state.SwitchState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldRoleName:
		m.ResetRoleName()
		return nil
	case userrole.FieldState:
		m.ResetState()
		return nil
	case userrole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userrole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserRole edge %s", name)
}

// WakatimeMutation represents an operation that mutates the Wakatime nodes in the graph.
type WakatimeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *uuid.UUID
	key           *string
	api           *string
	state         *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Wakatime, error)
	predicates    []predicate.Wakatime
}

var _ ent.Mutation = (*WakatimeMutation)(nil)

// wakatimeOption allows management of the mutation configuration using functional options.
type wakatimeOption func(*WakatimeMutation)

// newWakatimeMutation creates new mutation for the Wakatime entity.
func newWakatimeMutation(c config, op Op, opts ...wakatimeOption) *WakatimeMutation {
	m := &WakatimeMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeID sets the ID field of the mutation.
func withWakatimeID(id int) wakatimeOption {
	return func(m *WakatimeMutation) {
		var (
			err   error
			once  sync.Once
			value *Wakatime
		)
		m.oldValue = func(ctx context.Context) (*Wakatime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wakatime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatime sets the old Wakatime of the mutation.
func withWakatime(node *Wakatime) wakatimeOption {
	return func(m *WakatimeMutation) {
		m.oldValue = func(context.Context) (*Wakatime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wakatime entities.
func (m *WakatimeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wakatime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *WakatimeMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WakatimeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WakatimeMutation) ResetUserID() {
	m.user_id = nil
}

// SetKey sets the "key" field.
func (m *WakatimeMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *WakatimeMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *WakatimeMutation) ResetKey() {
	m.key = nil
}

// SetAPI sets the "api" field.
func (m *WakatimeMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *WakatimeMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI resets all changes to the "api" field.
func (m *WakatimeMutation) ResetAPI() {
	m.api = nil
}

// SetState sets the "state" field.
func (m *WakatimeMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *WakatimeMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *WakatimeMutation) ResetState() {
	m.state = nil
}

// SetCreateTime sets the "create_time" field.
func (m *WakatimeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WakatimeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WakatimeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WakatimeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WakatimeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Wakatime entity.
// If the Wakatime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WakatimeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the WakatimeMutation builder.
func (m *WakatimeMutation) Where(ps ...predicate.Wakatime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wakatime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wakatime).
func (m *WakatimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, wakatime.FieldUserID)
	}
	if m.key != nil {
		fields = append(fields, wakatime.FieldKey)
	}
	if m.api != nil {
		fields = append(fields, wakatime.FieldAPI)
	}
	if m.state != nil {
		fields = append(fields, wakatime.FieldState)
	}
	if m.create_time != nil {
		fields = append(fields, wakatime.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wakatime.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wakatime.FieldUserID:
		return m.UserID()
	case wakatime.FieldKey:
		return m.Key()
	case wakatime.FieldAPI:
		return m.API()
	case wakatime.FieldState:
		return m.State()
	case wakatime.FieldCreateTime:
		return m.CreateTime()
	case wakatime.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wakatime.FieldUserID:
		return m.OldUserID(ctx)
	case wakatime.FieldKey:
		return m.OldKey(ctx)
	case wakatime.FieldAPI:
		return m.OldAPI(ctx)
	case wakatime.FieldState:
		return m.OldState(ctx)
	case wakatime.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wakatime.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Wakatime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wakatime.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wakatime.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case wakatime.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case wakatime.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case wakatime.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wakatime.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Wakatime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Wakatime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Wakatime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeMutation) ResetField(name string) error {
	switch name {
	case wakatime.FieldUserID:
		m.ResetUserID()
		return nil
	case wakatime.FieldKey:
		m.ResetKey()
		return nil
	case wakatime.FieldAPI:
		m.ResetAPI()
		return nil
	case wakatime.FieldState:
		m.ResetState()
		return nil
	case wakatime.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wakatime.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Wakatime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Wakatime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Wakatime edge %s", name)
}

// WakatimeCategoryMutation represents an operation that mutates the WakatimeCategory nodes in the graph.
type WakatimeCategoryMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	wakatime_id      *uuid.UUID
	user_id          *uuid.UUID
	name             *string
	total_seconds    *int64
	addtotal_seconds *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*WakatimeCategory, error)
	predicates       []predicate.WakatimeCategory
}

var _ ent.Mutation = (*WakatimeCategoryMutation)(nil)

// wakatimecategoryOption allows management of the mutation configuration using functional options.
type wakatimecategoryOption func(*WakatimeCategoryMutation)

// newWakatimeCategoryMutation creates new mutation for the WakatimeCategory entity.
func newWakatimeCategoryMutation(c config, op Op, opts ...wakatimecategoryOption) *WakatimeCategoryMutation {
	m := &WakatimeCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeCategoryID sets the ID field of the mutation.
func withWakatimeCategoryID(id uuid.UUID) wakatimecategoryOption {
	return func(m *WakatimeCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeCategory
		)
		m.oldValue = func(ctx context.Context) (*WakatimeCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeCategory sets the old WakatimeCategory of the mutation.
func withWakatimeCategory(node *WakatimeCategory) wakatimecategoryOption {
	return func(m *WakatimeCategoryMutation) {
		m.oldValue = func(context.Context) (*WakatimeCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WakatimeCategory entities.
func (m *WakatimeCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WakatimeCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WakatimeCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WakatimeCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WakatimeCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WakatimeCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WakatimeCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetWakatimeID sets the "wakatime_id" field.
func (m *WakatimeCategoryMutation) SetWakatimeID(u uuid.UUID) {
	m.wakatime_id = &u
}

// WakatimeID returns the value of the "wakatime_id" field in the mutation.
func (m *WakatimeCategoryMutation) WakatimeID() (r uuid.UUID, exists bool) {
	v := m.wakatime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWakatimeID returns the old "wakatime_id" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldWakatimeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWakatimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWakatimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWakatimeID: %w", err)
	}
	return oldValue.WakatimeID, nil
}

// ResetWakatimeID resets all changes to the "wakatime_id" field.
func (m *WakatimeCategoryMutation) ResetWakatimeID() {
	m.wakatime_id = nil
}

// SetUserID sets the "user_id" field.
func (m *WakatimeCategoryMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WakatimeCategoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WakatimeCategoryMutation) ResetUserID() {
	m.user_id = nil
}

// SetName sets the "name" field.
func (m *WakatimeCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WakatimeCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WakatimeCategoryMutation) ResetName() {
	m.name = nil
}

// SetTotalSeconds sets the "total_seconds" field.
func (m *WakatimeCategoryMutation) SetTotalSeconds(i int64) {
	m.total_seconds = &i
	m.addtotal_seconds = nil
}

// TotalSeconds returns the value of the "total_seconds" field in the mutation.
func (m *WakatimeCategoryMutation) TotalSeconds() (r int64, exists bool) {
	v := m.total_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSeconds returns the old "total_seconds" field's value of the WakatimeCategory entity.
// If the WakatimeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeCategoryMutation) OldTotalSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSeconds: %w", err)
	}
	return oldValue.TotalSeconds, nil
}

// AddTotalSeconds adds i to the "total_seconds" field.
func (m *WakatimeCategoryMutation) AddTotalSeconds(i int64) {
	if m.addtotal_seconds != nil {
		*m.addtotal_seconds += i
	} else {
		m.addtotal_seconds = &i
	}
}

// AddedTotalSeconds returns the value that was added to the "total_seconds" field in this mutation.
func (m *WakatimeCategoryMutation) AddedTotalSeconds() (r int64, exists bool) {
	v := m.addtotal_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSeconds resets all changes to the "total_seconds" field.
func (m *WakatimeCategoryMutation) ResetTotalSeconds() {
	m.total_seconds = nil
	m.addtotal_seconds = nil
}

// Where appends a list predicates to the WakatimeCategoryMutation builder.
func (m *WakatimeCategoryMutation) Where(ps ...predicate.WakatimeCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeCategory).
func (m *WakatimeCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, wakatimecategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wakatimecategory.FieldUpdateTime)
	}
	if m.wakatime_id != nil {
		fields = append(fields, wakatimecategory.FieldWakatimeID)
	}
	if m.user_id != nil {
		fields = append(fields, wakatimecategory.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, wakatimecategory.FieldName)
	}
	if m.total_seconds != nil {
		fields = append(fields, wakatimecategory.FieldTotalSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wakatimecategory.FieldCreateTime:
		return m.CreateTime()
	case wakatimecategory.FieldUpdateTime:
		return m.UpdateTime()
	case wakatimecategory.FieldWakatimeID:
		return m.WakatimeID()
	case wakatimecategory.FieldUserID:
		return m.UserID()
	case wakatimecategory.FieldName:
		return m.Name()
	case wakatimecategory.FieldTotalSeconds:
		return m.TotalSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wakatimecategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wakatimecategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wakatimecategory.FieldWakatimeID:
		return m.OldWakatimeID(ctx)
	case wakatimecategory.FieldUserID:
		return m.OldUserID(ctx)
	case wakatimecategory.FieldName:
		return m.OldName(ctx)
	case wakatimecategory.FieldTotalSeconds:
		return m.OldTotalSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown WakatimeCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wakatimecategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wakatimecategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wakatimecategory.FieldWakatimeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWakatimeID(v)
		return nil
	case wakatimecategory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wakatimecategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case wakatimecategory.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_seconds != nil {
		fields = append(fields, wakatimecategory.FieldTotalSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wakatimecategory.FieldTotalSeconds:
		return m.AddedTotalSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wakatimecategory.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeCategoryMutation) ResetField(name string) error {
	switch name {
	case wakatimecategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wakatimecategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wakatimecategory.FieldWakatimeID:
		m.ResetWakatimeID()
		return nil
	case wakatimecategory.FieldUserID:
		m.ResetUserID()
		return nil
	case wakatimecategory.FieldName:
		m.ResetName()
		return nil
	case wakatimecategory.FieldTotalSeconds:
		m.ResetTotalSeconds()
		return nil
	}
	return fmt.Errorf("unknown WakatimeCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeCategory edge %s", name)
}

// WakatimeDependencyMutation represents an operation that mutates the WakatimeDependency nodes in the graph.
type WakatimeDependencyMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	wakatime_id      *uuid.UUID
	user_id          *uuid.UUID
	name             *string
	total_seconds    *int64
	addtotal_seconds *int64
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*WakatimeDependency, error)
	predicates       []predicate.WakatimeDependency
}

var _ ent.Mutation = (*WakatimeDependencyMutation)(nil)

// wakatimedependencyOption allows management of the mutation configuration using functional options.
type wakatimedependencyOption func(*WakatimeDependencyMutation)

// newWakatimeDependencyMutation creates new mutation for the WakatimeDependency entity.
func newWakatimeDependencyMutation(c config, op Op, opts ...wakatimedependencyOption) *WakatimeDependencyMutation {
	m := &WakatimeDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeDependencyID sets the ID field of the mutation.
func withWakatimeDependencyID(id uuid.UUID) wakatimedependencyOption {
	return func(m *WakatimeDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeDependency
		)
		m.oldValue = func(ctx context.Context) (*WakatimeDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeDependency sets the old WakatimeDependency of the mutation.
func withWakatimeDependency(node *WakatimeDependency) wakatimedependencyOption {
	return func(m *WakatimeDependencyMutation) {
		m.oldValue = func(context.Context) (*WakatimeDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WakatimeDependency entities.
func (m *WakatimeDependencyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeDependencyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeDependencyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *WakatimeDependencyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WakatimeDependencyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WakatimeDependencyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WakatimeDependencyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WakatimeDependencyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WakatimeDependencyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetWakatimeID sets the "wakatime_id" field.
func (m *WakatimeDependencyMutation) SetWakatimeID(u uuid.UUID) {
	m.wakatime_id = &u
}

// WakatimeID returns the value of the "wakatime_id" field in the mutation.
func (m *WakatimeDependencyMutation) WakatimeID() (r uuid.UUID, exists bool) {
	v := m.wakatime_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWakatimeID returns the old "wakatime_id" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldWakatimeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWakatimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWakatimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWakatimeID: %w", err)
	}
	return oldValue.WakatimeID, nil
}

// ResetWakatimeID resets all changes to the "wakatime_id" field.
func (m *WakatimeDependencyMutation) ResetWakatimeID() {
	m.wakatime_id = nil
}

// SetUserID sets the "user_id" field.
func (m *WakatimeDependencyMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WakatimeDependencyMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WakatimeDependencyMutation) ResetUserID() {
	m.user_id = nil
}

// SetName sets the "name" field.
func (m *WakatimeDependencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WakatimeDependencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WakatimeDependencyMutation) ResetName() {
	m.name = nil
}

// SetTotalSeconds sets the "total_seconds" field.
func (m *WakatimeDependencyMutation) SetTotalSeconds(i int64) {
	m.total_seconds = &i
	m.addtotal_seconds = nil
}

// TotalSeconds returns the value of the "total_seconds" field in the mutation.
func (m *WakatimeDependencyMutation) TotalSeconds() (r int64, exists bool) {
	v := m.total_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSeconds returns the old "total_seconds" field's value of the WakatimeDependency entity.
// If the WakatimeDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WakatimeDependencyMutation) OldTotalSeconds(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSeconds: %w", err)
	}
	return oldValue.TotalSeconds, nil
}

// AddTotalSeconds adds i to the "total_seconds" field.
func (m *WakatimeDependencyMutation) AddTotalSeconds(i int64) {
	if m.addtotal_seconds != nil {
		*m.addtotal_seconds += i
	} else {
		m.addtotal_seconds = &i
	}
}

// AddedTotalSeconds returns the value that was added to the "total_seconds" field in this mutation.
func (m *WakatimeDependencyMutation) AddedTotalSeconds() (r int64, exists bool) {
	v := m.addtotal_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSeconds resets all changes to the "total_seconds" field.
func (m *WakatimeDependencyMutation) ResetTotalSeconds() {
	m.total_seconds = nil
	m.addtotal_seconds = nil
}

// Where appends a list predicates to the WakatimeDependencyMutation builder.
func (m *WakatimeDependencyMutation) Where(ps ...predicate.WakatimeDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeDependency).
func (m *WakatimeDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeDependencyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, wakatimedependency.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, wakatimedependency.FieldUpdateTime)
	}
	if m.wakatime_id != nil {
		fields = append(fields, wakatimedependency.FieldWakatimeID)
	}
	if m.user_id != nil {
		fields = append(fields, wakatimedependency.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, wakatimedependency.FieldName)
	}
	if m.total_seconds != nil {
		fields = append(fields, wakatimedependency.FieldTotalSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wakatimedependency.FieldCreateTime:
		return m.CreateTime()
	case wakatimedependency.FieldUpdateTime:
		return m.UpdateTime()
	case wakatimedependency.FieldWakatimeID:
		return m.WakatimeID()
	case wakatimedependency.FieldUserID:
		return m.UserID()
	case wakatimedependency.FieldName:
		return m.Name()
	case wakatimedependency.FieldTotalSeconds:
		return m.TotalSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wakatimedependency.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case wakatimedependency.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case wakatimedependency.FieldWakatimeID:
		return m.OldWakatimeID(ctx)
	case wakatimedependency.FieldUserID:
		return m.OldUserID(ctx)
	case wakatimedependency.FieldName:
		return m.OldName(ctx)
	case wakatimedependency.FieldTotalSeconds:
		return m.OldTotalSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown WakatimeDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wakatimedependency.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case wakatimedependency.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case wakatimedependency.FieldWakatimeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWakatimeID(v)
		return nil
	case wakatimedependency.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wakatimedependency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case wakatimedependency.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeDependencyMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_seconds != nil {
		fields = append(fields, wakatimedependency.FieldTotalSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeDependencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wakatimedependency.FieldTotalSeconds:
		return m.AddedTotalSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wakatimedependency.FieldTotalSeconds:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown WakatimeDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeDependencyMutation) ResetField(name string) error {
	switch name {
	case wakatimedependency.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case wakatimedependency.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case wakatimedependency.FieldWakatimeID:
		m.ResetWakatimeID()
		return nil
	case wakatimedependency.FieldUserID:
		m.ResetUserID()
		return nil
	case wakatimedependency.FieldName:
		m.ResetName()
		return nil
	case wakatimedependency.FieldTotalSeconds:
		m.ResetTotalSeconds()
		return nil
	}
	return fmt.Errorf("unknown WakatimeDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeDependencyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeDependencyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeDependencyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeDependencyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDependency edge %s", name)
}

// WakatimeDurationMutation represents an operation that mutates the WakatimeDuration nodes in the graph.
type WakatimeDurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeDuration, error)
	predicates    []predicate.WakatimeDuration
}

var _ ent.Mutation = (*WakatimeDurationMutation)(nil)

// wakatimedurationOption allows management of the mutation configuration using functional options.
type wakatimedurationOption func(*WakatimeDurationMutation)

// newWakatimeDurationMutation creates new mutation for the WakatimeDuration entity.
func newWakatimeDurationMutation(c config, op Op, opts ...wakatimedurationOption) *WakatimeDurationMutation {
	m := &WakatimeDurationMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeDuration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeDurationID sets the ID field of the mutation.
func withWakatimeDurationID(id int) wakatimedurationOption {
	return func(m *WakatimeDurationMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeDuration
		)
		m.oldValue = func(ctx context.Context) (*WakatimeDuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeDuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeDuration sets the old WakatimeDuration of the mutation.
func withWakatimeDuration(node *WakatimeDuration) wakatimedurationOption {
	return func(m *WakatimeDurationMutation) {
		m.oldValue = func(context.Context) (*WakatimeDuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeDurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeDurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeDurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeDurationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeDuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeDurationMutation builder.
func (m *WakatimeDurationMutation) Where(ps ...predicate.WakatimeDuration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeDurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeDurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeDuration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeDurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeDurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeDuration).
func (m *WakatimeDurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeDurationMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeDurationMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeDurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeDuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeDuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeDurationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeDurationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeDurationMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeDuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeDurationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeDurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeDurationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeDuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeDurationMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeDuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeDurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeDurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeDurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeDurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeDurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeDurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeDurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeDurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeDuration edge %s", name)
}

// WakatimeEditorMutation represents an operation that mutates the WakatimeEditor nodes in the graph.
type WakatimeEditorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeEditor, error)
	predicates    []predicate.WakatimeEditor
}

var _ ent.Mutation = (*WakatimeEditorMutation)(nil)

// wakatimeeditorOption allows management of the mutation configuration using functional options.
type wakatimeeditorOption func(*WakatimeEditorMutation)

// newWakatimeEditorMutation creates new mutation for the WakatimeEditor entity.
func newWakatimeEditorMutation(c config, op Op, opts ...wakatimeeditorOption) *WakatimeEditorMutation {
	m := &WakatimeEditorMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeEditor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeEditorID sets the ID field of the mutation.
func withWakatimeEditorID(id int) wakatimeeditorOption {
	return func(m *WakatimeEditorMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeEditor
		)
		m.oldValue = func(ctx context.Context) (*WakatimeEditor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeEditor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeEditor sets the old WakatimeEditor of the mutation.
func withWakatimeEditor(node *WakatimeEditor) wakatimeeditorOption {
	return func(m *WakatimeEditorMutation) {
		m.oldValue = func(context.Context) (*WakatimeEditor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeEditorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeEditorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeEditorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeEditorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeEditor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeEditorMutation builder.
func (m *WakatimeEditorMutation) Where(ps ...predicate.WakatimeEditor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeEditorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeEditorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeEditor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeEditorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeEditorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeEditor).
func (m *WakatimeEditorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeEditorMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeEditorMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeEditorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeEditor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEditorMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeEditor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeEditorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeEditorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEditorMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeEditor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeEditorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeEditorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeEditorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeEditor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeEditorMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeEditor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeEditorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeEditorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeEditorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeEditorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeEditorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeEditorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeEditorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEditor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeEditorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEditor edge %s", name)
}

// WakatimeEntityMutation represents an operation that mutates the WakatimeEntity nodes in the graph.
type WakatimeEntityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeEntity, error)
	predicates    []predicate.WakatimeEntity
}

var _ ent.Mutation = (*WakatimeEntityMutation)(nil)

// wakatimeentityOption allows management of the mutation configuration using functional options.
type wakatimeentityOption func(*WakatimeEntityMutation)

// newWakatimeEntityMutation creates new mutation for the WakatimeEntity entity.
func newWakatimeEntityMutation(c config, op Op, opts ...wakatimeentityOption) *WakatimeEntityMutation {
	m := &WakatimeEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeEntityID sets the ID field of the mutation.
func withWakatimeEntityID(id int) wakatimeentityOption {
	return func(m *WakatimeEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeEntity
		)
		m.oldValue = func(ctx context.Context) (*WakatimeEntity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeEntity sets the old WakatimeEntity of the mutation.
func withWakatimeEntity(node *WakatimeEntity) wakatimeentityOption {
	return func(m *WakatimeEntityMutation) {
		m.oldValue = func(context.Context) (*WakatimeEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeEntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeEntityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeEntity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeEntityMutation builder.
func (m *WakatimeEntityMutation) Where(ps ...predicate.WakatimeEntity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeEntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeEntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeEntity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeEntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeEntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeEntity).
func (m *WakatimeEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeEntityMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeEntityMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeEntity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeEntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeEntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeEntityMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeEntityMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeEntityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeEntityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeEntityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeEntityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEntity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeEntityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeEntity edge %s", name)
}

// WakatimeGrandTotalMutation represents an operation that mutates the WakatimeGrandTotal nodes in the graph.
type WakatimeGrandTotalMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeGrandTotal, error)
	predicates    []predicate.WakatimeGrandTotal
}

var _ ent.Mutation = (*WakatimeGrandTotalMutation)(nil)

// wakatimegrandtotalOption allows management of the mutation configuration using functional options.
type wakatimegrandtotalOption func(*WakatimeGrandTotalMutation)

// newWakatimeGrandTotalMutation creates new mutation for the WakatimeGrandTotal entity.
func newWakatimeGrandTotalMutation(c config, op Op, opts ...wakatimegrandtotalOption) *WakatimeGrandTotalMutation {
	m := &WakatimeGrandTotalMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeGrandTotal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeGrandTotalID sets the ID field of the mutation.
func withWakatimeGrandTotalID(id int) wakatimegrandtotalOption {
	return func(m *WakatimeGrandTotalMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeGrandTotal
		)
		m.oldValue = func(ctx context.Context) (*WakatimeGrandTotal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeGrandTotal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeGrandTotal sets the old WakatimeGrandTotal of the mutation.
func withWakatimeGrandTotal(node *WakatimeGrandTotal) wakatimegrandtotalOption {
	return func(m *WakatimeGrandTotalMutation) {
		m.oldValue = func(context.Context) (*WakatimeGrandTotal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeGrandTotalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeGrandTotalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeGrandTotalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeGrandTotalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeGrandTotal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeGrandTotalMutation builder.
func (m *WakatimeGrandTotalMutation) Where(ps ...predicate.WakatimeGrandTotal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeGrandTotalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeGrandTotalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeGrandTotal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeGrandTotalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeGrandTotalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeGrandTotal).
func (m *WakatimeGrandTotalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeGrandTotalMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeGrandTotalMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeGrandTotalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeGrandTotal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeGrandTotalMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeGrandTotal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeGrandTotalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeGrandTotalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeGrandTotalMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeGrandTotal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeGrandTotalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeGrandTotalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeGrandTotalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeGrandTotalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeGrandTotalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeGrandTotalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeGrandTotalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeGrandTotalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeGrandTotalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeGrandTotal edge %s", name)
}

// WakatimeHeartBeatMutation represents an operation that mutates the WakatimeHeartBeat nodes in the graph.
type WakatimeHeartBeatMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeHeartBeat, error)
	predicates    []predicate.WakatimeHeartBeat
}

var _ ent.Mutation = (*WakatimeHeartBeatMutation)(nil)

// wakatimeheartbeatOption allows management of the mutation configuration using functional options.
type wakatimeheartbeatOption func(*WakatimeHeartBeatMutation)

// newWakatimeHeartBeatMutation creates new mutation for the WakatimeHeartBeat entity.
func newWakatimeHeartBeatMutation(c config, op Op, opts ...wakatimeheartbeatOption) *WakatimeHeartBeatMutation {
	m := &WakatimeHeartBeatMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeHeartBeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeHeartBeatID sets the ID field of the mutation.
func withWakatimeHeartBeatID(id int) wakatimeheartbeatOption {
	return func(m *WakatimeHeartBeatMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeHeartBeat
		)
		m.oldValue = func(ctx context.Context) (*WakatimeHeartBeat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeHeartBeat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeHeartBeat sets the old WakatimeHeartBeat of the mutation.
func withWakatimeHeartBeat(node *WakatimeHeartBeat) wakatimeheartbeatOption {
	return func(m *WakatimeHeartBeatMutation) {
		m.oldValue = func(context.Context) (*WakatimeHeartBeat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeHeartBeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeHeartBeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeHeartBeatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeHeartBeatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeHeartBeat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeHeartBeatMutation builder.
func (m *WakatimeHeartBeatMutation) Where(ps ...predicate.WakatimeHeartBeat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeHeartBeatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeHeartBeatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeHeartBeat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeHeartBeatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeHeartBeatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeHeartBeat).
func (m *WakatimeHeartBeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeHeartBeatMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeHeartBeatMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeHeartBeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeHeartBeat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeHeartBeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeHeartBeat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeHeartBeatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeHeartBeatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeHeartBeatMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeHeartBeat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeHeartBeatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeHeartBeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeHeartBeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeHeartBeatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeHeartBeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeHeartBeatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeHeartBeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeHeartBeatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeHeartBeatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeHeartBeat edge %s", name)
}

// WakatimeLanguageMutation represents an operation that mutates the WakatimeLanguage nodes in the graph.
type WakatimeLanguageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeLanguage, error)
	predicates    []predicate.WakatimeLanguage
}

var _ ent.Mutation = (*WakatimeLanguageMutation)(nil)

// wakatimelanguageOption allows management of the mutation configuration using functional options.
type wakatimelanguageOption func(*WakatimeLanguageMutation)

// newWakatimeLanguageMutation creates new mutation for the WakatimeLanguage entity.
func newWakatimeLanguageMutation(c config, op Op, opts ...wakatimelanguageOption) *WakatimeLanguageMutation {
	m := &WakatimeLanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeLanguageID sets the ID field of the mutation.
func withWakatimeLanguageID(id int) wakatimelanguageOption {
	return func(m *WakatimeLanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeLanguage
		)
		m.oldValue = func(ctx context.Context) (*WakatimeLanguage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeLanguage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeLanguage sets the old WakatimeLanguage of the mutation.
func withWakatimeLanguage(node *WakatimeLanguage) wakatimelanguageOption {
	return func(m *WakatimeLanguageMutation) {
		m.oldValue = func(context.Context) (*WakatimeLanguage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeLanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeLanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeLanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeLanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeLanguage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeLanguageMutation builder.
func (m *WakatimeLanguageMutation) Where(ps ...predicate.WakatimeLanguage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeLanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeLanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeLanguage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeLanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeLanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeLanguage).
func (m *WakatimeLanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeLanguageMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeLanguageMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeLanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeLanguage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeLanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeLanguage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeLanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeLanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeLanguageMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeLanguage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeLanguageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeLanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeLanguageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeLanguageMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeLanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeLanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeLanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeLanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeLanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeLanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeLanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeLanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeLanguage edge %s", name)
}

// WakatimeProjectMutation represents an operation that mutates the WakatimeProject nodes in the graph.
type WakatimeProjectMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeProject, error)
	predicates    []predicate.WakatimeProject
}

var _ ent.Mutation = (*WakatimeProjectMutation)(nil)

// wakatimeprojectOption allows management of the mutation configuration using functional options.
type wakatimeprojectOption func(*WakatimeProjectMutation)

// newWakatimeProjectMutation creates new mutation for the WakatimeProject entity.
func newWakatimeProjectMutation(c config, op Op, opts ...wakatimeprojectOption) *WakatimeProjectMutation {
	m := &WakatimeProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeProjectID sets the ID field of the mutation.
func withWakatimeProjectID(id int) wakatimeprojectOption {
	return func(m *WakatimeProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeProject
		)
		m.oldValue = func(ctx context.Context) (*WakatimeProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeProject sets the old WakatimeProject of the mutation.
func withWakatimeProject(node *WakatimeProject) wakatimeprojectOption {
	return func(m *WakatimeProjectMutation) {
		m.oldValue = func(context.Context) (*WakatimeProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeProjectMutation builder.
func (m *WakatimeProjectMutation) Where(ps ...predicate.WakatimeProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeProject).
func (m *WakatimeProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeProjectMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeProjectMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeProjectMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeProjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeProjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeProjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeProjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProject edge %s", name)
}

// WakatimeProjectDurationMutation represents an operation that mutates the WakatimeProjectDuration nodes in the graph.
type WakatimeProjectDurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeProjectDuration, error)
	predicates    []predicate.WakatimeProjectDuration
}

var _ ent.Mutation = (*WakatimeProjectDurationMutation)(nil)

// wakatimeprojectdurationOption allows management of the mutation configuration using functional options.
type wakatimeprojectdurationOption func(*WakatimeProjectDurationMutation)

// newWakatimeProjectDurationMutation creates new mutation for the WakatimeProjectDuration entity.
func newWakatimeProjectDurationMutation(c config, op Op, opts ...wakatimeprojectdurationOption) *WakatimeProjectDurationMutation {
	m := &WakatimeProjectDurationMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeProjectDuration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeProjectDurationID sets the ID field of the mutation.
func withWakatimeProjectDurationID(id int) wakatimeprojectdurationOption {
	return func(m *WakatimeProjectDurationMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeProjectDuration
		)
		m.oldValue = func(ctx context.Context) (*WakatimeProjectDuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeProjectDuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeProjectDuration sets the old WakatimeProjectDuration of the mutation.
func withWakatimeProjectDuration(node *WakatimeProjectDuration) wakatimeprojectdurationOption {
	return func(m *WakatimeProjectDurationMutation) {
		m.oldValue = func(context.Context) (*WakatimeProjectDuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeProjectDurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeProjectDurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeProjectDurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeProjectDurationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeProjectDuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeProjectDurationMutation builder.
func (m *WakatimeProjectDurationMutation) Where(ps ...predicate.WakatimeProjectDuration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeProjectDurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeProjectDurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeProjectDuration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeProjectDurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeProjectDurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeProjectDuration).
func (m *WakatimeProjectDurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeProjectDurationMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeProjectDurationMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeProjectDurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeProjectDuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectDurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeProjectDuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeProjectDurationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeProjectDurationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectDurationMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeProjectDuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeProjectDurationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeProjectDurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeProjectDurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeProjectDurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeProjectDurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeProjectDurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeProjectDurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeProjectDurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeProjectDurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectDuration edge %s", name)
}

// WakatimeProjectInfoMutation represents an operation that mutates the WakatimeProjectInfo nodes in the graph.
type WakatimeProjectInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeProjectInfo, error)
	predicates    []predicate.WakatimeProjectInfo
}

var _ ent.Mutation = (*WakatimeProjectInfoMutation)(nil)

// wakatimeprojectinfoOption allows management of the mutation configuration using functional options.
type wakatimeprojectinfoOption func(*WakatimeProjectInfoMutation)

// newWakatimeProjectInfoMutation creates new mutation for the WakatimeProjectInfo entity.
func newWakatimeProjectInfoMutation(c config, op Op, opts ...wakatimeprojectinfoOption) *WakatimeProjectInfoMutation {
	m := &WakatimeProjectInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeProjectInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeProjectInfoID sets the ID field of the mutation.
func withWakatimeProjectInfoID(id int) wakatimeprojectinfoOption {
	return func(m *WakatimeProjectInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeProjectInfo
		)
		m.oldValue = func(ctx context.Context) (*WakatimeProjectInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeProjectInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeProjectInfo sets the old WakatimeProjectInfo of the mutation.
func withWakatimeProjectInfo(node *WakatimeProjectInfo) wakatimeprojectinfoOption {
	return func(m *WakatimeProjectInfoMutation) {
		m.oldValue = func(context.Context) (*WakatimeProjectInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeProjectInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeProjectInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeProjectInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeProjectInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeProjectInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeProjectInfoMutation builder.
func (m *WakatimeProjectInfoMutation) Where(ps ...predicate.WakatimeProjectInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeProjectInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeProjectInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeProjectInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeProjectInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeProjectInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeProjectInfo).
func (m *WakatimeProjectInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeProjectInfoMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeProjectInfoMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeProjectInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeProjectInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeProjectInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeProjectInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeProjectInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeProjectInfoMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeProjectInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeProjectInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeProjectInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeProjectInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeProjectInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeProjectInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeProjectInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeProjectInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeProjectInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeProjectInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeProjectInfo edge %s", name)
}

// WakatimeSystemMutation represents an operation that mutates the WakatimeSystem nodes in the graph.
type WakatimeSystemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WakatimeSystem, error)
	predicates    []predicate.WakatimeSystem
}

var _ ent.Mutation = (*WakatimeSystemMutation)(nil)

// wakatimesystemOption allows management of the mutation configuration using functional options.
type wakatimesystemOption func(*WakatimeSystemMutation)

// newWakatimeSystemMutation creates new mutation for the WakatimeSystem entity.
func newWakatimeSystemMutation(c config, op Op, opts ...wakatimesystemOption) *WakatimeSystemMutation {
	m := &WakatimeSystemMutation{
		config:        c,
		op:            op,
		typ:           TypeWakatimeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWakatimeSystemID sets the ID field of the mutation.
func withWakatimeSystemID(id int) wakatimesystemOption {
	return func(m *WakatimeSystemMutation) {
		var (
			err   error
			once  sync.Once
			value *WakatimeSystem
		)
		m.oldValue = func(ctx context.Context) (*WakatimeSystem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WakatimeSystem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWakatimeSystem sets the old WakatimeSystem of the mutation.
func withWakatimeSystem(node *WakatimeSystem) wakatimesystemOption {
	return func(m *WakatimeSystemMutation) {
		m.oldValue = func(context.Context) (*WakatimeSystem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WakatimeSystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WakatimeSystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WakatimeSystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WakatimeSystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WakatimeSystem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the WakatimeSystemMutation builder.
func (m *WakatimeSystemMutation) Where(ps ...predicate.WakatimeSystem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WakatimeSystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WakatimeSystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WakatimeSystem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WakatimeSystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WakatimeSystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WakatimeSystem).
func (m *WakatimeSystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WakatimeSystemMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WakatimeSystemMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WakatimeSystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown WakatimeSystem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeSystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WakatimeSystem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WakatimeSystemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WakatimeSystemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WakatimeSystemMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown WakatimeSystem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WakatimeSystemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WakatimeSystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WakatimeSystemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WakatimeSystem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WakatimeSystemMutation) ResetField(name string) error {
	return fmt.Errorf("unknown WakatimeSystem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WakatimeSystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WakatimeSystemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WakatimeSystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WakatimeSystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WakatimeSystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WakatimeSystemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WakatimeSystemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WakatimeSystem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WakatimeSystemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WakatimeSystem edge %s", name)
}
